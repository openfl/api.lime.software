<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="35" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<__cast params="T" get="inline" set="null" line="38" static="1">
		<f a="value">
			<c path="__cast.T"/>
			<x path="Any"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</__cast>
	<toString get="inline" set="null" line="41" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="35" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<__cast params="T" get="inline" set="null" line="38" static="1">
			<f a="value">
				<c path="__cast.T"/>
				<x path="Any"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</__cast>
		<toString get="inline" set="null" line="41" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.utils.RegExp" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/RegExp.hx" extern="1">
		<dotall public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</dotall>
		<extended public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</extended>
		<global public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</global>
		<ignoreCase public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreCase>
		<lastIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</lastIndex>
		<multiline public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</multiline>
		<source public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</source>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</exec>
		<get_dotall set="method"><f a=""><x path="Bool"/></f></get_dotall>
		<get_extended set="method"><f a=""><x path="Bool"/></f></get_extended>
		<get_global set="method"><f a=""><x path="Bool"/></f></get_global>
		<get_ignoreCase set="method"><f a=""><x path="Bool"/></f></get_ignoreCase>
		<get_lastIndex set="method"><f a=""><x path="Int"/></f></get_lastIndex>
		<get_multiline set="method"><f a=""><x path="Bool"/></f></get_multiline>
		<get_source set="method"><f a=""><c path="String"/></f></get_source>
		<set_lastIndex set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_lastIndex>
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"RegExp"</e></m>
		</meta>
	</class>
	<class path="EReg" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/EReg.hx">
		<r><c path="flash.utils.RegExp"/></r>
		<result><d/></result>
		<match public="1" set="method" line="30">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="37">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="26">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="List" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="23" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<getProperty public="1" set="method" line="38" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<fields public="1" set="method" line="64" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="78" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compareMethods public="1" set="method" line="89" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/Std.hx">
		<isOfType public="1" set="method" line="30" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<string public="1" set="method" line="43" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseFloat public="1" set="method" line="59" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/String.hx" extern="1">
		<fromCharCode public="1" get="inline" set="null" line="37" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StringBuf.hx">
		<b><c path="String"/></b>
		<new public="1" get="inline" set="null" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/StringTools.hx">
		<startsWith public="1" set="method" line="222" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="252" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<replace public="1" set="method" line="413" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="435" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/Type.hx">
		<getClassName public="1" set="method" line="70" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="91" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="95" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="118" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="137" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="160" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="174" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getEnumConstructs public="1" set="method" line="224" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="229" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumIndex public="1" get="inline" set="null" line="294" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="UnicodeString" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/UnicodeString.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>This abstract provides consistent cross-target unicode support.

	@see https://haxe.org/manual/std-UnicodeString.html</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":access"><e>StringTools</e></m>
		</meta>
		<impl><class path="_UnicodeString.UnicodeString_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/UnicodeString.hx" private="1" module="UnicodeString" final="1"><meta>
	<m n=":keep"/>
	<m n=":access"><e>StringTools</e></m>
</meta></class></impl>
	</abstract>
	<class path="flash.events.IEventDispatcher" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1" get="accessor" set="accessor">
			<c path="flash.accessibility.AccessibilityProperties"/>
			<meta><m n=":flash.property"/></meta>
		</accessibilityProperties>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</alpha>
		<blendMode public="1" get="accessor" set="accessor">
			<x path="flash.display.BlendMode"/>
			<meta><m n=":flash.property"/></meta>
		</blendMode>
		<blendShader public="1" get="null" set="accessor">
			<c path="flash.display.Shader"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</blendShader>
		<cacheAsBitmap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cacheAsBitmap>
		<filters public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
			<meta><m n=":flash.property"/></meta>
		</filters>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<loaderInfo public="1" get="accessor" set="null">
			<c path="flash.display.LoaderInfo"/>
			<meta><m n=":flash.property"/></meta>
		</loaderInfo>
		<mask public="1" get="accessor" set="accessor">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</mask>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</mouseY>
		<name public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<opaqueBackground public="1" get="accessor" set="accessor">
			<x path="Null"><x path="UInt"/></x>
			<meta><m n=":flash.property"/></meta>
		</opaqueBackground>
		<parent public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":flash.property"/></meta>
		</parent>
		<root public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</root>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rotation>
		<rotationX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationX>
		<rotationY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationY>
		<rotationZ public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</rotationZ>
		<scale9Grid public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</scale9Grid>
		<scaleX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</scaleX>
		<scaleY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</scaleY>
		<scaleZ public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</scaleZ>
		<scrollRect public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</scrollRect>
		<stage public="1" get="accessor" set="null">
			<c path="flash.display.Stage"/>
			<meta><m n=":flash.property"/></meta>
		</stage>
		<transform public="1" get="accessor" set="accessor">
			<c path="flash.geom.Transform"/>
			<meta><m n=":flash.property"/></meta>
		</transform>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</visible>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</y>
		<z public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<get_accessibilityProperties set="method"><f a=""><c path="flash.accessibility.AccessibilityProperties"/></f></get_accessibilityProperties>
		<get_alpha set="method"><f a=""><x path="Float"/></f></get_alpha>
		<get_blendMode set="method"><f a=""><x path="flash.display.BlendMode"/></f></get_blendMode>
		<get_cacheAsBitmap set="method"><f a=""><x path="Bool"/></f></get_cacheAsBitmap>
		<get_filters set="method"><f a=""><c path="Array"><c path="flash.filters.BitmapFilter"/></c></f></get_filters>
		<get_height set="method"><f a=""><x path="Float"/></f></get_height>
		<get_loaderInfo set="method"><f a=""><c path="flash.display.LoaderInfo"/></f></get_loaderInfo>
		<get_mask set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_mask>
		<get_metaData set="method"><f a=""><d/></f></get_metaData>
		<get_mouseX set="method"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method"><f a=""><x path="Float"/></f></get_mouseY>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_opaqueBackground set="method"><f a=""><x path="Null"><x path="UInt"/></x></f></get_opaqueBackground>
		<get_parent set="method"><f a=""><c path="flash.display.DisplayObjectContainer"/></f></get_parent>
		<get_root set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_root>
		<get_rotation set="method"><f a=""><x path="Float"/></f></get_rotation>
		<get_rotationX set="method"><f a=""><x path="Float"/></f></get_rotationX>
		<get_rotationY set="method"><f a=""><x path="Float"/></f></get_rotationY>
		<get_rotationZ set="method"><f a=""><x path="Float"/></f></get_rotationZ>
		<get_scale9Grid set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_scale9Grid>
		<get_scaleX set="method"><f a=""><x path="Float"/></f></get_scaleX>
		<get_scaleY set="method"><f a=""><x path="Float"/></f></get_scaleY>
		<get_scaleZ set="method"><f a=""><x path="Float"/></f></get_scaleZ>
		<get_scrollRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_scrollRect>
		<get_stage set="method"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<get_transform set="method"><f a=""><c path="flash.geom.Transform"/></f></get_transform>
		<get_visible set="method"><f a=""><x path="Bool"/></f></get_visible>
		<get_width set="method"><f a=""><x path="Float"/></f></get_width>
		<get_x set="method"><f a=""><x path="Float"/></f></get_x>
		<get_y set="method"><f a=""><x path="Float"/></f></get_y>
		<get_z set="method"><f a=""><x path="Float"/></f></get_z>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<set_accessibilityProperties set="method"><f a="value">
	<c path="flash.accessibility.AccessibilityProperties"/>
	<c path="flash.accessibility.AccessibilityProperties"/>
</f></set_accessibilityProperties>
		<set_alpha set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_blendMode set="method"><f a="value">
	<x path="flash.display.BlendMode"/>
	<x path="flash.display.BlendMode"/>
</f></set_blendMode>
		<set_blendShader set="method"><f a="value">
	<c path="flash.display.Shader"/>
	<c path="flash.display.Shader"/>
</f></set_blendShader>
		<set_cacheAsBitmap set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmap>
		<set_filters set="method"><f a="value">
	<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
	<c path="Array"><c path="flash.filters.BitmapFilter"/></c>
</f></set_filters>
		<set_height set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<set_mask set="method"><f a="value">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></set_mask>
		<set_metaData set="method"><f a="value">
	<d/>
	<d/>
</f></set_metaData>
		<set_name set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<set_opaqueBackground set="method"><f a="value">
	<x path="Null"><x path="UInt"/></x>
	<x path="Null"><x path="UInt"/></x>
</f></set_opaqueBackground>
		<set_rotation set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<set_rotationX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationX>
		<set_rotationY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationY>
		<set_rotationZ set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotationZ>
		<set_scale9Grid set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scale9Grid>
		<set_scaleX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<set_scaleY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<set_scaleZ set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleZ>
		<set_scrollRect set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_scrollRect>
		<set_transform set="method"><f a="value">
	<c path="flash.geom.Transform"/>
	<c path="flash.geom.Transform"/>
</f></set_transform>
		<set_visible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_width set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<set_x set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_z set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_z>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1" get="accessor" set="accessor">
			<c path="flash.accessibility.AccessibilityImplementation"/>
			<meta><m n=":flash.property"/></meta>
		</accessibilityImplementation>
		<contextMenu public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenu"/>
			<meta><m n=":flash.property"/></meta>
		</contextMenu>
		<doubleClickEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</doubleClickEnabled>
		<focusRect public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</focusRect>
		<mouseEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseEnabled>
		<needsSoftKeyboard public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</softKeyboardInputAreaOfInterest>
		<tabEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</tabEnabled>
		<tabIndex public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</tabIndex>
		<get_accessibilityImplementation set="method"><f a=""><c path="flash.accessibility.AccessibilityImplementation"/></f></get_accessibilityImplementation>
		<get_contextMenu set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></get_contextMenu>
		<get_doubleClickEnabled set="method"><f a=""><x path="Bool"/></f></get_doubleClickEnabled>
		<get_focusRect set="method"><f a=""><d/></f></get_focusRect>
		<get_mouseEnabled set="method"><f a=""><x path="Bool"/></f></get_mouseEnabled>
		<get_needsSoftKeyboard set="method"><f a=""><x path="Bool"/></f></get_needsSoftKeyboard>
		<get_softKeyboardInputAreaOfInterest set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_softKeyboardInputAreaOfInterest>
		<get_tabEnabled set="method"><f a=""><x path="Bool"/></f></get_tabEnabled>
		<get_tabIndex set="method"><f a=""><x path="Int"/></f></get_tabIndex>
		<requestSoftKeyboard public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<set_accessibilityImplementation set="method"><f a="value">
	<c path="flash.accessibility.AccessibilityImplementation"/>
	<c path="flash.accessibility.AccessibilityImplementation"/>
</f></set_accessibilityImplementation>
		<set_contextMenu set="method"><f a="value">
	<c path="flash.ui.ContextMenu"/>
	<c path="flash.ui.ContextMenu"/>
</f></set_contextMenu>
		<set_doubleClickEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_doubleClickEnabled>
		<set_focusRect set="method"><f a="value">
	<d/>
	<d/>
</f></set_focusRect>
		<set_mouseEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseEnabled>
		<set_needsSoftKeyboard set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_needsSoftKeyboard>
		<set_softKeyboardInputAreaOfInterest set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_softKeyboardInputAreaOfInterest>
		<set_tabEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabEnabled>
		<set_tabIndex set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_tabIndex>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseChildren>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numChildren>
		<tabChildren public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</tabChildren>
		<textSnapshot public="1" get="accessor" set="null">
			<c path="flash.text.TextSnapshot"/>
			<meta><m n=":flash.property"/></meta>
		</textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<get_mouseChildren set="method"><f a=""><x path="Bool"/></f></get_mouseChildren>
		<get_numChildren set="method"><f a=""><x path="Int"/></f></get_numChildren>
		<get_tabChildren set="method"><f a=""><x path="Bool"/></f></get_tabChildren>
		<get_textSnapshot set="method"><f a=""><c path="flash.text.TextSnapshot"/></f></get_textSnapshot>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</removeChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<set_mouseChildren set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseChildren>
		<set_tabChildren set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabChildren>
		<stopAllMovieClips public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</stopAllMovieClips>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</buttonMode>
		<dropTarget public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</dropTarget>
		<graphics public="1" get="accessor" set="null">
			<c path="flash.display.Graphics"/>
			<meta><m n=":flash.property"/></meta>
		</graphics>
		<hitArea public="1" get="accessor" set="accessor">
			<c path="flash.display.Sprite"/>
			<meta><m n=":flash.property"/></meta>
		</hitArea>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<useHandCursor public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useHandCursor>
		<get_buttonMode set="method"><f a=""><x path="Bool"/></f></get_buttonMode>
		<get_dropTarget set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_dropTarget>
		<get_graphics set="method"><f a=""><c path="flash.display.Graphics"/></f></get_graphics>
		<get_hitArea set="method"><f a=""><c path="flash.display.Sprite"/></f></get_hitArea>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_useHandCursor set="method"><f a=""><x path="Bool"/></f></get_useHandCursor>
		<set_buttonMode set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_buttonMode>
		<set_hitArea set="method"><f a="value">
	<c path="flash.display.Sprite"/>
	<c path="flash.display.Sprite"/>
</f></set_hitArea>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<set_useHandCursor set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHandCursor>
		<startDrag public="1" set="method">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startDrag>
		<startTouchDrag public="1" set="method">
			<f a="touchPointID:?lockCenter:?bounds" v=":false:">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ lockCenter : false }</e></m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1" set="method">
			<f a="touchPointID">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.MovieClip" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</currentFrame>
		<currentFrameLabel public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</currentFrameLabel>
		<currentLabel public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</currentLabel>
		<currentLabels public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.FrameLabel"/></c>
			<meta><m n=":flash.property"/></meta>
		</currentLabels>
		<currentScene public="1" get="accessor" set="null">
			<c path="flash.display.Scene"/>
			<meta><m n=":flash.property"/></meta>
		</currentScene>
		<enabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</enabled>
		<framesLoaded public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</framesLoaded>
		<isPlaying public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</isPlaying>
		<scenes public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.Scene"/></c>
			<meta><m n=":flash.property"/></meta>
		</scenes>
		<totalFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</totalFrames>
		<trackAsMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</trackAsMenu>
		<addFrameScript public="1" set="method"><f a="restArgs">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></addFrameScript>
		<get_currentFrame set="method"><f a=""><x path="Int"/></f></get_currentFrame>
		<get_currentFrameLabel set="method"><f a=""><c path="String"/></f></get_currentFrameLabel>
		<get_currentLabel set="method"><f a=""><c path="String"/></f></get_currentLabel>
		<get_currentLabels set="method"><f a=""><c path="Array"><c path="flash.display.FrameLabel"/></c></f></get_currentLabels>
		<get_currentScene set="method"><f a=""><c path="flash.display.Scene"/></f></get_currentScene>
		<get_enabled set="method"><f a=""><x path="Bool"/></f></get_enabled>
		<get_framesLoaded set="method"><f a=""><x path="Int"/></f></get_framesLoaded>
		<get_isPlaying set="method"><f a=""><x path="Bool"/></f></get_isPlaying>
		<get_scenes set="method"><f a=""><c path="Array"><c path="flash.display.Scene"/></c></f></get_scenes>
		<get_totalFrames set="method"><f a=""><x path="Int"/></f></get_totalFrames>
		<get_trackAsMenu set="method"><f a=""><x path="Bool"/></f></get_trackAsMenu>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<x path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<x path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<set_enabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<set_trackAsMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_trackAsMenu>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="51">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="40"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<class path="flash.Boot" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" expr="false" line="52" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skip_constructor>
		<IN_E expr="0" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IN_E>
		<enum_to_string public="1" set="method" line="85" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="100" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__instanceof>
		<__clear_trace public="1" set="method" line="109" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="117" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="123" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="151" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="171" static="1">
			<f a="v:str:?maxRecursion" v="::5">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ maxRecursion : 5 }</e></m>
			</meta>
		</__string_rec>
		<fromCodePoint public="1" set="method" line="221" static="1"><f a="code">
	<x path="Int"/>
	<c path="String"/>
</f></fromCodePoint>
		<__unprotect__ set="method" line="230" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<mapDynamic public="1" set="method" line="234" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</mapDynamic>
		<filterDynamic public="1" set="method" line="242" static="1">
			<f a="d:f">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</filterDynamic>
		<start set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</start>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Lib" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getURL public="1" set="method" line="57" static="1">
			<f a="url:?target">
				<c path="flash.net.URLRequest"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getURL>
		<haxe_doc>Platform-specific Flash Library. Provides some platform-specific
	functions for the Flash target.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="flash.Vector" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="56" static="1">
			<f a="v">
				<c path="Array"><c path="ofArray.T"/></c>
				<c path="flash.Vector"><c path="ofArray.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="60" static="1">
			<f a="v">
				<c path="flash.Vector"><c path="convert.T"/></c>
				<c path="flash.Vector"><c path="convert.U"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</convert>
		<typeReference public="1" params="T" get="inline" set="null" line="91" static="1">
			<f a=""><x path="Class"><c path="flash.Vector"><c path="typeReference.T"/></c></x></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Get a run-time value referencing the `Vector` class with concrete type parameters.

		Normally in Haxe, for most of the types, type parameters are eliminated at run-time,
		so there is no way to check if a value is of a type with specific type parameters.

		However, on the Flash target, the `flash.Vector<T>` values carry type parameter
		information at run-time all the type-checks (such as `Std.isOfType` and `Std.downcast`) on them
		must be done using a `Class<T>` value that also carries the type parameters. However,
		Haxe syntax does not allow creating such values and this function exists to mitigate
		this limitation.

		It should be used as such:
		```haxe
		var specificVectorType:Class<Vector<Int>> = Vector.typeReference();
		trace(Std.isOfType(vec, specificVectorType));
		```
		or using the type-check syntax:
		```haxe
		trace(Std.isOfType(vec, (Vector.typeReference() : Class<Vector<Int>>)));
		```

		It's also helpful when working with native Flash libraries, that receive Class instances:
		```haxe
		new Signal((Vector.typeReference() : Class<Vector<Int>>));
		```]]></haxe_doc>
		</typeReference>
		<length public="1"><x path="Int"/></length>
		<fixed public="1"><x path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><x path="Null"><c path="flash.Vector.T"/></x></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<insertAt public="1" get="inline" set="null" line="50"><f a="index:element">
	<x path="Int"/>
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></insertAt>
		<removeAt public="1">
			<f a="index">
				<x path="Int"/>
				<c path="flash.Vector.T"/>
			</f>
			<meta><m n=":require"><e>flash19</e></m></meta>
		</removeAt>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><x path="UInt"/></errno>
		<stub public="1"><x path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><x path="Bool"/></silent>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.desktop.Clipboard" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/Clipboard.hx" extern="1">
		<generalClipboard public="1" get="accessor" set="null" static="1">
			<c path="flash.desktop.Clipboard"/>
			<meta><m n=":flash.property"/></meta>
		</generalClipboard>
		<get_generalClipboard set="method" static="1"><f a=""><c path="flash.desktop.Clipboard"/></f></get_generalClipboard>
		<formats public="1" get="accessor" set="null">
			<c path="Array"><x path="flash.desktop.ClipboardFormats"/></c>
			<meta><m n=":flash.property"/></meta>
		</formats>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<clearData public="1" set="method"><f a="format">
	<x path="flash.desktop.ClipboardFormats"/>
	<x path="Void"/>
</f></clearData>
		<getData public="1" set="method"><f a="format:?transferMode">
	<x path="flash.desktop.ClipboardFormats"/>
	<x path="flash.desktop.ClipboardTransferMode"/>
	<x path="flash.utils.Object"/>
</f></getData>
		<get_formats set="method"><f a=""><c path="Array"><x path="flash.desktop.ClipboardFormats"/></c></f></get_formats>
		<hasFormat public="1" set="method"><f a="format">
	<x path="flash.desktop.ClipboardFormats"/>
	<x path="Bool"/>
</f></hasFormat>
		<setData public="1" set="method">
			<f a="format:data:?serializable" v="::true">
				<x path="flash.desktop.ClipboardFormats"/>
				<x path="flash.utils.Object"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ serializable : true }</e></m></meta>
		</setData>
		<setDataHandler public="1" set="method">
			<f a="format:handler:?serializable" v="::true">
				<x path="flash.desktop.ClipboardFormats"/>
				<t path="flash.utils.Function"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ serializable : true }</e></m></meta>
		</setDataHandler>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10</e></m>
		</meta>
	</class>
	<abstract path="flash.desktop.ClipboardFormats" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardFormats.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.desktop.ClipboardFormats"</e></m>
			<m n=":require"><e>flash10</e></m>
		</meta>
		<impl><class path="flash.desktop._ClipboardFormats.ClipboardFormats_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardFormats.hx" private="1" module="flash.desktop.ClipboardFormats" extern="1" final="1">
	<AIR_PREFIX public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AIR_PREFIX>
	<BITMAP_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BITMAP_FORMAT>
	<FILE_LIST_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FILE_LIST_FORMAT>
	<FILE_PROMISE_LIST_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FILE_PROMISE_LIST_FORMAT>
	<FLASH_PREFIX public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLASH_PREFIX>
	<HTML_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HTML_FORMAT>
	<REFERENCE_PREFIX public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REFERENCE_PREFIX>
	<RICH_TEXT_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RICH_TEXT_FORMAT>
	<SERIALIZATION_PREFIX public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SERIALIZATION_PREFIX>
	<TEXT_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT_FORMAT>
	<URL_FORMAT public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardFormats"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</URL_FORMAT>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.desktop.ClipboardFormats"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.desktop._ClipboardFormats.ClipboardFormats_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardFormats.hx" private="1" module="flash.desktop.ClipboardFormats" extern="1" final="1">
		<AIR_PREFIX public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AIR_PREFIX>
		<BITMAP_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BITMAP_FORMAT>
		<FILE_LIST_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FILE_LIST_FORMAT>
		<FILE_PROMISE_LIST_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FILE_PROMISE_LIST_FORMAT>
		<FLASH_PREFIX public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLASH_PREFIX>
		<HTML_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HTML_FORMAT>
		<REFERENCE_PREFIX public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REFERENCE_PREFIX>
		<RICH_TEXT_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RICH_TEXT_FORMAT>
		<SERIALIZATION_PREFIX public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SERIALIZATION_PREFIX>
		<TEXT_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT_FORMAT>
		<URL_FORMAT public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardFormats"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</URL_FORMAT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.desktop.ClipboardFormats"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.desktop.ClipboardTransferMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardTransferMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.desktop.ClipboardTransferMode"</e></m>
			<m n=":require"><e>flash10</e></m>
		</meta>
		<impl><class path="flash.desktop._ClipboardTransferMode.ClipboardTransferMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardTransferMode.hx" private="1" module="flash.desktop.ClipboardTransferMode" extern="1" final="1">
	<CLONE_ONLY public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardTransferMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLONE_ONLY>
	<CLONE_PREFERRED public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardTransferMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLONE_PREFERRED>
	<ORIGINAL_ONLY public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardTransferMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ORIGINAL_ONLY>
	<ORIGINAL_PREFERRED public="1" set="null" static="1">
		<x path="flash.desktop.ClipboardTransferMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ORIGINAL_PREFERRED>
	<meta>
		<m n=":native"><e>"flash.desktop.ClipboardTransferMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.desktop._ClipboardTransferMode.ClipboardTransferMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/desktop/ClipboardTransferMode.hx" private="1" module="flash.desktop.ClipboardTransferMode" extern="1" final="1">
		<CLONE_ONLY public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardTransferMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLONE_ONLY>
		<CLONE_PREFERRED public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardTransferMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLONE_PREFERRED>
		<ORIGINAL_ONLY public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardTransferMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ORIGINAL_ONLY>
		<ORIGINAL_PREFERRED public="1" set="null" static="1">
			<x path="flash.desktop.ClipboardTransferMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ORIGINAL_PREFERRED>
		<meta>
			<m n=":native"><e>"flash.desktop.ClipboardTransferMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.ActionScriptVersion" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ActionScriptVersion.hx">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
		</meta>
		<impl><class path="flash.display._ActionScriptVersion.ActionScriptVersion_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ActionScriptVersion.hx" private="1" module="flash.display.ActionScriptVersion" extern="1" final="1">
	<ACTIONSCRIPT2 public="1" set="null" static="1">
		<x path="flash.display.ActionScriptVersion"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ACTIONSCRIPT2>
	<ACTIONSCRIPT3 public="1" set="null" static="1">
		<x path="flash.display.ActionScriptVersion"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ACTIONSCRIPT3>
	<meta>
		<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ActionScriptVersion.ActionScriptVersion_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ActionScriptVersion.hx" private="1" module="flash.display.ActionScriptVersion" extern="1" final="1">
		<ACTIONSCRIPT2 public="1" set="null" static="1">
			<x path="flash.display.ActionScriptVersion"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ACTIONSCRIPT2>
		<ACTIONSCRIPT3 public="1" set="null" static="1">
			<x path="flash.display.ActionScriptVersion"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ACTIONSCRIPT3>
		<meta>
			<m n=":native"><e>"flash.display.ActionScriptVersion"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Bitmap" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1" get="accessor" set="accessor">
			<c path="flash.display.BitmapData"/>
			<meta><m n=":flash.property"/></meta>
		</bitmapData>
		<pixelSnapping public="1" get="accessor" set="accessor">
			<x path="flash.display.PixelSnapping"/>
			<meta><m n=":flash.property"/></meta>
		</pixelSnapping>
		<smoothing public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</smoothing>
		<get_bitmapData set="method"><f a=""><c path="flash.display.BitmapData"/></f></get_bitmapData>
		<get_pixelSnapping set="method"><f a=""><x path="flash.display.PixelSnapping"/></f></get_pixelSnapping>
		<get_smoothing set="method"><f a=""><x path="Bool"/></f></get_smoothing>
		<set_bitmapData set="method"><f a="value">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_bitmapData>
		<set_pixelSnapping set="method"><f a="value">
	<x path="flash.display.PixelSnapping"/>
	<x path="flash.display.PixelSnapping"/>
</f></set_pixelSnapping>
		<set_smoothing set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_smoothing>
		<new public="1" set="method">
			<f a="?bitmapData:?pixelSnapping:?smoothing" v="::false">
				<c path="flash.display.BitmapData"/>
				<x path="flash.display.PixelSnapping"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.BitmapData" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<rect public="1" get="accessor" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</rect>
		<transparent public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</transparent>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<x path="flash.utils.Object"/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::::false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false }</e></m></meta>
		</copyPixels>
		<copyPixelsToByteArray public="1" set="method">
			<f a="rect:data">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyPixelsToByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":::::false">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<x path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</draw>
		<drawWithQuality public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality" v=":::::false:">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<x path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="flash.display.StageQuality"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smoothing : false }</e></m>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</drawWithQuality>
		<encode public="1" set="method">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<x path="flash.utils.Object"/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method">
			<f a="mask:color:?findColor" v="::true">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_rect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_rect>
		<get_transparent set="method"><f a=""><x path="Bool"/></f></get_transparent>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<hitTest public="1" set="method">
			<f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v="::::1">
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="flash.utils.Object"/>
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ secondAlphaThreshold : 1 }</e></m></meta>
		</hitTest>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7, high : 255, low : 0 }</e></m></meta>
		</noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7 }</e></m></meta>
		</perlinNoise>
		<pixelDissolve public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor" v=":::0:0:0">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0, numPixels : 0, randomSeed : 0 }</e></m></meta>
		</pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<threshold public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:0xFFFFFFFF:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ copySource : false, mask : 0xFFFFFFFF, color : 0 }</e></m></meta>
		</threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<new public="1" set="method">
			<f a="width:height:?transparent:?fillColor" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.display.BlendMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/BlendMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.BlendMode"</e></m>
		</meta>
		<impl><class path="flash.display._BlendMode.BlendMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/BlendMode.hx" private="1" module="flash.display.BlendMode" extern="1" final="1">
	<ADD public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADD>
	<ALPHA public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALPHA>
	<DARKEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DARKEN>
	<DIFFERENCE public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFERENCE>
	<ERASE public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ERASE>
	<HARDLIGHT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HARDLIGHT>
	<INVERT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVERT>
	<LAYER public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LAYER>
	<LIGHTEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LIGHTEN>
	<MULTIPLY public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MULTIPLY>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<OVERLAY public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OVERLAY>
	<SCREEN public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCREEN>
	<SHADER public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHADER>
	<SUBTRACT public="1" set="null" static="1">
		<x path="flash.display.BlendMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBTRACT>
	<meta>
		<m n=":native"><e>"flash.display.BlendMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._BlendMode.BlendMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/BlendMode.hx" private="1" module="flash.display.BlendMode" extern="1" final="1">
		<ADD public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADD>
		<ALPHA public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALPHA>
		<DARKEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DARKEN>
		<DIFFERENCE public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFERENCE>
		<ERASE public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ERASE>
		<HARDLIGHT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HARDLIGHT>
		<INVERT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVERT>
		<LAYER public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LAYER>
		<LIGHTEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LIGHTEN>
		<MULTIPLY public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MULTIPLY>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<OVERLAY public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OVERLAY>
		<SCREEN public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCREEN>
		<SHADER public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHADER>
		<SUBTRACT public="1" set="null" static="1">
			<x path="flash.display.BlendMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBTRACT>
		<meta>
			<m n=":native"><e>"flash.display.BlendMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.CapsStyle" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/CapsStyle.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.CapsStyle"</e></m>
		</meta>
		<impl><class path="flash.display._CapsStyle.CapsStyle_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/CapsStyle.hx" private="1" module="flash.display.CapsStyle" extern="1" final="1">
	<NONE public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<ROUND public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<SQUARE public="1" set="null" static="1">
		<x path="flash.display.CapsStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SQUARE>
	<meta>
		<m n=":native"><e>"flash.display.CapsStyle"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._CapsStyle.CapsStyle_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/CapsStyle.hx" private="1" module="flash.display.CapsStyle" extern="1" final="1">
		<NONE public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<ROUND public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<SQUARE public="1" set="null" static="1">
			<x path="flash.display.CapsStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SQUARE>
		<meta>
			<m n=":native"><e>"flash.display.CapsStyle"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.ColorCorrection" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrection.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
		<impl><class path="flash.display._ColorCorrection.ColorCorrection_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrection.hx" private="1" module="flash.display.ColorCorrection" extern="1" final="1">
	<DEFAULT public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<OFF public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OFF>
	<ON public="1" set="null" static="1">
		<x path="flash.display.ColorCorrection"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ON>
	<meta>
		<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ColorCorrection.ColorCorrection_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrection.hx" private="1" module="flash.display.ColorCorrection" extern="1" final="1">
		<DEFAULT public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<OFF public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OFF>
		<ON public="1" set="null" static="1">
			<x path="flash.display.ColorCorrection"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ON>
		<meta>
			<m n=":native"><e>"flash.display.ColorCorrection"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.ColorCorrectionSupport" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrectionSupport.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
		<impl><class path="flash.display._ColorCorrectionSupport.ColorCorrectionSupport_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrectionSupport.hx" private="1" module="flash.display.ColorCorrectionSupport" extern="1" final="1">
	<DEFAULT_OFF public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT_OFF>
	<DEFAULT_ON public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT_ON>
	<UNSUPPORTED public="1" set="null" static="1">
		<x path="flash.display.ColorCorrectionSupport"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNSUPPORTED>
	<meta>
		<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ColorCorrectionSupport.ColorCorrectionSupport_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ColorCorrectionSupport.hx" private="1" module="flash.display.ColorCorrectionSupport" extern="1" final="1">
		<DEFAULT_OFF public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT_OFF>
		<DEFAULT_ON public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT_ON>
		<UNSUPPORTED public="1" set="null" static="1">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNSUPPORTED>
		<meta>
			<m n=":native"><e>"flash.display.ColorCorrectionSupport"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.FrameLabel" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/FrameLabel.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</frame>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<get_frame set="method"><f a=""><x path="Int"/></f></get_frame>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="flash.display.GradientType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GradientType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.GradientType"</e></m>
		</meta>
		<impl><class path="flash.display._GradientType.GradientType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GradientType.hx" private="1" module="flash.display.GradientType" extern="1" final="1">
	<LINEAR public="1" set="null" static="1">
		<x path="flash.display.GradientType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR>
	<RADIAL public="1" set="null" static="1">
		<x path="flash.display.GradientType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RADIAL>
	<meta>
		<m n=":native"><e>"flash.display.GradientType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._GradientType.GradientType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GradientType.hx" private="1" module="flash.display.GradientType" extern="1" final="1">
		<LINEAR public="1" set="null" static="1">
			<x path="flash.display.GradientType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR>
		<RADIAL public="1" set="null" static="1">
			<x path="flash.display.GradientType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RADIAL>
		<meta>
			<m n=":native"><e>"flash.display.GradientType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Graphics" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Graphics.hx" extern="1" final="1">
		<beginBitmapFill public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true }</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method">
			<f a="color:?alpha" v=":1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1 }</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<x path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<x path="flash.display.SpreadMethod"/>
				<x path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</beginGradientFill>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<cubicCurveTo public="1" set="method">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method">
			<f a="x:y:width:height:ellipseWidth:?ellipseHeight" v=":::::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ellipseHeight : 0 }</e></m></meta>
		</drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth" v="::true:false">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ smooth : false, repeat : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v=":::::::0">
				<x path="flash.display.GradientType"/>
				<c path="Array"><x path="UInt"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<x path="flash.display.SpreadMethod"/>
				<x path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0 }</e></m></meta>
		</lineGradientStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineStyle public="1" set="method">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="0:0:1:false::::3">
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="flash.display.LineScaleMode"/>
				<x path="flash.display.CapsStyle"/>
				<x path="flash.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miterLimit : 3, pixelHinting : false, alpha : 1, color : 0, thickness : 0 }</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<readGraphicsData public="1" set="method">
			<f a="?recurse" v="true">
				<x path="Bool"/>
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
			</f>
			<meta>
				<m n=":value"><e>{ recurse : true }</e></m>
				<m n=":require"><e>flash11_6</e></m>
			</meta>
		</readGraphicsData>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.display.GraphicsPathWinding" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GraphicsPathWinding.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
		</meta>
		<impl><class path="flash.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GraphicsPathWinding.hx" private="1" module="flash.display.GraphicsPathWinding" extern="1" final="1">
	<EVEN_ODD public="1" set="null" static="1">
		<x path="flash.display.GraphicsPathWinding"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EVEN_ODD>
	<NON_ZERO public="1" set="null" static="1">
		<x path="flash.display.GraphicsPathWinding"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NON_ZERO>
	<meta>
		<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/GraphicsPathWinding.hx" private="1" module="flash.display.GraphicsPathWinding" extern="1" final="1">
		<EVEN_ODD public="1" set="null" static="1">
			<x path="flash.display.GraphicsPathWinding"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EVEN_ODD>
		<NON_ZERO public="1" set="null" static="1">
			<x path="flash.display.GraphicsPathWinding"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NON_ZERO>
		<meta>
			<m n=":native"><e>"flash.display.GraphicsPathWinding"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.IGraphicsData" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<abstract path="flash.display.InterpolationMethod" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/InterpolationMethod.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
		</meta>
		<impl><class path="flash.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/InterpolationMethod.hx" private="1" module="flash.display.InterpolationMethod" extern="1" final="1">
	<LINEAR_RGB public="1" set="null" static="1">
		<x path="flash.display.InterpolationMethod"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR_RGB>
	<RGB public="1" set="null" static="1">
		<x path="flash.display.InterpolationMethod"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB>
	<meta>
		<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/InterpolationMethod.hx" private="1" module="flash.display.InterpolationMethod" extern="1" final="1">
		<LINEAR_RGB public="1" set="null" static="1">
			<x path="flash.display.InterpolationMethod"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR_RGB>
		<RGB public="1" set="null" static="1">
			<x path="flash.display.InterpolationMethod"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB>
		<meta>
			<m n=":native"><e>"flash.display.InterpolationMethod"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.JointStyle" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/JointStyle.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.JointStyle"</e></m>
		</meta>
		<impl><class path="flash.display._JointStyle.JointStyle_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/JointStyle.hx" private="1" module="flash.display.JointStyle" extern="1" final="1">
	<BEVEL public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEVEL>
	<MITER public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MITER>
	<ROUND public="1" set="null" static="1">
		<x path="flash.display.JointStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<meta>
		<m n=":native"><e>"flash.display.JointStyle"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._JointStyle.JointStyle_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/JointStyle.hx" private="1" module="flash.display.JointStyle" extern="1" final="1">
		<BEVEL public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEVEL>
		<MITER public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MITER>
		<ROUND public="1" set="null" static="1">
			<x path="flash.display.JointStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<meta>
			<m n=":native"><e>"flash.display.JointStyle"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.LineScaleMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/LineScaleMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
		</meta>
		<impl><class path="flash.display._LineScaleMode.LineScaleMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/LineScaleMode.hx" private="1" module="flash.display.LineScaleMode" extern="1" final="1">
	<HORIZONTAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HORIZONTAL>
	<NONE public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<VERTICAL public="1" set="null" static="1">
		<x path="flash.display.LineScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VERTICAL>
	<meta>
		<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._LineScaleMode.LineScaleMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/LineScaleMode.hx" private="1" module="flash.display.LineScaleMode" extern="1" final="1">
		<HORIZONTAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HORIZONTAL>
		<NONE public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<VERTICAL public="1" set="null" static="1">
			<x path="flash.display.LineScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VERTICAL>
		<meta>
			<m n=":native"><e>"flash.display.LineScaleMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Loader" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</content>
		<contentLoaderInfo public="1" get="accessor" set="null">
			<c path="flash.display.LoaderInfo"/>
			<meta><m n=":flash.property"/></meta>
		</contentLoaderInfo>
		<uncaughtErrorEvents public="1" get="accessor" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<get_content set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_content>
		<get_contentLoaderInfo set="method"><f a=""><c path="flash.display.LoaderInfo"/></f></get_contentLoaderInfo>
		<get_uncaughtErrorEvents set="method"><f a=""><c path="flash.events.UncaughtErrorEvents"/></f></get_uncaughtErrorEvents>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ gc : true }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unloadAndStop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" get="accessor" set="null">
			<x path="flash.display.ActionScriptVersion"/>
			<meta><m n=":flash.property"/></meta>
		</actionScriptVersion>
		<applicationDomain public="1" get="accessor" set="null">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</applicationDomain>
		<bytes public="1" get="accessor" set="null">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":flash.property"/></meta>
		</bytes>
		<bytesLoaded public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<childAllowsParent public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</childAllowsParent>
		<childSandboxBridge public="1" get="accessor" set="accessor">
			<d/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</childSandboxBridge>
		<content public="1" get="accessor" set="null">
			<c path="flash.display.DisplayObject"/>
			<meta><m n=":flash.property"/></meta>
		</content>
		<contentType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</contentType>
		<frameRate public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameRate>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<isURLInaccessible public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isURLInaccessible>
		<loader public="1" get="accessor" set="null">
			<c path="flash.display.Loader"/>
			<meta><m n=":flash.property"/></meta>
		</loader>
		<loaderURL public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</loaderURL>
		<parameters public="1" get="accessor" set="null">
			<d><c path="String"/></d>
			<meta><m n=":flash.property"/></meta>
		</parameters>
		<parentAllowsChild public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</parentAllowsChild>
		<parentSandboxBridge public="1" get="accessor" set="accessor">
			<d/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</parentSandboxBridge>
		<sameDomain public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</sameDomain>
		<sharedEvents public="1" get="accessor" set="null">
			<c path="flash.events.EventDispatcher"/>
			<meta><m n=":flash.property"/></meta>
		</sharedEvents>
		<swfVersion public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</swfVersion>
		<uncaughtErrorEvents public="1" get="accessor" set="null">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</uncaughtErrorEvents>
		<url public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<get_actionScriptVersion set="method"><f a=""><x path="flash.display.ActionScriptVersion"/></f></get_actionScriptVersion>
		<get_applicationDomain set="method"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_applicationDomain>
		<get_bytes set="method"><f a=""><c path="flash.utils.ByteArray"/></f></get_bytes>
		<get_bytesLoaded set="method"><f a=""><x path="UInt"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="UInt"/></f></get_bytesTotal>
		<get_childAllowsParent set="method"><f a=""><x path="Bool"/></f></get_childAllowsParent>
		<get_childSandboxBridge set="method"><f a=""><d/></f></get_childSandboxBridge>
		<get_content set="method"><f a=""><c path="flash.display.DisplayObject"/></f></get_content>
		<get_contentType set="method"><f a=""><c path="String"/></f></get_contentType>
		<get_frameRate set="method"><f a=""><x path="Float"/></f></get_frameRate>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_isURLInaccessible set="method"><f a=""><x path="Bool"/></f></get_isURLInaccessible>
		<get_loader set="method"><f a=""><c path="flash.display.Loader"/></f></get_loader>
		<get_loaderURL set="method"><f a=""><c path="String"/></f></get_loaderURL>
		<get_parameters set="method"><f a=""><d><c path="String"/></d></f></get_parameters>
		<get_parentAllowsChild set="method"><f a=""><x path="Bool"/></f></get_parentAllowsChild>
		<get_parentSandboxBridge set="method"><f a=""><d/></f></get_parentSandboxBridge>
		<get_sameDomain set="method"><f a=""><x path="Bool"/></f></get_sameDomain>
		<get_sharedEvents set="method"><f a=""><c path="flash.events.EventDispatcher"/></f></get_sharedEvents>
		<get_swfVersion set="method"><f a=""><x path="UInt"/></f></get_swfVersion>
		<get_uncaughtErrorEvents set="method"><f a=""><c path="flash.events.UncaughtErrorEvents"/></f></get_uncaughtErrorEvents>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<set_childSandboxBridge set="method"><f a="value">
	<d/>
	<d/>
</f></set_childSandboxBridge>
		<set_parentSandboxBridge set="method"><f a="value">
	<d/>
	<d/>
</f></set_parentSandboxBridge>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<abstract path="flash.display.PixelSnapping" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/PixelSnapping.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.PixelSnapping"</e></m>
		</meta>
		<impl><class path="flash.display._PixelSnapping.PixelSnapping_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/PixelSnapping.hx" private="1" module="flash.display.PixelSnapping" extern="1" final="1">
	<ALWAYS public="1" set="null" static="1">
		<x path="flash.display.PixelSnapping"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALWAYS>
	<AUTO public="1" set="null" static="1">
		<x path="flash.display.PixelSnapping"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUTO>
	<NEVER public="1" set="null" static="1">
		<x path="flash.display.PixelSnapping"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEVER>
	<meta>
		<m n=":native"><e>"flash.display.PixelSnapping"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._PixelSnapping.PixelSnapping_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/PixelSnapping.hx" private="1" module="flash.display.PixelSnapping" extern="1" final="1">
		<ALWAYS public="1" set="null" static="1">
			<x path="flash.display.PixelSnapping"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALWAYS>
		<AUTO public="1" set="null" static="1">
			<x path="flash.display.PixelSnapping"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUTO>
		<NEVER public="1" set="null" static="1">
			<x path="flash.display.PixelSnapping"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEVER>
		<meta>
			<m n=":native"><e>"flash.display.PixelSnapping"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Scene" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Scene.hx" extern="1" final="1">
		<labels public="1" get="accessor" set="null">
			<c path="Array"><c path="flash.display.FrameLabel"/></c>
			<meta><m n=":flash.property"/></meta>
		</labels>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<numFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numFrames>
		<get_labels set="method"><f a=""><c path="Array"><c path="flash.display.FrameLabel"/></c></f></get_labels>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_numFrames set="method"><f a=""><x path="Int"/></f></get_numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Shader" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null" set="accessor">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":flash.property"/></meta>
		</byteCode>
		<data public="1" get="accessor" set="accessor">
			<c path="flash.display.ShaderData"/>
			<meta><m n=":flash.property"/></meta>
		</data>
		<precisionHint public="1" get="accessor" set="accessor">
			<x path="flash.display.ShaderPrecision"/>
			<meta><m n=":flash.property"/></meta>
		</precisionHint>
		<get_data set="method"><f a=""><c path="flash.display.ShaderData"/></f></get_data>
		<get_precisionHint set="method"><f a=""><x path="flash.display.ShaderPrecision"/></f></get_precisionHint>
		<set_byteCode set="method"><f a="value">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
</f></set_byteCode>
		<set_data set="method"><f a="value">
	<c path="flash.display.ShaderData"/>
	<c path="flash.display.ShaderData"/>
</f></set_data>
		<set_precisionHint set="method"><f a="value">
	<x path="flash.display.ShaderPrecision"/>
	<x path="flash.display.ShaderPrecision"/>
</f></set_precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ShaderData.hx" extern="1"><new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new></class>
	<abstract path="flash.display.ShaderPrecision" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ShaderPrecision.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
		</meta>
		<impl><class path="flash.display._ShaderPrecision.ShaderPrecision_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ShaderPrecision.hx" private="1" module="flash.display.ShaderPrecision" extern="1" final="1">
	<FAST public="1" set="null" static="1">
		<x path="flash.display.ShaderPrecision"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAST>
	<FULL public="1" set="null" static="1">
		<x path="flash.display.ShaderPrecision"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL>
	<meta>
		<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._ShaderPrecision.ShaderPrecision_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/ShaderPrecision.hx" private="1" module="flash.display.ShaderPrecision" extern="1" final="1">
		<FAST public="1" set="null" static="1">
			<x path="flash.display.ShaderPrecision"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAST>
		<FULL public="1" set="null" static="1">
			<x path="flash.display.ShaderPrecision"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL>
		<meta>
			<m n=":native"><e>"flash.display.ShaderPrecision"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.SpreadMethod" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/SpreadMethod.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
		</meta>
		<impl><class path="flash.display._SpreadMethod.SpreadMethod_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/SpreadMethod.hx" private="1" module="flash.display.SpreadMethod" extern="1" final="1">
	<PAD public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAD>
	<REFLECT public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REFLECT>
	<REPEAT public="1" set="null" static="1">
		<x path="flash.display.SpreadMethod"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT>
	<meta>
		<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._SpreadMethod.SpreadMethod_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/SpreadMethod.hx" private="1" module="flash.display.SpreadMethod" extern="1" final="1">
		<PAD public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAD>
		<REFLECT public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REFLECT>
		<REPEAT public="1" set="null" static="1">
			<x path="flash.display.SpreadMethod"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT>
		<meta>
			<m n=":native"><e>"flash.display.SpreadMethod"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display.Stage" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1" get="accessor" set="accessor">
			<x path="flash.display.StageAlign"/>
			<meta><m n=":flash.property"/></meta>
		</align>
		<allowsFullScreen public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</allowsFullScreen>
		<allowsFullScreenInteractive public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</allowsFullScreenInteractive>
		<browserZoomFactor public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</browserZoomFactor>
		<color public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</color>
		<colorCorrection public="1" get="accessor" set="accessor">
			<x path="flash.display.ColorCorrection"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</colorCorrection>
		<colorCorrectionSupport public="1" get="accessor" set="null">
			<x path="flash.display.ColorCorrectionSupport"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</colorCorrectionSupport>
		<contentsScaleFactor public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</contentsScaleFactor>
		<displayContextInfo public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</displayContextInfo>
		<displayState public="1" get="accessor" set="accessor">
			<x path="flash.display.StageDisplayState"/>
			<meta><m n=":flash.property"/></meta>
		</displayState>
		<focus public="1" get="accessor" set="accessor">
			<c path="flash.display.InteractiveObject"/>
			<meta><m n=":flash.property"/></meta>
		</focus>
		<frameRate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameRate>
		<fullScreenHeight public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenHeight>
		<fullScreenSourceRect public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenSourceRect>
		<fullScreenWidth public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</fullScreenWidth>
		<mouseLock public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</mouseLock>
		<quality public="1" get="accessor" set="accessor">
			<x path="flash.display.StageQuality"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<scaleMode public="1" get="accessor" set="accessor">
			<x path="flash.display.StageScaleMode"/>
			<meta><m n=":flash.property"/></meta>
		</scaleMode>
		<showDefaultContextMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</showDefaultContextMenu>
		<softKeyboardRect public="1" get="accessor" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</softKeyboardRect>
		<stage3Ds public="1" get="accessor" set="null">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</stage3Ds>
		<stageFocusRect public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</stageFocusRect>
		<stageHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</stageHeight>
		<stageVideos public="1" get="accessor" set="null">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</stageVideos>
		<stageWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</stageWidth>
		<wmodeGPU public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</wmodeGPU>
		<get_align set="method"><f a=""><x path="flash.display.StageAlign"/></f></get_align>
		<get_allowsFullScreen set="method"><f a=""><x path="Bool"/></f></get_allowsFullScreen>
		<get_allowsFullScreenInteractive set="method"><f a=""><x path="Bool"/></f></get_allowsFullScreenInteractive>
		<get_browserZoomFactor set="method"><f a=""><x path="Float"/></f></get_browserZoomFactor>
		<get_color set="method"><f a=""><x path="UInt"/></f></get_color>
		<get_colorCorrection set="method"><f a=""><x path="flash.display.ColorCorrection"/></f></get_colorCorrection>
		<get_colorCorrectionSupport set="method"><f a=""><x path="flash.display.ColorCorrectionSupport"/></f></get_colorCorrectionSupport>
		<get_constructor set="method"><f a=""><d/></f></get_constructor>
		<get_contentsScaleFactor set="method"><f a=""><x path="Float"/></f></get_contentsScaleFactor>
		<get_displayContextInfo set="method"><f a=""><c path="String"/></f></get_displayContextInfo>
		<get_displayState set="method"><f a=""><x path="flash.display.StageDisplayState"/></f></get_displayState>
		<get_focus set="method"><f a=""><c path="flash.display.InteractiveObject"/></f></get_focus>
		<get_frameRate set="method"><f a=""><x path="Float"/></f></get_frameRate>
		<get_fullScreenHeight set="method"><f a=""><x path="UInt"/></f></get_fullScreenHeight>
		<get_fullScreenSourceRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_fullScreenSourceRect>
		<get_fullScreenWidth set="method"><f a=""><x path="UInt"/></f></get_fullScreenWidth>
		<get_mouseLock set="method"><f a=""><x path="Bool"/></f></get_mouseLock>
		<get_quality set="method"><f a=""><x path="flash.display.StageQuality"/></f></get_quality>
		<get_scaleMode set="method"><f a=""><x path="flash.display.StageScaleMode"/></f></get_scaleMode>
		<get_showDefaultContextMenu set="method"><f a=""><x path="Bool"/></f></get_showDefaultContextMenu>
		<get_softKeyboardRect set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_softKeyboardRect>
		<get_stage3Ds set="method"><f a=""><c path="flash.Vector"><c path="flash.display.Stage3D"/></c></f></get_stage3Ds>
		<get_stageFocusRect set="method"><f a=""><x path="Bool"/></f></get_stageFocusRect>
		<get_stageHeight set="method"><f a=""><x path="Int"/></f></get_stageHeight>
		<get_stageVideos set="method"><f a=""><c path="flash.Vector"><c path="flash.media.StageVideo"/></c></f></get_stageVideos>
		<get_stageWidth set="method"><f a=""><x path="Int"/></f></get_stageWidth>
		<get_wmodeGPU set="method"><f a=""><x path="Bool"/></f></get_wmodeGPU>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
		<set_align set="method"><f a="value">
	<x path="flash.display.StageAlign"/>
	<x path="flash.display.StageAlign"/>
</f></set_align>
		<set_color set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_color>
		<set_colorCorrection set="method"><f a="value">
	<x path="flash.display.ColorCorrection"/>
	<x path="flash.display.ColorCorrection"/>
</f></set_colorCorrection>
		<set_constructor set="method"><f a="value">
	<d/>
	<d/>
</f></set_constructor>
		<set_displayState set="method"><f a="value">
	<x path="flash.display.StageDisplayState"/>
	<x path="flash.display.StageDisplayState"/>
</f></set_displayState>
		<set_focus set="method"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_focus>
		<set_frameRate set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<set_fullScreenSourceRect set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_fullScreenSourceRect>
		<set_mouseLock set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseLock>
		<set_quality set="method"><f a="value">
	<x path="flash.display.StageQuality"/>
	<x path="flash.display.StageQuality"/>
</f></set_quality>
		<set_scaleMode set="method"><f a="value">
	<x path="flash.display.StageScaleMode"/>
	<x path="flash.display.StageScaleMode"/>
</f></set_scaleMode>
		<set_showDefaultContextMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_showDefaultContextMenu>
		<set_stageFocusRect set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_stageFocusRect>
		<set_stageHeight set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stageHeight>
		<set_stageWidth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_stageWidth>
	</class>
	<class path="flash.display.Stage3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" get="accessor" set="null">
			<c path="flash.display3D.Context3D"/>
			<meta><m n=":flash.property"/></meta>
		</context3D>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</visible>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</y>
		<get_context3D set="method"><f a=""><c path="flash.display3D.Context3D"/></f></get_context3D>
		<get_visible set="method"><f a=""><x path="Bool"/></f></get_visible>
		<get_x set="method"><f a=""><x path="Float"/></f></get_x>
		<get_y set="method"><f a=""><x path="Float"/></f></get_y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<x path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<requestContext3DMatchingProfiles public="1" set="method">
			<f a="profiles">
				<c path="flash.Vector"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash12</e></m></meta>
		</requestContext3DMatchingProfiles>
		<set_visible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_x set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<abstract path="flash.display.StageAlign" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageAlign.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageAlign"</e></m>
		</meta>
		<impl><class path="flash.display._StageAlign.StageAlign_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageAlign.hx" private="1" module="flash.display.StageAlign" extern="1" final="1">
	<BOTTOM public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM>
	<BOTTOM_LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM_LEFT>
	<BOTTOM_RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM_RIGHT>
	<LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<TOP public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP>
	<TOP_LEFT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP_LEFT>
	<TOP_RIGHT public="1" set="null" static="1">
		<x path="flash.display.StageAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP_RIGHT>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.display.StageAlign"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageAlign.StageAlign_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageAlign.hx" private="1" module="flash.display.StageAlign" extern="1" final="1">
		<BOTTOM public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM>
		<BOTTOM_LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM_RIGHT>
		<LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<TOP public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP>
		<TOP_LEFT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP_LEFT>
		<TOP_RIGHT public="1" set="null" static="1">
			<x path="flash.display.StageAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP_RIGHT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.display.StageAlign"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageDisplayState" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageDisplayState.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
		</meta>
		<impl><class path="flash.display._StageDisplayState.StageDisplayState_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageDisplayState.hx" private="1" module="flash.display.StageDisplayState" extern="1" final="1">
	<FULL_SCREEN public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL_SCREEN>
	<FULL_SCREEN_INTERACTIVE public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL_SCREEN_INTERACTIVE>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.display.StageDisplayState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageDisplayState.StageDisplayState_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageDisplayState.hx" private="1" module="flash.display.StageDisplayState" extern="1" final="1">
		<FULL_SCREEN public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL_SCREEN>
		<FULL_SCREEN_INTERACTIVE public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL_SCREEN_INTERACTIVE>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.display.StageDisplayState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.display.StageDisplayState"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageQuality" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageQuality.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageQuality"</e></m>
		</meta>
		<impl><class path="flash.display._StageQuality.StageQuality_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageQuality.hx" private="1" module="flash.display.StageQuality" extern="1" final="1">
	<BEST public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEST>
	<HIGH public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH>
	<HIGH_16X16 public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH_16X16>
	<HIGH_16X16_LINEAR public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH_16X16_LINEAR>
	<HIGH_8X8 public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH_8X8>
	<HIGH_8X8_LINEAR public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH_8X8_LINEAR>
	<LOW public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LOW>
	<MEDIUM public="1" set="null" static="1">
		<x path="flash.display.StageQuality"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIUM>
	<meta>
		<m n=":native"><e>"flash.display.StageQuality"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageQuality.StageQuality_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageQuality.hx" private="1" module="flash.display.StageQuality" extern="1" final="1">
		<BEST public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEST>
		<HIGH public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH>
		<HIGH_16X16 public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH_16X16>
		<HIGH_16X16_LINEAR public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH_16X16_LINEAR>
		<HIGH_8X8 public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH_8X8>
		<HIGH_8X8_LINEAR public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH_8X8_LINEAR>
		<LOW public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LOW>
		<MEDIUM public="1" set="null" static="1">
			<x path="flash.display.StageQuality"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIUM>
		<meta>
			<m n=":native"><e>"flash.display.StageQuality"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.StageScaleMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageScaleMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
		</meta>
		<impl><class path="flash.display._StageScaleMode.StageScaleMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageScaleMode.hx" private="1" module="flash.display.StageScaleMode" extern="1" final="1">
	<EXACT_FIT public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXACT_FIT>
	<NO_BORDER public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_BORDER>
	<NO_SCALE public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_SCALE>
	<SHOW_ALL public="1" set="null" static="1">
		<x path="flash.display.StageScaleMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHOW_ALL>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._StageScaleMode.StageScaleMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/StageScaleMode.hx" private="1" module="flash.display.StageScaleMode" extern="1" final="1">
		<EXACT_FIT public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXACT_FIT>
		<NO_BORDER public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_BORDER>
		<NO_SCALE public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_SCALE>
		<SHOW_ALL public="1" set="null" static="1">
			<x path="flash.display.StageScaleMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHOW_ALL>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.display.StageScaleMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display.TriangleCulling" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/TriangleCulling.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
		</meta>
		<impl><class path="flash.display._TriangleCulling.TriangleCulling_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/TriangleCulling.hx" private="1" module="flash.display.TriangleCulling" extern="1" final="1">
	<NEGATIVE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEGATIVE>
	<NONE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<POSITIVE public="1" set="null" static="1">
		<x path="flash.display.TriangleCulling"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POSITIVE>
	<meta>
		<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display._TriangleCulling.TriangleCulling_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display/TriangleCulling.hx" private="1" module="flash.display.TriangleCulling" extern="1" final="1">
		<NEGATIVE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEGATIVE>
		<NONE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<POSITIVE public="1" set="null" static="1">
			<x path="flash.display.TriangleCulling"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POSITIVE>
		<meta>
			<m n=":native"><e>"flash.display.TriangleCulling"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display3D.Context3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3D.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<supportsVideoTexture public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</supportsVideoTexture>
		<get_supportsVideoTexture set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsVideoTexture>
		<backBufferHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferHeight>
		<backBufferWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferWidth>
		<driverInfo public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</driverInfo>
		<enableErrorChecking public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</enableErrorChecking>
		<maxBackBufferHeight public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxBackBufferHeight>
		<maxBackBufferWidth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxBackBufferWidth>
		<profile public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash12</e></m>
			</meta>
		</profile>
		<totalGPUMemory public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</totalGPUMemory>
		<clear public="1" set="method">
			<f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask" v="0:0:0:1:1:0:0xFFFFFFFF">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mask : 0xFFFFFFFF, stencil : 0, depth : 1, alpha : 1, blue : 0, green : 0, red : 0 }</e></m></meta>
		</clear>
		<configureBackBuffer public="1" set="method">
			<f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution:?wantsBestResolutionOnBrowserZoom" v=":::true:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wantsBestResolutionOnBrowserZoom : false, wantsBestResolution : false, enableDepthAndStencil : true }</e></m></meta>
		</configureBackBuffer>
		<createCubeTexture public="1" set="method">
			<f a="size:format:optimizeForRenderToTexture:?streamingLevels" v=":::0">
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.CubeTexture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices:?bufferUsage">
	<x path="Int"/>
	<x path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<c path="flash.display3D.textures.RectangleTexture"/>
			</f>
			<meta><m n=":require"><e>flash11_8</e></m></meta>
		</createRectangleTexture>
		<createTexture public="1" set="method">
			<f a="width:height:format:optimizeForRenderToTexture:?streamingLevels" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flash.display3D.textures.Texture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex:?bufferUsage">
	<x path="Int"/>
	<x path="Int"/>
	<x path="flash.display3D.Context3DBufferUsage"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createVideoTexture public="1" set="method"><f a=""><c path="flash.display3D.textures.VideoTexture"/></f></createVideoTexture>
		<dispose public="1" set="method">
			<f a="?recreate" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ recreate : true }</e></m></meta>
		</dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method">
			<f a="indexBuffer:?firstIndex:?numTriangles" v=":0:-1">
				<c path="flash.display3D.IndexBuffer3D"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numTriangles : -1, firstIndex : 0 }</e></m></meta>
		</drawTriangles>
		<get_backBufferHeight set="method"><f a=""><x path="Int"/></f></get_backBufferHeight>
		<get_backBufferWidth set="method"><f a=""><x path="Int"/></f></get_backBufferWidth>
		<get_driverInfo set="method"><f a=""><c path="String"/></f></get_driverInfo>
		<get_enableErrorChecking set="method"><f a=""><x path="Bool"/></f></get_enableErrorChecking>
		<get_maxBackBufferHeight set="method"><f a=""><x path="Int"/></f></get_maxBackBufferHeight>
		<get_maxBackBufferWidth set="method"><f a=""><x path="Int"/></f></get_maxBackBufferWidth>
		<get_profile set="method"><f a=""><c path="String"/></f></get_profile>
		<get_totalGPUMemory set="method"><f a=""><x path="Float"/></f></get_totalGPUMemory>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<x path="flash.display3D.Context3DBlendFactor"/>
	<x path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<x path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<x path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1" set="method">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method">
			<f a="programType:firstRegister:matrix:?transposedMatrix" v=":::false">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transposedMatrix : false }</e></m></meta>
		</setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method">
			<f a="programType:firstRegister:data:?numRegisters" v=":::-1">
				<x path="flash.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numRegisters : -1 }</e></m></meta>
		</setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method">
			<f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector:?colorOutputIndex" v=":false:0:0:0">
				<c path="flash.display3D.textures.TextureBase"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ colorOutputIndex : 0, surfaceSelector : 0, antiAlias : 0, enableDepthAndStencil : false }</e></m></meta>
		</setRenderToTexture>
		<setSamplerStateAt public="1" set="method">
			<f a="sampler:wrap:filter:mipfilter">
				<x path="Int"/>
				<x path="flash.display3D.Context3DWrapMode"/>
				<x path="flash.display3D.Context3DTextureFilter"/>
				<x path="flash.display3D.Context3DMipFilter"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_6</e></m></meta>
		</setSamplerStateAt>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<x path="flash.display3D.Context3DTriangleFace"/>
	<x path="flash.display3D.Context3DCompareMode"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method">
			<f a="referenceValue:?readMask:?writeMask" v=":255:255">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 255, readMask : 255 }</e></m></meta>
		</setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method">
			<f a="index:buffer:?bufferOffset:?format" v="::0:">
				<x path="Int"/>
				<c path="flash.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<x path="flash.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferOffset : 0 }</e></m></meta>
		</setVertexBufferAt>
		<set_enableErrorChecking set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableErrorChecking>
		<set_maxBackBufferHeight set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxBackBufferHeight>
		<set_maxBackBufferWidth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxBackBufferWidth>
	</class>
	<abstract path="flash.display3D.Context3DBlendFactor" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBlendFactor.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DBlendFactor.Context3DBlendFactor_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBlendFactor.hx" private="1" module="flash.display3D.Context3DBlendFactor" extern="1" final="1">
	<DESTINATION_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESTINATION_ALPHA>
	<DESTINATION_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESTINATION_COLOR>
	<ONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE>
	<ONE_MINUS_DESTINATION_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_DESTINATION_ALPHA>
	<ONE_MINUS_DESTINATION_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_DESTINATION_COLOR>
	<ONE_MINUS_SOURCE_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_SOURCE_ALPHA>
	<ONE_MINUS_SOURCE_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_SOURCE_COLOR>
	<SOURCE_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOURCE_ALPHA>
	<SOURCE_COLOR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOURCE_COLOR>
	<ZERO public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBlendFactor"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZERO>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DBlendFactor.Context3DBlendFactor_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBlendFactor.hx" private="1" module="flash.display3D.Context3DBlendFactor" extern="1" final="1">
		<DESTINATION_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESTINATION_ALPHA>
		<DESTINATION_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESTINATION_COLOR>
		<ONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE>
		<ONE_MINUS_DESTINATION_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_DESTINATION_ALPHA>
		<ONE_MINUS_DESTINATION_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_DESTINATION_COLOR>
		<ONE_MINUS_SOURCE_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_SOURCE_ALPHA>
		<ONE_MINUS_SOURCE_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_SOURCE_COLOR>
		<SOURCE_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOURCE_ALPHA>
		<SOURCE_COLOR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOURCE_COLOR>
		<ZERO public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBlendFactor"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZERO>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DBlendFactor"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DBufferUsage" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBufferUsage.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
			<m n=":require"><e>flash12</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DBufferUsage.Context3DBufferUsage_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBufferUsage.hx" private="1" module="flash.display3D.Context3DBufferUsage" extern="1" final="1">
	<DYNAMIC_DRAW public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBufferUsage"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DYNAMIC_DRAW>
	<STATIC_DRAW public="1" set="null" static="1">
		<x path="flash.display3D.Context3DBufferUsage"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STATIC_DRAW>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DBufferUsage.Context3DBufferUsage_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DBufferUsage.hx" private="1" module="flash.display3D.Context3DBufferUsage" extern="1" final="1">
		<DYNAMIC_DRAW public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBufferUsage"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DYNAMIC_DRAW>
		<STATIC_DRAW public="1" set="null" static="1">
			<x path="flash.display3D.Context3DBufferUsage"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STATIC_DRAW>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DBufferUsage"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DCompareMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DCompareMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DCompareMode.hx" private="1" module="flash.display3D.Context3DCompareMode" extern="1" final="1">
	<ALWAYS public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALWAYS>
	<EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUAL>
	<GREATER public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER>
	<GREATER_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_EQUAL>
	<LESS public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS>
	<LESS_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_EQUAL>
	<NEVER public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEVER>
	<NOT_EQUAL public="1" set="null" static="1">
		<x path="flash.display3D.Context3DCompareMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NOT_EQUAL>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DCompareMode.hx" private="1" module="flash.display3D.Context3DCompareMode" extern="1" final="1">
		<ALWAYS public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALWAYS>
		<EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUAL>
		<GREATER public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER>
		<GREATER_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_EQUAL>
		<LESS public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS>
		<LESS_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_EQUAL>
		<NEVER public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEVER>
		<NOT_EQUAL public="1" set="null" static="1">
			<x path="flash.display3D.Context3DCompareMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NOT_EQUAL>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DCompareMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DMipFilter" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DMipFilter.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DMipFilter.Context3DMipFilter_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DMipFilter.hx" private="1" module="flash.display3D.Context3DMipFilter" extern="1" final="1">
	<MIPLINEAR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIPLINEAR>
	<MIPNEAREST public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIPNEAREST>
	<MIPNONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DMipFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIPNONE>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DMipFilter.Context3DMipFilter_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DMipFilter.hx" private="1" module="flash.display3D.Context3DMipFilter" extern="1" final="1">
		<MIPLINEAR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIPLINEAR>
		<MIPNEAREST public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIPNEAREST>
		<MIPNONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DMipFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIPNONE>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DMipFilter"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DProfile" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProfile.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DProfile.Context3DProfile_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProfile.hx" private="1" module="flash.display3D.Context3DProfile" extern="1" final="1">
	<BASELINE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BASELINE>
	<BASELINE_CONSTRAINED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BASELINE_CONSTRAINED>
	<BASELINE_EXTENDED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BASELINE_EXTENDED>
	<STANDARD public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD>
	<STANDARD_CONSTRAINED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD_CONSTRAINED>
	<STANDARD_EXTENDED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProfile"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD_EXTENDED>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DProfile.Context3DProfile_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProfile.hx" private="1" module="flash.display3D.Context3DProfile" extern="1" final="1">
		<BASELINE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BASELINE>
		<BASELINE_CONSTRAINED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BASELINE_CONSTRAINED>
		<BASELINE_EXTENDED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BASELINE_EXTENDED>
		<STANDARD public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD>
		<STANDARD_CONSTRAINED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD_CONSTRAINED>
		<STANDARD_EXTENDED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProfile"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD_EXTENDED>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DProfile"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DProgramType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProgramType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DProgramType.Context3DProgramType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProgramType.hx" private="1" module="flash.display3D.Context3DProgramType" extern="1" final="1">
	<FRAGMENT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProgramType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FRAGMENT>
	<VERTEX public="1" set="null" static="1">
		<x path="flash.display3D.Context3DProgramType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VERTEX>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DProgramType.Context3DProgramType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DProgramType.hx" private="1" module="flash.display3D.Context3DProgramType" extern="1" final="1">
		<FRAGMENT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProgramType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FRAGMENT>
		<VERTEX public="1" set="null" static="1">
			<x path="flash.display3D.Context3DProgramType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VERTEX>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DProgramType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DStencilAction" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DStencilAction.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DStencilAction.Context3DStencilAction_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DStencilAction.hx" private="1" module="flash.display3D.Context3DStencilAction" extern="1" final="1">
	<DECREMENT_SATURATE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECREMENT_SATURATE>
	<DECREMENT_WRAP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECREMENT_WRAP>
	<INCREMENT_SATURATE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INCREMENT_SATURATE>
	<INCREMENT_WRAP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INCREMENT_WRAP>
	<INVERT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVERT>
	<KEEP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KEEP>
	<SET public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SET>
	<ZERO public="1" set="null" static="1">
		<x path="flash.display3D.Context3DStencilAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZERO>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DStencilAction.Context3DStencilAction_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DStencilAction.hx" private="1" module="flash.display3D.Context3DStencilAction" extern="1" final="1">
		<DECREMENT_SATURATE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECREMENT_SATURATE>
		<DECREMENT_WRAP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECREMENT_WRAP>
		<INCREMENT_SATURATE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INCREMENT_SATURATE>
		<INCREMENT_WRAP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INCREMENT_WRAP>
		<INVERT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVERT>
		<KEEP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KEEP>
		<SET public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SET>
		<ZERO public="1" set="null" static="1">
			<x path="flash.display3D.Context3DStencilAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZERO>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DStencilAction"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTextureFilter" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFilter.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTextureFilter.Context3DTextureFilter_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFilter.hx" private="1" module="flash.display3D.Context3DTextureFilter" extern="1" final="1">
	<ANISOTROPIC16X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANISOTROPIC16X>
	<ANISOTROPIC2X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANISOTROPIC2X>
	<ANISOTROPIC4X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANISOTROPIC4X>
	<ANISOTROPIC8X public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANISOTROPIC8X>
	<LINEAR public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR>
	<NEAREST public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFilter"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEAREST>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTextureFilter.Context3DTextureFilter_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFilter.hx" private="1" module="flash.display3D.Context3DTextureFilter" extern="1" final="1">
		<ANISOTROPIC16X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANISOTROPIC16X>
		<ANISOTROPIC2X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANISOTROPIC2X>
		<ANISOTROPIC4X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANISOTROPIC4X>
		<ANISOTROPIC8X public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANISOTROPIC8X>
		<LINEAR public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR>
		<NEAREST public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFilter"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEAREST>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTextureFilter"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTextureFormat" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFormat.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTextureFormat.Context3DTextureFormat_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFormat.hx" private="1" module="flash.display3D.Context3DTextureFormat" extern="1" final="1">
	<BGRA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BGRA>
	<BGRA_PACKED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BGRA_PACKED>
	<BGR_PACKED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BGR_PACKED>
	<COMPRESSED public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPRESSED>
	<COMPRESSED_ALPHA public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPRESSED_ALPHA>
	<RGBA_HALF_FLOAT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTextureFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGBA_HALF_FLOAT>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTextureFormat.Context3DTextureFormat_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTextureFormat.hx" private="1" module="flash.display3D.Context3DTextureFormat" extern="1" final="1">
		<BGRA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BGRA>
		<BGRA_PACKED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BGRA_PACKED>
		<BGR_PACKED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BGR_PACKED>
		<COMPRESSED public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPRESSED>
		<COMPRESSED_ALPHA public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPRESSED_ALPHA>
		<RGBA_HALF_FLOAT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTextureFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGBA_HALF_FLOAT>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTextureFormat"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DTriangleFace" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTriangleFace.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTriangleFace.hx" private="1" module="flash.display3D.Context3DTriangleFace" extern="1" final="1">
	<BACK public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACK>
	<FRONT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FRONT>
	<FRONT_AND_BACK public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FRONT_AND_BACK>
	<NONE public="1" set="null" static="1">
		<x path="flash.display3D.Context3DTriangleFace"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DTriangleFace.hx" private="1" module="flash.display3D.Context3DTriangleFace" extern="1" final="1">
		<BACK public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACK>
		<FRONT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FRONT>
		<FRONT_AND_BACK public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FRONT_AND_BACK>
		<NONE public="1" set="null" static="1">
			<x path="flash.display3D.Context3DTriangleFace"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DTriangleFace"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DVertexBufferFormat" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DVertexBufferFormat.Context3DVertexBufferFormat_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DVertexBufferFormat.hx" private="1" module="flash.display3D.Context3DVertexBufferFormat" extern="1" final="1">
	<BYTES_4 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BYTES_4>
	<FLOAT_1 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT_1>
	<FLOAT_2 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT_2>
	<FLOAT_3 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT_3>
	<FLOAT_4 public="1" set="null" static="1">
		<x path="flash.display3D.Context3DVertexBufferFormat"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT_4>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DVertexBufferFormat.Context3DVertexBufferFormat_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DVertexBufferFormat.hx" private="1" module="flash.display3D.Context3DVertexBufferFormat" extern="1" final="1">
		<BYTES_4 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BYTES_4>
		<FLOAT_1 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT_1>
		<FLOAT_2 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT_2>
		<FLOAT_3 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT_3>
		<FLOAT_4 public="1" set="null" static="1">
			<x path="flash.display3D.Context3DVertexBufferFormat"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT_4>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DVertexBufferFormat"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.display3D.Context3DWrapMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DWrapMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
		</meta>
		<impl><class path="flash.display3D._Context3DWrapMode.Context3DWrapMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DWrapMode.hx" private="1" module="flash.display3D.Context3DWrapMode" extern="1" final="1">
	<CLAMP public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLAMP>
	<CLAMP_U_REPEAT_V public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLAMP_U_REPEAT_V>
	<REPEAT public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT>
	<REPEAT_U_CLAMP_V public="1" set="null" static="1">
		<x path="flash.display3D.Context3DWrapMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT_U_CLAMP_V>
	<meta>
		<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.display3D._Context3DWrapMode.Context3DWrapMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Context3DWrapMode.hx" private="1" module="flash.display3D.Context3DWrapMode" extern="1" final="1">
		<CLAMP public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLAMP>
		<CLAMP_U_REPEAT_V public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLAMP_U_REPEAT_V>
		<REPEAT public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT>
		<REPEAT_U_CLAMP_V public="1" set="null" static="1">
			<x path="flash.display3D.Context3DWrapMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT_U_CLAMP_V>
		<meta>
			<m n=":native"><e>"flash.display3D.Context3DWrapMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/IndexBuffer3D.hx" extern="1" final="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/Program3D.hx" extern="1" final="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/textures/CubeTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:side:?miplevel" v="::0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:side:?miplevel" v=":::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/textures/RectangleTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/textures/Texture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?async" v="::false">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method">
			<f a="source:?miplevel" v=":0">
				<c path="flash.display.BitmapData"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method">
			<f a="data:byteArrayOffset:?miplevel" v="::0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
	</class>
	<class path="flash.display3D.textures.VideoTexture" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/display3D/textures/VideoTexture.hx" extern="1" final="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<videoHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoHeight>
		<videoWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoWidth>
		<attachCamera public="1" set="method"><f a="theCamera">
	<c path="flash.media.Camera"/>
	<x path="Void"/>
</f></attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<get_videoHeight set="method"><f a=""><x path="Int"/></f></get_videoHeight>
		<get_videoWidth set="method"><f a=""><x path="Int"/></f></get_videoWidth>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.errors.Error" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/errors/Error.hx" extern="1">
		<length final="1" public="1" set="null" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:restArgs">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<x path="haxe.extern.Rest"><d/></x>
	<d/>
</f></throwError>
		<errorID public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<get_errorID set="method"><f a=""><x path="Int"/></f></get_errorID>
		<new public="1" set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.Event" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/Event.hx" extern="1">
		<ACTIVATE final="1" public="1" set="null" static="1"><c path="String"/></ACTIVATE>
		<ADDED final="1" public="1" set="null" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE final="1" public="1" set="null" static="1"><c path="String"/></ADDED_TO_STAGE>
		<BROWSER_ZOOM_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></BROWSER_ZOOM_CHANGE>
		<CANCEL final="1" public="1" set="null" static="1"><c path="String"/></CANCEL>
		<CHANGE final="1" public="1" set="null" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE final="1" public="1" set="null" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE final="1" public="1" set="null" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE final="1" public="1" set="null" static="1"><c path="String"/></CLOSE>
		<COMPLETE final="1" public="1" set="null" static="1"><c path="String"/></COMPLETE>
		<CONNECT final="1" public="1" set="null" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE final="1" public="1" set="null" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME final="1" public="1" set="null" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN final="1" public="1" set="null" static="1"><c path="String"/></FULLSCREEN>
		<ID3 final="1" public="1" set="null" static="1"><c path="String"/></ID3>
		<INIT final="1" public="1" set="null" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN final="1" public="1" set="null" static="1"><c path="String"/></OPEN>
		<PASTE final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED final="1" public="1" set="null" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE final="1" public="1" set="null" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER final="1" public="1" set="null" static="1"><c path="String"/></RENDER>
		<RESIZE final="1" public="1" set="null" static="1"><c path="String"/></RESIZE>
		<SCROLL final="1" public="1" set="null" static="1"><c path="String"/></SCROLL>
		<SELECT final="1" public="1" set="null" static="1"><c path="String"/></SELECT>
		<SELECT_ALL final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE final="1" public="1" set="null" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD final="1" public="1" set="null" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME final="1" public="1" set="null" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE final="1" public="1" set="null" static="1"><c path="String"/></WORKER_STATE>
		<bubbles public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</bubbles>
		<cancelable public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cancelable>
		<currentTarget public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</currentTarget>
		<eventPhase public="1" get="accessor" set="null">
			<x path="flash.events.EventPhase"/>
			<meta><m n=":flash.property"/></meta>
		</eventPhase>
		<target public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</target>
		<type public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:restArgs">
	<c path="String"/>
	<x path="haxe.extern.Rest"><d/></x>
	<c path="String"/>
</f></formatToString>
		<get_bubbles set="method"><f a=""><x path="Bool"/></f></get_bubbles>
		<get_cancelable set="method"><f a=""><x path="Bool"/></f></get_cancelable>
		<get_currentTarget set="method"><f a=""><d/></f></get_currentTarget>
		<get_eventPhase set="method"><f a=""><x path="flash.events.EventPhase"/></f></get_eventPhase>
		<get_target set="method"><f a=""><d/></f></get_target>
		<get_type set="method"><f a=""><c path="String"/></f></get_type>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.TextEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK final="1" public="1" set="null" static="1"><c path="String"/></LINK>
		<TEXT_INPUT final="1" public="1" set="null" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</text>
		<get_text set="method"><f a=""><c path="String"/></f></get_text>
		<set_text set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR final="1" public="1" set="null" static="1"><c path="String"/></ERROR>
		<errorID public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</errorID>
		<get_errorID set="method"><f a=""><x path="Int"/></f></get_errorID>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
	</class>
	<abstract path="flash.events.EventPhase" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/EventPhase.hx">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.events.EventPhase"</e></m>
		</meta>
		<impl><class path="flash.events._EventPhase.EventPhase_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/EventPhase.hx" private="1" module="flash.events.EventPhase" extern="1" final="1">
	<AT_TARGET public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT_TARGET>
	<BUBBLING_PHASE public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUBBLING_PHASE>
	<CAPTURING_PHASE public="1" set="null" static="1">
		<x path="flash.events.EventPhase"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPTURING_PHASE>
	<meta>
		<m n=":native"><e>"flash.events.EventPhase"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.events._EventPhase.EventPhase_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/EventPhase.hx" private="1" module="flash.events.EventPhase" extern="1" final="1">
		<AT_TARGET public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUBBLING_PHASE>
		<CAPTURING_PHASE public="1" set="null" static="1">
			<x path="flash.events.EventPhase"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPTURING_PHASE>
		<meta>
			<m n=":native"><e>"flash.events.EventPhase"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.events.FocusEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/FocusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<FOCUS_IN final="1" public="1" set="null" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT final="1" public="1" set="null" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<isRelatedObjectInaccessible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</isRelatedObjectInaccessible>
		<keyCode public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</keyCode>
		<relatedObject public="1" get="accessor" set="accessor">
			<c path="flash.display.InteractiveObject"/>
			<meta><m n=":flash.property"/></meta>
		</relatedObject>
		<shiftKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</shiftKey>
		<get_isRelatedObjectInaccessible set="method"><f a=""><x path="Bool"/></f></get_isRelatedObjectInaccessible>
		<get_keyCode set="method"><f a=""><x path="UInt"/></f></get_keyCode>
		<get_relatedObject set="method"><f a=""><c path="flash.display.InteractiveObject"/></f></get_relatedObject>
		<get_shiftKey set="method"><f a=""><x path="Bool"/></f></get_shiftKey>
		<set_isRelatedObjectInaccessible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isRelatedObjectInaccessible>
		<set_keyCode set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_keyCode>
		<set_relatedObject set="method"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_relatedObject>
		<set_shiftKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shiftKey>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode" v=":true:false::false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ keyCode : 0, shiftKey : false, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.IOErrorEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR final="1" public="1" set="null" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR final="1" public="1" set="null" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR final="1" public="1" set="null" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR final="1" public="1" set="null" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false::0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN final="1" public="1" set="null" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP final="1" public="1" set="null" static="1"><c path="String"/></KEY_UP>
		<altKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</altKey>
		<charCode public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</charCode>
		<ctrlKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ctrlKey>
		<keyCode public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</keyCode>
		<keyLocation public="1" get="accessor" set="accessor">
			<x path="flash.ui.KeyLocation"/>
			<meta><m n=":flash.property"/></meta>
		</keyLocation>
		<shiftKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</shiftKey>
		<get_altKey set="method"><f a=""><x path="Bool"/></f></get_altKey>
		<get_charCode set="method"><f a=""><x path="UInt"/></f></get_charCode>
		<get_ctrlKey set="method"><f a=""><x path="Bool"/></f></get_ctrlKey>
		<get_keyCode set="method"><f a=""><x path="UInt"/></f></get_keyCode>
		<get_keyLocation set="method"><f a=""><x path="flash.ui.KeyLocation"/></f></get_keyLocation>
		<get_shiftKey set="method"><f a=""><x path="Bool"/></f></get_shiftKey>
		<set_altKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_altKey>
		<set_charCode set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_charCode>
		<set_ctrlKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ctrlKey>
		<set_keyCode set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_keyCode>
		<set_keyLocation set="method"><f a="value">
	<x path="flash.ui.KeyLocation"/>
	<x path="flash.ui.KeyLocation"/>
</f></set_keyLocation>
		<set_shiftKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue" v=":true:false:0:0:0:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="flash.ui.KeyLocation"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shiftKeyValue : false, altKeyValue : false, ctrlKeyValue : false, keyLocationValue : 0, keyCodeValue : 0, charCodeValue : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK final="1" public="1" set="null" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK final="1" public="1" set="null" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL final="1" public="1" set="null" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT final="1" public="1" set="null" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER final="1" public="1" set="null" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</altKey>
		<buttonDown public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</buttonDown>
		<ctrlKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ctrlKey>
		<delta public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</delta>
		<isRelatedObjectInaccessible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</isRelatedObjectInaccessible>
		<localX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</localX>
		<localY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</localY>
		<movementX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</movementX>
		<movementY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</movementY>
		<relatedObject public="1" get="accessor" set="accessor">
			<c path="flash.display.InteractiveObject"/>
			<meta><m n=":flash.property"/></meta>
		</relatedObject>
		<shiftKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</shiftKey>
		<stageX public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</stageX>
		<stageY public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</stageY>
		<get_altKey set="method"><f a=""><x path="Bool"/></f></get_altKey>
		<get_buttonDown set="method"><f a=""><x path="Bool"/></f></get_buttonDown>
		<get_ctrlKey set="method"><f a=""><x path="Bool"/></f></get_ctrlKey>
		<get_delta set="method"><f a=""><x path="Int"/></f></get_delta>
		<get_isRelatedObjectInaccessible set="method"><f a=""><x path="Bool"/></f></get_isRelatedObjectInaccessible>
		<get_localX set="method"><f a=""><x path="Float"/></f></get_localX>
		<get_localY set="method"><f a=""><x path="Float"/></f></get_localY>
		<get_movementX set="method"><f a=""><x path="Float"/></f></get_movementX>
		<get_movementY set="method"><f a=""><x path="Float"/></f></get_movementY>
		<get_relatedObject set="method"><f a=""><c path="flash.display.InteractiveObject"/></f></get_relatedObject>
		<get_shiftKey set="method"><f a=""><x path="Bool"/></f></get_shiftKey>
		<get_stageX set="method"><f a=""><x path="Float"/></f></get_stageX>
		<get_stageY set="method"><f a=""><x path="Float"/></f></get_stageY>
		<set_altKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_altKey>
		<set_buttonDown set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_buttonDown>
		<set_ctrlKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ctrlKey>
		<set_delta set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_delta>
		<set_isRelatedObjectInaccessible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isRelatedObjectInaccessible>
		<set_localX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_localX>
		<set_localY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_localY>
		<set_movementX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_movementX>
		<set_movementY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_movementY>
		<set_relatedObject set="method"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_relatedObject>
		<set_shiftKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta" v=":true:false:0:0::false:false:false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ delta : 0, buttonDown : false, shiftKey : false, altKey : false, ctrlKey : false, localY : 0, localX : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS final="1" public="1" set="null" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA final="1" public="1" set="null" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<get_bytesLoaded set="method"><f a=""><x path="Float"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="Float"/></f></get_bytesTotal>
		<set_bytesLoaded set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bytesLoaded>
		<set_bytesTotal set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bytesTotal>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bytesTotal : 0, bytesLoaded : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.events.TouchEvent" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/TouchEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROXIMITY_BEGIN final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_BEGIN>
		<PROXIMITY_END final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_END>
		<PROXIMITY_MOVE final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_MOVE>
		<PROXIMITY_OUT final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_OUT>
		<PROXIMITY_OVER final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_OVER>
		<PROXIMITY_ROLL_OUT final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_ROLL_OUT>
		<PROXIMITY_ROLL_OVER final="1" public="1" set="null" static="1"><c path="String"/></PROXIMITY_ROLL_OVER>
		<TOUCH_BEGIN final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP final="1" public="1" set="null" static="1"><c path="String"/></TOUCH_TAP>
		<altKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</altKey>
		<ctrlKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ctrlKey>
		<isPrimaryTouchPoint public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isPrimaryTouchPoint>
		<isRelatedObjectInaccessible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isRelatedObjectInaccessible>
		<localX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</localX>
		<localY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</localY>
		<pressure public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</pressure>
		<relatedObject public="1" get="accessor" set="accessor">
			<c path="flash.display.InteractiveObject"/>
			<meta><m n=":flash.property"/></meta>
		</relatedObject>
		<shiftKey public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</shiftKey>
		<sizeX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sizeX>
		<sizeY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sizeY>
		<stageX public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</stageX>
		<stageY public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</stageY>
		<touchPointID public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</touchPointID>
		<get_altKey set="method"><f a=""><x path="Bool"/></f></get_altKey>
		<get_ctrlKey set="method"><f a=""><x path="Bool"/></f></get_ctrlKey>
		<get_isPrimaryTouchPoint set="method"><f a=""><x path="Bool"/></f></get_isPrimaryTouchPoint>
		<get_isRelatedObjectInaccessible set="method"><f a=""><x path="Bool"/></f></get_isRelatedObjectInaccessible>
		<get_localX set="method"><f a=""><x path="Float"/></f></get_localX>
		<get_localY set="method"><f a=""><x path="Float"/></f></get_localY>
		<get_pressure set="method"><f a=""><x path="Float"/></f></get_pressure>
		<get_relatedObject set="method"><f a=""><c path="flash.display.InteractiveObject"/></f></get_relatedObject>
		<get_shiftKey set="method"><f a=""><x path="Bool"/></f></get_shiftKey>
		<get_sizeX set="method"><f a=""><x path="Float"/></f></get_sizeX>
		<get_sizeY set="method"><f a=""><x path="Float"/></f></get_sizeY>
		<get_stageX set="method"><f a=""><x path="Float"/></f></get_stageX>
		<get_stageY set="method"><f a=""><x path="Float"/></f></get_stageY>
		<get_touchPointID set="method"><f a=""><x path="Int"/></f></get_touchPointID>
		<set_altKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_altKey>
		<set_ctrlKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ctrlKey>
		<set_isPrimaryTouchPoint set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isPrimaryTouchPoint>
		<set_isRelatedObjectInaccessible set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_isRelatedObjectInaccessible>
		<set_localX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_localX>
		<set_localY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_localY>
		<set_pressure set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pressure>
		<set_relatedObject set="method"><f a="value">
	<c path="flash.display.InteractiveObject"/>
	<c path="flash.display.InteractiveObject"/>
</f></set_relatedObject>
		<set_shiftKey set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shiftKey>
		<set_sizeX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sizeX>
		<set_sizeY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sizeY>
		<set_touchPointID set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_touchPointID>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey" v=":true:false:0:false:0.:0.:0.:0.:0.::false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ shiftKey : false, altKey : false, ctrlKey : false, pressure : 0., sizeY : 0., sizeX : 0., localY : 0., localX : 0., isPrimaryTouchPoint : false, touchPointID : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:restArgs">
	<c path="String"/>
	<x path="haxe.extern.Rest"><d/></x>
	<d/>
</f></call>
		<get_available set="method" static="1"><f a=""><x path="Bool"/></f></get_available>
		<get_objectID set="method" static="1"><f a=""><c path="String"/></f></get_objectID>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/filters/GlowFilter.hx" extern="1" final="1">
		<extends path="flash.filters.BitmapFilter"/>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</alpha>
		<blurX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</blurX>
		<blurY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</blurY>
		<color public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</color>
		<inner public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</inner>
		<knockout public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</knockout>
		<quality public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<strength public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</strength>
		<get_alpha set="method"><f a=""><x path="Float"/></f></get_alpha>
		<get_blurX set="method"><f a=""><x path="Float"/></f></get_blurX>
		<get_blurY set="method"><f a=""><x path="Float"/></f></get_blurY>
		<get_color set="method"><f a=""><x path="UInt"/></f></get_color>
		<get_inner set="method"><f a=""><x path="Bool"/></f></get_inner>
		<get_knockout set="method"><f a=""><x path="Bool"/></f></get_knockout>
		<get_quality set="method"><f a=""><x path="Int"/></f></get_quality>
		<get_strength set="method"><f a=""><x path="Float"/></f></get_strength>
		<set_alpha set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_blurX set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_blurX>
		<set_blurY set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_blurY>
		<set_color set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_color>
		<set_inner set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inner>
		<set_knockout set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_knockout>
		<set_quality set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_quality>
		<set_strength set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_strength>
		<new public="1" set="method">
			<f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout" v="16711680:1:6:6:2:1:false:false">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ knockout : false, inner : false, quality : 1, strength : 2, blurY : 6, blurX : 6, alpha : 1, color : 16711680 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<get_color set="method"><f a=""><x path="UInt"/></f></get_color>
		<set_color set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_color>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaOffset : 0, blueOffset : 0, greenOffset : 0, redOffset : 0, alphaMultiplier : 1, blueMultiplier : 1, greenMultiplier : 1, redMultiplier : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Matrix" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<createBox public="1" set="method">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setTo public="1" set="method">
			<f a="aa:ba:ca:da:txa:tya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</determinant>
		<position public="1" get="accessor" set="accessor">
			<c path="flash.geom.Vector3D"/>
			<meta><m n=":flash.property"/></meta>
		</position>
		<rawData public="1" get="accessor" set="accessor">
			<c path="flash.Vector"><x path="Float"/></c>
			<meta><m n=":flash.property"/></meta>
		</rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method">
			<f a="column:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyRawDataFrom public="1" set="method">
			<f a="vector:?index:?transpose" v=":0:false">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataFrom>
		<copyRawDataTo public="1" set="method">
			<f a="vector:?index:?transpose" v=":0:false">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transpose : false, index : 0 }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</copyRawDataTo>
		<copyRowFrom public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRowTo public="1" set="method">
			<f a="row:vector3D">
				<x path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyToMatrix3D public="1" set="method">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<x path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<get_determinant set="method"><f a=""><x path="Float"/></f></get_determinant>
		<get_position set="method"><f a=""><c path="flash.geom.Vector3D"/></f></get_position>
		<get_rawData set="method"><f a=""><c path="flash.Vector"><x path="Float"/></c></f></get_rawData>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<x path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<set_position set="method"><f a="value">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></set_position>
		<set_rawData set="method"><f a="value">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
</f></set_rawData>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<abstract path="flash.geom.Orientation3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Orientation3D.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
		</meta>
		<impl><class path="flash.geom._Orientation3D.Orientation3D_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Orientation3D.hx" private="1" module="flash.geom.Orientation3D" extern="1" final="1">
	<AXIS_ANGLE public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AXIS_ANGLE>
	<EULER_ANGLES public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EULER_ANGLES>
	<QUATERNION public="1" set="null" static="1">
		<x path="flash.geom.Orientation3D"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUATERNION>
	<meta>
		<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.geom._Orientation3D.Orientation3D_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Orientation3D.hx" private="1" module="flash.geom.Orientation3D" extern="1" final="1">
		<AXIS_ANGLE public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AXIS_ANGLE>
		<EULER_ANGLES public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EULER_ANGLES>
		<QUATERNION public="1" set="null" static="1">
			<x path="flash.geom.Orientation3D"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUATERNION>
		<meta>
			<m n=":native"><e>"flash.geom.Orientation3D"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.geom.PerspectiveProjection" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fieldOfView>
		<focalLength public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</focalLength>
		<projectionCenter public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</projectionCenter>
		<get_fieldOfView set="method"><f a=""><x path="Float"/></f></get_fieldOfView>
		<get_focalLength set="method"><f a=""><x path="Float"/></f></get_focalLength>
		<get_projectionCenter set="method"><f a=""><c path="flash.geom.Point"/></f></get_projectionCenter>
		<set_fieldOfView set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fieldOfView>
		<set_focalLength set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_focalLength>
		<set_projectionCenter set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<copyFrom public="1" set="method">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<get_length set="method"><f a=""><x path="Float"/></f></get_length>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" set="method">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bottom>
		<bottomRight public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</right>
		<size public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</size>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</top>
		<topLeft public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<get_bottom set="method"><f a=""><x path="Float"/></f></get_bottom>
		<get_bottomRight set="method"><f a=""><c path="flash.geom.Point"/></f></get_bottomRight>
		<get_left set="method"><f a=""><x path="Float"/></f></get_left>
		<get_right set="method"><f a=""><x path="Float"/></f></get_right>
		<get_size set="method"><f a=""><c path="flash.geom.Point"/></f></get_size>
		<get_top set="method"><f a=""><x path="Float"/></f></get_top>
		<get_topLeft set="method"><f a=""><c path="flash.geom.Point"/></f></get_topLeft>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<set_bottom set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<set_bottomRight set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_bottomRight>
		<set_left set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<set_right set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<set_size set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_size>
		<set_top set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<set_topLeft set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_topLeft>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.geom.Transform" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1" get="accessor" set="accessor">
			<c path="flash.geom.ColorTransform"/>
			<meta><m n=":flash.property"/></meta>
		</colorTransform>
		<concatenatedColorTransform public="1" get="accessor" set="null">
			<c path="flash.geom.ColorTransform"/>
			<meta><m n=":flash.property"/></meta>
		</concatenatedColorTransform>
		<concatenatedMatrix public="1" get="accessor" set="null">
			<c path="flash.geom.Matrix"/>
			<meta><m n=":flash.property"/></meta>
		</concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor">
			<c path="flash.geom.Matrix"/>
			<meta><m n=":flash.property"/></meta>
		</matrix>
		<matrix3D public="1" get="accessor" set="accessor">
			<c path="flash.geom.Matrix3D"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</matrix3D>
		<perspectiveProjection public="1" get="accessor" set="accessor">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</perspectiveProjection>
		<pixelBounds public="1" get="accessor" set="null">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</pixelBounds>
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<get_colorTransform set="method"><f a=""><c path="flash.geom.ColorTransform"/></f></get_colorTransform>
		<get_concatenatedColorTransform set="method"><f a=""><c path="flash.geom.ColorTransform"/></f></get_concatenatedColorTransform>
		<get_concatenatedMatrix set="method"><f a=""><c path="flash.geom.Matrix"/></f></get_concatenatedMatrix>
		<get_matrix set="method"><f a=""><c path="flash.geom.Matrix"/></f></get_matrix>
		<get_matrix3D set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></get_matrix3D>
		<get_perspectiveProjection set="method"><f a=""><c path="flash.geom.PerspectiveProjection"/></f></get_perspectiveProjection>
		<get_pixelBounds set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_pixelBounds>
		<set_colorTransform set="method"><f a="value">
	<c path="flash.geom.ColorTransform"/>
	<c path="flash.geom.ColorTransform"/>
</f></set_colorTransform>
		<set_matrix set="method"><f a="value">
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.Matrix"/>
</f></set_matrix>
		<set_matrix3D set="method"><f a="value">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
</f></set_matrix3D>
		<set_perspectiveProjection set="method"><f a="value">
	<c path="flash.geom.PerspectiveProjection"/>
	<c path="flash.geom.PerspectiveProjection"/>
</f></set_perspectiveProjection>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS final="1" public="1" set="null" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<copyFrom public="1" set="method">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method">
			<f a="toCompare:?allFour" v=":false">
				<c path="flash.geom.Vector3D"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</equals>
		<get_length set="method"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared set="method"><f a=""><x path="Float"/></f></get_lengthSquared>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="flash.geom.Vector3D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</nearEquals>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" set="method">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="?x:?y:?z:?w" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK final="1" public="1" set="null" static="1"><c path="String"/></BLACK>
		<BLUE final="1" public="1" set="null" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW final="1" public="1" set="null" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL final="1" public="1" set="null" static="1"><c path="String"/></CASUAL>
		<CURSIVE final="1" public="1" set="null" static="1"><c path="String"/></CURSIVE>
		<CYAN final="1" public="1" set="null" static="1"><c path="String"/></CYAN>
		<DARK_BLUE final="1" public="1" set="null" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN final="1" public="1" set="null" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN final="1" public="1" set="null" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED final="1" public="1" set="null" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW final="1" public="1" set="null" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT final="1" public="1" set="null" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED final="1" public="1" set="null" static="1"><c path="String"/></DEPRESSED>
		<GRAY final="1" public="1" set="null" static="1"><c path="String"/></GRAY>
		<GREEN final="1" public="1" set="null" static="1"><c path="String"/></GREEN>
		<LARGE final="1" public="1" set="null" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW final="1" public="1" set="null" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA final="1" public="1" set="null" static="1"><c path="String"/></MAGENTA>
		<MEDIUM final="1" public="1" set="null" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE final="1" public="1" set="null" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS final="1" public="1" set="null" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED final="1" public="1" set="null" static="1"><c path="String"/></RAISED>
		<RED final="1" public="1" set="null" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW final="1" public="1" set="null" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL final="1" public="1" set="null" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS final="1" public="1" set="null" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM final="1" public="1" set="null" static="1"><c path="String"/></UNIFORM>
		<WHITE final="1" public="1" set="null" static="1"><c path="String"/></WHITE>
		<YELLOW final="1" public="1" set="null" static="1"><c path="String"/></YELLOW>
		<backgroundColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundColor>
		<backgroundOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundOpacity>
		<bottomInset public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</bottomInset>
		<edgeColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</edgeColor>
		<fillColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fillColor>
		<fillOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fillOpacity>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</font>
		<fontColor public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontColor>
		<fontEdge public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontEdge>
		<fontOpacity public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</fontOpacity>
		<size public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</size>
		<get_backgroundColor set="method"><f a=""><c path="String"/></f></get_backgroundColor>
		<get_backgroundOpacity set="method"><f a=""><c path="String"/></f></get_backgroundOpacity>
		<get_bottomInset set="method"><f a=""><c path="String"/></f></get_bottomInset>
		<get_edgeColor set="method"><f a=""><c path="String"/></f></get_edgeColor>
		<get_fillColor set="method"><f a=""><c path="String"/></f></get_fillColor>
		<get_fillOpacity set="method"><f a=""><c path="String"/></f></get_fillOpacity>
		<get_font set="method"><f a=""><c path="String"/></f></get_font>
		<get_fontColor set="method"><f a=""><c path="String"/></f></get_fontColor>
		<get_fontEdge set="method"><f a=""><c path="String"/></f></get_fontEdge>
		<get_fontOpacity set="method"><f a=""><c path="String"/></f></get_fontOpacity>
		<get_size set="method"><f a=""><c path="String"/></f></get_size>
		<set_backgroundColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_backgroundColor>
		<set_backgroundOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_backgroundOpacity>
		<set_bottomInset set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_bottomInset>
		<set_edgeColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_edgeColor>
		<set_fillColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fillColor>
		<set_fillOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fillOpacity>
		<set_font set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<set_fontColor set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontColor>
		<set_fontEdge set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontEdge>
		<set_fontOpacity set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontOpacity>
		<set_size set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_size>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING final="1" public="1" set="null" static="1"><x path="Int"/></BUFFERING>
		<EOF final="1" public="1" set="null" static="1"><x path="Int"/></EOF>
		<PAUSED final="1" public="1" set="null" static="1"><x path="Int"/></PAUSED>
		<PLAYING final="1" public="1" set="null" static="1"><x path="Int"/></PLAYING>
		<READY final="1" public="1" set="null" static="1"><x path="Int"/></READY>
		<SUSPENDED final="1" public="1" set="null" static="1"><x path="Int"/></SUSPENDED>
		<TRICK_PLAY final="1" public="1" set="null" static="1"><x path="Int"/></TRICK_PLAY>
		<UNINITIALIZED final="1" public="1" set="null" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</state>
		<get_state set="method"><f a=""><x path="Int"/></f></get_state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS final="1" public="1" set="null" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<AUDIO_ONLY_STREAM_END final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_END>
		<AUDIO_ONLY_STREAM_START final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_ONLY_STREAM_START>
		<AUDIO_START_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></AUDIO_START_ERROR>
		<BAD_MANIFEST_SIGNATURE final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIASAMPLE_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MEDIASAMPLE_FOUND>
		<BAD_MEDIA_INTERLEAVING final="1" public="1" set="null" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD final="1" public="1" set="null" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_ERASE_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_ERASE_TIMELINE>
		<CANNOT_FAIL_OVER final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_HANDLE_MAIN_MANIFEST_UPDATE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_HANDLE_MAIN_MANIFEST_UPDATE>
		<CANNOT_LOAD_PLAY_LIST final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CANNOT_SPLIT_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></CANNOT_SPLIT_TIMELINE>
		<CODEC_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE final="1" public="1" set="null" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH final="1" public="1" set="null" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CRYPTO_ALGORITHM_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ALGORITHM_NOT_SUPPORTED>
		<CRYPTO_ERROR_BAD_CERTIFICATE final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_CERTIFICATE>
		<CRYPTO_ERROR_BAD_PARAMETER final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BAD_PARAMETER>
		<CRYPTO_ERROR_BUFFER_TOO_SMALL final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_BUFFER_TOO_SMALL>
		<CRYPTO_ERROR_CORRUPTED_DATA final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_CORRUPTED_DATA>
		<CRYPTO_ERROR_DIGEST_FINISH final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_FINISH>
		<CRYPTO_ERROR_DIGEST_UPDATE final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_DIGEST_UPDATE>
		<CRYPTO_ERROR_UNKNOWN final="1" public="1" set="null" static="1"><x path="Int"/></CRYPTO_ERROR_UNKNOWN>
		<CURRENT_PERIOD_EXPIRED final="1" public="1" set="null" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DID_NOT_GET_NEXT_FRAGMENT final="1" public="1" set="null" static="1"><x path="Int"/></DID_NOT_GET_NEXT_FRAGMENT>
		<DRM_INIT_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE final="1" public="1" set="null" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<END_OF_PERIOD final="1" public="1" set="null" static="1"><x path="Int"/></END_OF_PERIOD>
		<EOF final="1" public="1" set="null" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_OPEN_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_OPEN_ERROR>
		<FILE_READ_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_READ_ERROR>
		<FILE_STRUCTURE_INVALID final="1" public="1" set="null" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FILE_WRITE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FILE_WRITE_ERROR>
		<FRAGMENT_READ_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT final="1" public="1" set="null" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<ID3_PARSE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></ID3_PARSE_ERROR>
		<INCOMPATIBLE_RENDER_MODE final="1" public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_RENDER_MODE>
		<INCOMPATIBLE_VERSION final="1" public="1" set="null" static="1"><x path="Int"/></INCOMPATIBLE_VERSION>
		<INTERNAL_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></INTERNAL_ERROR>
		<INVALID_KEY final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_KEY>
		<INVALID_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE final="1" public="1" set="null" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<KEY_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></KEY_NOT_FOUND>
		<KEY_SERVER_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></KEY_SERVER_NOT_FOUND>
		<LISTENER_NOT_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></LISTENER_NOT_FOUND>
		<LIVE_HOLD final="1" public="1" set="null" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD final="1" public="1" set="null" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE final="1" public="1" set="null" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<MAIN_MANIFEST_UPDATE_TO_BE_HANDLED final="1" public="1" set="null" static="1"><x path="Int"/></MAIN_MANIFEST_UPDATE_TO_BE_HANDLED>
		<MANIFEST_FILE_UNEXPECTEDLY_CHANGED final="1" public="1" set="null" static="1"><x path="Int"/></MANIFEST_FILE_UNEXPECTEDLY_CHANGED>
		<NETWORK_DOWN final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE final="1" public="1" set="null" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED final="1" public="1" set="null" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_AUDIO_SINK final="1" public="1" set="null" static="1"><x path="Int"/></NO_AUDIO_SINK>
		<NO_FIXED_SIZE final="1" public="1" set="null" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_TIMELINE final="1" public="1" set="null" static="1"><x path="Int"/></NO_TIMELINE>
		<NO_USEABLE_BITRATE_PROFILE final="1" public="1" set="null" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<NULL_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></NULL_OPERATION>
		<ONLY_ALLOWED_IN_PAUSED_STATE final="1" public="1" set="null" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED final="1" public="1" set="null" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY final="1" public="1" set="null" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW final="1" public="1" set="null" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></PARSE_ERROR>
		<PARTIAL_REPLACEMENT final="1" public="1" set="null" static="1"><x path="Int"/></PARTIAL_REPLACEMENT>
		<PERIOD_HOLD final="1" public="1" set="null" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED final="1" public="1" set="null" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED final="1" public="1" set="null" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<POSTROLL_WITH_LIVE_NOT_ALLOWED final="1" public="1" set="null" static="1"><x path="Int"/></POSTROLL_WITH_LIVE_NOT_ALLOWED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS final="1" public="1" set="null" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<PROTOCOL_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></PROTOCOL_NOT_SUPPORTED>
		<RANGE_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></RANGE_ERROR>
		<RANGE_SPANS_READHEAD final="1" public="1" set="null" static="1"><x path="Int"/></RANGE_SPANS_READHEAD>
		<RENDITION_M3U8_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></RENDITION_M3U8_ERROR>
		<REPLACEMENT_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED final="1" public="1" set="null" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SECURITY_ERROR final="1" public="1" set="null" static="1"><x path="Int"/></SECURITY_ERROR>
		<SEEK_FAILED final="1" public="1" set="null" static="1"><x path="Int"/></SEEK_FAILED>
		<SEGMENT_SKIPPED_ON_FAILURE final="1" public="1" set="null" static="1"><x path="Int"/></SEGMENT_SKIPPED_ON_FAILURE>
		<SIZE_UNKNOWN final="1" public="1" set="null" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SPS_PPS_FOUND_OUTSIDE_AVCC final="1" public="1" set="null" static="1"><x path="Int"/></SPS_PPS_FOUND_OUTSIDE_AVCC>
		<SUCCESS final="1" public="1" set="null" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE final="1" public="1" set="null" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<TIMELINE_TOO_SHORT final="1" public="1" set="null" static="1"><x path="Int"/></TIMELINE_TOO_SHORT>
		<UNDERFLOW final="1" public="1" set="null" static="1"><x path="Int"/></UNDERFLOW>
		<UNREPORTED_TIME_DISCONTINUITY_FOUND final="1" public="1" set="null" static="1"><x path="Int"/></UNREPORTED_TIME_DISCONTINUITY_FOUND>
		<UNSUPPORTED_CONFIGURATION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION final="1" public="1" set="null" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED final="1" public="1" set="null" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT final="1" public="1" set="null" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</result>
		<get_result set="method"><f a=""><x path="Int"/></f></get_result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE final="1" public="1" set="null" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE final="1" public="1" set="null" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED final="1" public="1" set="null" static="1"><c path="String"/></UNDEFINED>
		<backBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferLength>
		<backBufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</backBufferTime>
		<bufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferLength>
		<bufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferTime>
		<captionStyle public="1" get="null" set="accessor">
			<c path="flash.media.AVCaptionStyle"/>
			<meta><m n=":flash.property"/></meta>
		</captionStyle>
		<captionsEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</captionsEnabled>
		<clientLivePoint public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</clientLivePoint>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<decoderType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</decoderType>
		<droppedFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</droppedFrames>
		<frameTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameTime>
		<initialBufferTime public="1" get="null" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</initialBufferTime>
		<playState public="1" get="accessor" set="null">
			<c path="flash.media.AVPlayState"/>
			<meta><m n=":flash.property"/></meta>
		</playState>
		<renderType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</renderType>
		<time public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</time>
		<useHardwareDecoder public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useHardwareDecoder>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</volume>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<fastForward public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></fastForward>
		<get_backBufferLength set="method"><f a=""><x path="Float"/></f></get_backBufferLength>
		<get_bufferLength set="method"><f a=""><x path="Float"/></f></get_bufferLength>
		<get_captionsEnabled set="method"><f a=""><x path="Bool"/></f></get_captionsEnabled>
		<get_clientLivePoint set="method"><f a=""><x path="Float"/></f></get_clientLivePoint>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_decoderType set="method"><f a=""><c path="String"/></f></get_decoderType>
		<get_droppedFrames set="method"><f a=""><x path="Int"/></f></get_droppedFrames>
		<get_frameTime set="method"><f a=""><x path="Float"/></f></get_frameTime>
		<get_playState set="method"><f a=""><c path="flash.media.AVPlayState"/></f></get_playState>
		<get_renderType set="method"><f a=""><c path="String"/></f></get_renderType>
		<get_time set="method"><f a=""><x path="Float"/></f></get_time>
		<get_useHardwareDecoder set="method"><f a=""><x path="Bool"/></f></get_useHardwareDecoder>
		<get_volume set="method"><f a=""><x path="Float"/></f></get_volume>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<rewind public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></rewind>
		<seek public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seek>
		<seekToKeyFrame public="1" set="method">
			<f a="offset:?inBufferSeek" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.media.AVResult"/>
			</f>
			<meta><m n=":value"><e>{ inBufferSeek : true }</e></m></meta>
		</seekToKeyFrame>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<setPlaySpeed public="1" set="method"><f a="speed:reserved">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaySpeed>
		<set_backBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_backBufferTime>
		<set_bufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTime>
		<set_captionStyle set="method"><f a="value">
	<c path="flash.media.AVCaptionStyle"/>
	<c path="flash.media.AVCaptionStyle"/>
</f></set_captionStyle>
		<set_captionsEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_captionsEnabled>
		<set_initialBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_initialBufferTime>
		<set_useHardwareDecoder set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHardwareDecoder>
		<set_volume set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/Camera.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<names public="1" get="accessor" set="null" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</names>
		<_scanHardware public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":ns">
					<e>"flash.media"</e>
					<e>internal</e>
				</m>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<get_names set="method" static="1"><f a=""><c path="Array"><d/></c></f></get_names>
		<activityLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</activityLevel>
		<bandwidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bandwidth>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<fps public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fps>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<index public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</index>
		<keyFrameInterval public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</keyFrameInterval>
		<loopback public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</loopback>
		<motionLevel public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</motionLevel>
		<motionTimeout public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</motionTimeout>
		<muted public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</muted>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<position public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_2</e></m>
			</meta>
		</position>
		<quality public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<copyToByteArray public="1" set="method">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToByteArray>
		<copyToVector public="1" set="method">
			<f a="rect:destination">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</copyToVector>
		<drawToBitmapData public="1" set="method">
			<f a="destination">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</drawToBitmapData>
		<get_activityLevel set="method"><f a=""><x path="Float"/></f></get_activityLevel>
		<get_bandwidth set="method"><f a=""><x path="Int"/></f></get_bandwidth>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_fps set="method"><f a=""><x path="Float"/></f></get_fps>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_index set="method"><f a=""><x path="Int"/></f></get_index>
		<get_keyFrameInterval set="method"><f a=""><x path="Int"/></f></get_keyFrameInterval>
		<get_loopback set="method"><f a=""><x path="Bool"/></f></get_loopback>
		<get_motionLevel set="method"><f a=""><x path="Int"/></f></get_motionLevel>
		<get_motionTimeout set="method"><f a=""><x path="Int"/></f></get_motionTimeout>
		<get_muted set="method"><f a=""><x path="Bool"/></f></get_muted>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_position set="method"><f a=""><c path="String"/></f></get_position>
		<get_quality set="method"><f a=""><x path="Int"/></f></get_quality>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method">
			<f a="?compress" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ compress : false }</e></m></meta>
		</setLoopback>
		<setMode public="1" set="method">
			<f a="width:height:fps:?favorArea" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ favorArea : true }</e></m></meta>
		</setMode>
		<setMotionLevel public="1" set="method">
			<f a="motionLevel:?timeout" v=":2000">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : 2000 }</e></m></meta>
		</setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.ID3Info" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/ID3Info.hx" extern="1" final="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.Microphone" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/Microphone.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<names public="1" get="accessor" set="null" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</names>
		<getEnhancedMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta>
				<m n=":value"><e>{ index : -1 }</e></m>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1">
			<f a="?index" v="-1">
				<x path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":value"><e>{ index : -1 }</e></m></meta>
		</getMicrophone>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<get_names set="method" static="1"><f a=""><c path="Array"><d/></c></f></get_names>
		<activityLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</activityLevel>
		<codec public="1" get="accessor" set="accessor">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</codec>
		<enableVAD public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</enableVAD>
		<encodeQuality public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</encodeQuality>
		<enhancedOptions public="1" get="accessor" set="accessor">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</enhancedOptions>
		<framesPerPacket public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</framesPerPacket>
		<gain public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</gain>
		<index public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</index>
		<muted public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</muted>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</name>
		<noiseSuppressionLevel public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</noiseSuppressionLevel>
		<rate public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</rate>
		<silenceLevel public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</silenceLevel>
		<silenceTimeout public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</silenceTimeout>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<useEchoSuppression public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useEchoSuppression>
		<get_activityLevel set="method"><f a=""><x path="Float"/></f></get_activityLevel>
		<get_codec set="method"><f a=""><x path="flash.media.SoundCodec"/></f></get_codec>
		<get_enableVAD set="method"><f a=""><x path="Bool"/></f></get_enableVAD>
		<get_encodeQuality set="method"><f a=""><x path="Int"/></f></get_encodeQuality>
		<get_enhancedOptions set="method"><f a=""><c path="flash.media.MicrophoneEnhancedOptions"/></f></get_enhancedOptions>
		<get_framesPerPacket set="method"><f a=""><x path="Int"/></f></get_framesPerPacket>
		<get_gain set="method"><f a=""><x path="Float"/></f></get_gain>
		<get_index set="method"><f a=""><x path="Int"/></f></get_index>
		<get_muted set="method"><f a=""><x path="Bool"/></f></get_muted>
		<get_name set="method"><f a=""><c path="String"/></f></get_name>
		<get_noiseSuppressionLevel set="method"><f a=""><x path="Int"/></f></get_noiseSuppressionLevel>
		<get_rate set="method"><f a=""><x path="Int"/></f></get_rate>
		<get_silenceLevel set="method"><f a=""><x path="Float"/></f></get_silenceLevel>
		<get_silenceTimeout set="method"><f a=""><x path="Int"/></f></get_silenceTimeout>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_useEchoSuppression set="method"><f a=""><x path="Bool"/></f></get_useEchoSuppression>
		<setLoopBack public="1" set="method">
			<f a="?state" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : true }</e></m></meta>
		</setLoopBack>
		<setSilenceLevel public="1" set="method">
			<f a="silenceLevel:?timeout" v=":-1">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<set_codec set="method"><f a="value">
	<x path="flash.media.SoundCodec"/>
	<x path="flash.media.SoundCodec"/>
</f></set_codec>
		<set_enableVAD set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enableVAD>
		<set_encodeQuality set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_encodeQuality>
		<set_enhancedOptions set="method"><f a="value">
	<c path="flash.media.MicrophoneEnhancedOptions"/>
	<c path="flash.media.MicrophoneEnhancedOptions"/>
</f></set_enhancedOptions>
		<set_framesPerPacket set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_framesPerPacket>
		<set_gain set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<set_noiseSuppressionLevel set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_noiseSuppressionLevel>
		<set_rate set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_rate>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.media.MicrophoneEnhancedMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/MicrophoneEnhancedMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
		<impl><class path="flash.media._MicrophoneEnhancedMode.MicrophoneEnhancedMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/MicrophoneEnhancedMode.hx" private="1" module="flash.media.MicrophoneEnhancedMode" extern="1" final="1">
	<FULL_DUPLEX public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL_DUPLEX>
	<HALF_DUPLEX public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HALF_DUPLEX>
	<HEADSET public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEADSET>
	<OFF public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OFF>
	<SPEAKER_MUTE public="1" set="null" static="1">
		<x path="flash.media.MicrophoneEnhancedMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPEAKER_MUTE>
	<meta>
		<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.media._MicrophoneEnhancedMode.MicrophoneEnhancedMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/MicrophoneEnhancedMode.hx" private="1" module="flash.media.MicrophoneEnhancedMode" extern="1" final="1">
		<FULL_DUPLEX public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL_DUPLEX>
		<HALF_DUPLEX public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HALF_DUPLEX>
		<HEADSET public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEADSET>
		<OFF public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OFF>
		<SPEAKER_MUTE public="1" set="null" static="1">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPEAKER_MUTE>
		<meta>
			<m n=":native"><e>"flash.media.MicrophoneEnhancedMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1" final="1">
		<autoGain public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</autoGain>
		<echoPath public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</echoPath>
		<isVoiceDetected public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</isVoiceDetected>
		<mode public="1" get="accessor" set="accessor">
			<x path="flash.media.MicrophoneEnhancedMode"/>
			<meta><m n=":flash.property"/></meta>
		</mode>
		<nonLinearProcessing public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</nonLinearProcessing>
		<get_autoGain set="method"><f a=""><x path="Bool"/></f></get_autoGain>
		<get_echoPath set="method"><f a=""><x path="Int"/></f></get_echoPath>
		<get_isVoiceDetected set="method"><f a=""><x path="Int"/></f></get_isVoiceDetected>
		<get_mode set="method"><f a=""><x path="flash.media.MicrophoneEnhancedMode"/></f></get_mode>
		<get_nonLinearProcessing set="method"><f a=""><x path="Bool"/></f></get_nonLinearProcessing>
		<set_autoGain set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoGain>
		<set_echoPath set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_echoPath>
		<set_isVoiceDetected set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_isVoiceDetected>
		<set_mode set="method"><f a="value">
	<x path="flash.media.MicrophoneEnhancedMode"/>
	<x path="flash.media.MicrophoneEnhancedMode"/>
</f></set_mode>
		<set_nonLinearProcessing set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_nonLinearProcessing>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.Sound" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<id3 public="1" get="accessor" set="null">
			<c path="flash.media.ID3Info"/>
			<meta><m n=":flash.property"/></meta>
		</id3>
		<isBuffering public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isBuffering>
		<isURLInaccessible public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isURLInaccessible>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<url public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<extract public="1" set="method">
			<f a="target:length:?startPosition" v="::-1">
				<c path="flash.utils.ByteArray"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{ startPosition : -1 }</e></m>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</extract>
		<get_bytesLoaded set="method"><f a=""><x path="UInt"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="Int"/></f></get_bytesTotal>
		<get_id3 set="method"><f a=""><c path="flash.media.ID3Info"/></f></get_id3>
		<get_isBuffering set="method"><f a=""><x path="Bool"/></f></get_isBuffering>
		<get_isURLInaccessible set="method"><f a=""><x path="Bool"/></f></get_isURLInaccessible>
		<get_length set="method"><f a=""><x path="Float"/></f></get_length>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1" set="method">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method">
			<f a="bytes:samples:?format:?stereo:?sampleRate" v=":::true:44100">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ sampleRate : 44100, stereo : true }</e></m>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</loadPCMFromByteArray>
		<play public="1" set="method">
			<f a="?startTime:?loops:?sndTransform" v="0:0:">
				<x path="Float"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundChannel"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundChannel.hx" extern="1" final="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</leftPeak>
		<position public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</position>
		<rightPeak public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rightPeak>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<get_leftPeak set="method"><f a=""><x path="Float"/></f></get_leftPeak>
		<get_position set="method"><f a=""><x path="Float"/></f></get_position>
		<get_rightPeak set="method"><f a=""><x path="Float"/></f></get_rightPeak>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.media.SoundCodec" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundCodec.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.media.SoundCodec"</e></m>
		</meta>
		<impl><class path="flash.media._SoundCodec.SoundCodec_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundCodec.hx" private="1" module="flash.media.SoundCodec" extern="1" final="1">
	<NELLYMOSER public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NELLYMOSER>
	<PCMA public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PCMA>
	<PCMU public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PCMU>
	<SPEEX public="1" set="null" static="1">
		<x path="flash.media.SoundCodec"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPEEX>
	<meta>
		<m n=":native"><e>"flash.media.SoundCodec"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.media._SoundCodec.SoundCodec_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundCodec.hx" private="1" module="flash.media.SoundCodec" extern="1" final="1">
		<NELLYMOSER public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NELLYMOSER>
		<PCMA public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PCMA>
		<PCMU public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PCMU>
		<SPEEX public="1" set="null" static="1">
			<x path="flash.media.SoundCodec"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPEEX>
		<meta>
			<m n=":native"><e>"flash.media.SoundCodec"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.media.SoundLoaderContext" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<new public="1" set="method">
			<f a="?bufferTime:?checkPolicyFile" v="1000:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false, bufferTime : 1000 }</e></m></meta>
		</new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/SoundTransform.hx" extern="1" final="1">
		<leftToLeft public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</leftToLeft>
		<leftToRight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</leftToRight>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</pan>
		<rightToLeft public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rightToLeft>
		<rightToRight public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</rightToRight>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</volume>
		<get_leftToLeft set="method"><f a=""><x path="Float"/></f></get_leftToLeft>
		<get_leftToRight set="method"><f a=""><x path="Float"/></f></get_leftToRight>
		<get_pan set="method"><f a=""><x path="Float"/></f></get_pan>
		<get_rightToLeft set="method"><f a=""><x path="Float"/></f></get_rightToLeft>
		<get_rightToRight set="method"><f a=""><x path="Float"/></f></get_rightToRight>
		<get_volume set="method"><f a=""><x path="Float"/></f></get_volume>
		<set_leftToLeft set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_leftToLeft>
		<set_leftToRight set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_leftToRight>
		<set_pan set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<set_rightToLeft set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rightToLeft>
		<set_rightToRight set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rightToRight>
		<set_volume set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<new public="1" set="method">
			<f a="?vol:?panning" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ panning : 0, vol : 1 }</e></m></meta>
		</new>
	</class>
	<class path="flash.media.StageVideo" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" get="accessor" set="null">
			<c path="flash.Vector"><c path="String"/></c>
			<meta><m n=":flash.property"/></meta>
		</colorSpaces>
		<depth public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</depth>
		<pan public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</pan>
		<videoHeight public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoHeight>
		<videoWidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</videoWidth>
		<viewPort public="1" get="accessor" set="accessor">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":flash.property"/></meta>
		</viewPort>
		<zoom public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</zoom>
		<attachAVStream public="1" set="method">
			<f a="avStream">
				<c path="flash.media.AVStream"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_7</e></m></meta>
		</attachAVStream>
		<attachCamera public="1" set="method">
			<f a="theCamera">
				<c path="flash.media.Camera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</attachCamera>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<get_colorSpaces set="method"><f a=""><c path="flash.Vector"><c path="String"/></c></f></get_colorSpaces>
		<get_depth set="method"><f a=""><x path="Int"/></f></get_depth>
		<get_pan set="method"><f a=""><c path="flash.geom.Point"/></f></get_pan>
		<get_videoHeight set="method"><f a=""><x path="Int"/></f></get_videoHeight>
		<get_videoWidth set="method"><f a=""><x path="Int"/></f></get_videoWidth>
		<get_viewPort set="method"><f a=""><c path="flash.geom.Rectangle"/></f></get_viewPort>
		<get_zoom set="method"><f a=""><c path="flash.geom.Point"/></f></get_zoom>
		<set_depth set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_depth>
		<set_pan set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_pan>
		<set_viewPort set="method"><f a="value">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></set_viewPort>
		<set_zoom set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_zoom>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bandwidth>
		<codec public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</codec>
		<fps public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fps>
		<height public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</height>
		<keyFrameInterval public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</keyFrameInterval>
		<quality public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<width public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</width>
		<get_bandwidth set="method"><f a=""><x path="Int"/></f></get_bandwidth>
		<get_codec set="method"><f a=""><c path="String"/></f></get_codec>
		<get_fps set="method"><f a=""><x path="Float"/></f></get_fps>
		<get_height set="method"><f a=""><x path="Int"/></f></get_height>
		<get_keyFrameInterval set="method"><f a=""><x path="Int"/></f></get_keyFrameInterval>
		<get_quality set="method"><f a=""><x path="Int"/></f></get_quality>
		<get_width set="method"><f a=""><x path="Int"/></f></get_width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" get="accessor" set="accessor" static="1">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</defaultObjectEncoding>
		<get_defaultObjectEncoding set="method" static="1"><f a=""><x path="UInt"/></f></get_defaultObjectEncoding>
		<set_defaultObjectEncoding set="method" static="1"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_defaultObjectEncoding>
		<client public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</client>
		<connected public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</connected>
		<connectedProxyType public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</connectedProxyType>
		<farID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farID>
		<farNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farNonce>
		<maxPeerConnections public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</maxPeerConnections>
		<nearID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearID>
		<nearNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearNonce>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<protocol public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</protocol>
		<proxyType public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</proxyType>
		<unconnectedPeerStreams public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</unconnectedPeerStreams>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<usingTLS public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</usingTLS>
		<addHeader public="1" set="method">
			<f a="operation:?mustUnderstand:?param" v=":false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mustUnderstand : false }</e></m></meta>
		</addHeader>
		<call public="1" set="method"><f a="command:responder:restArgs">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:restArgs">
	<c path="String"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></connect>
		<get_client set="method"><f a=""><d/></f></get_client>
		<get_connected set="method"><f a=""><x path="Bool"/></f></get_connected>
		<get_connectedProxyType set="method"><f a=""><c path="String"/></f></get_connectedProxyType>
		<get_farID set="method"><f a=""><c path="String"/></f></get_farID>
		<get_farNonce set="method"><f a=""><c path="String"/></f></get_farNonce>
		<get_maxPeerConnections set="method"><f a=""><x path="UInt"/></f></get_maxPeerConnections>
		<get_nearID set="method"><f a=""><c path="String"/></f></get_nearID>
		<get_nearNonce set="method"><f a=""><c path="String"/></f></get_nearNonce>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_protocol set="method"><f a=""><c path="String"/></f></get_protocol>
		<get_proxyType set="method"><f a=""><c path="String"/></f></get_proxyType>
		<get_unconnectedPeerStreams set="method"><f a=""><c path="Array"><d/></c></f></get_unconnectedPeerStreams>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<get_usingTLS set="method"><f a=""><x path="Bool"/></f></get_usingTLS>
		<set_client set="method"><f a="value">
	<d/>
	<d/>
</f></set_client>
		<set_maxPeerConnections set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_maxPeerConnections>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<set_proxyType set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_proxyType>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS final="1" public="1" set="null" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<resetDRMVouchers public="1" set="method" static="1"><f a=""><x path="Void"/></f></resetDRMVouchers>
		<audioCodec public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</audioCodec>
		<audioReliable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</audioReliable>
		<audioSampleAccess public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</audioSampleAccess>
		<backBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</backBufferLength>
		<backBufferTime public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</backBufferTime>
		<bufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferLength>
		<bufferTime public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bufferTime>
		<bufferTimeMax public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</bufferTimeMax>
		<bytesLoaded public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesLoaded>
		<bytesTotal public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesTotal>
		<checkPolicyFile public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</checkPolicyFile>
		<client public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</client>
		<currentFPS public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentFPS>
		<dataReliable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</dataReliable>
		<decodedFrames public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</decodedFrames>
		<farID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farID>
		<farNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</farNonce>
		<inBufferSeek public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</inBufferSeek>
		<info public="1" get="accessor" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</info>
		<liveDelay public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</liveDelay>
		<maxPauseBufferTime public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastFetchPeriod>
		<multicastInfo public="1" get="accessor" set="null">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastInfo>
		<multicastPushNeighborLimit public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastRelayMarginDuration>
		<multicastWindowDuration public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</multicastWindowDuration>
		<nearNonce public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</nearNonce>
		<objectEncoding public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<peerStreams public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</peerStreams>
		<soundTransform public="1" get="accessor" set="accessor">
			<c path="flash.media.SoundTransform"/>
			<meta><m n=":flash.property"/></meta>
		</soundTransform>
		<time public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</time>
		<useHardwareDecoder public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</useHardwareDecoder>
		<useJitterBuffer public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</useJitterBuffer>
		<videoCodec public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</videoCodec>
		<videoReliable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoReliable>
		<videoSampleAccess public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoSampleAccess>
		<videoStreamSettings public="1" get="accessor" set="accessor">
			<c path="flash.media.VideoStreamSettings"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</videoStreamSettings>
		<appendBytes public="1" set="method">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<appendBytesAction public="1" set="method">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<attach public="1" set="method">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method">
			<f a="theCamera:?snapshotMilliseconds" v=":-1">
				<c path="flash.media.Camera"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ snapshotMilliseconds : -1 }</e></m></meta>
		</attachCamera>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<get_audioCodec set="method"><f a=""><x path="UInt"/></f></get_audioCodec>
		<get_audioReliable set="method"><f a=""><x path="Bool"/></f></get_audioReliable>
		<get_audioSampleAccess set="method"><f a=""><x path="Bool"/></f></get_audioSampleAccess>
		<get_backBufferLength set="method"><f a=""><x path="Float"/></f></get_backBufferLength>
		<get_backBufferTime set="method"><f a=""><x path="Float"/></f></get_backBufferTime>
		<get_bufferLength set="method"><f a=""><x path="Float"/></f></get_bufferLength>
		<get_bufferTime set="method"><f a=""><x path="Float"/></f></get_bufferTime>
		<get_bufferTimeMax set="method"><f a=""><x path="Float"/></f></get_bufferTimeMax>
		<get_bytesLoaded set="method"><f a=""><x path="UInt"/></f></get_bytesLoaded>
		<get_bytesTotal set="method"><f a=""><x path="UInt"/></f></get_bytesTotal>
		<get_checkPolicyFile set="method"><f a=""><x path="Bool"/></f></get_checkPolicyFile>
		<get_client set="method"><f a=""><d/></f></get_client>
		<get_currentFPS set="method"><f a=""><x path="Float"/></f></get_currentFPS>
		<get_dataReliable set="method"><f a=""><x path="Bool"/></f></get_dataReliable>
		<get_decodedFrames set="method"><f a=""><x path="UInt"/></f></get_decodedFrames>
		<get_farID set="method"><f a=""><c path="String"/></f></get_farID>
		<get_farNonce set="method"><f a=""><c path="String"/></f></get_farNonce>
		<get_inBufferSeek set="method"><f a=""><x path="Bool"/></f></get_inBufferSeek>
		<get_info set="method"><f a=""><c path="flash.net.NetStreamInfo"/></f></get_info>
		<get_liveDelay set="method"><f a=""><x path="Float"/></f></get_liveDelay>
		<get_maxPauseBufferTime set="method"><f a=""><x path="Float"/></f></get_maxPauseBufferTime>
		<get_multicastAvailabilitySendToAll set="method"><f a=""><x path="Bool"/></f></get_multicastAvailabilitySendToAll>
		<get_multicastAvailabilityUpdatePeriod set="method"><f a=""><x path="Float"/></f></get_multicastAvailabilityUpdatePeriod>
		<get_multicastFetchPeriod set="method"><f a=""><x path="Float"/></f></get_multicastFetchPeriod>
		<get_multicastInfo set="method"><f a=""><c path="flash.net.NetStreamMulticastInfo"/></f></get_multicastInfo>
		<get_multicastPushNeighborLimit set="method"><f a=""><x path="Float"/></f></get_multicastPushNeighborLimit>
		<get_multicastRelayMarginDuration set="method"><f a=""><x path="Float"/></f></get_multicastRelayMarginDuration>
		<get_multicastWindowDuration set="method"><f a=""><x path="Float"/></f></get_multicastWindowDuration>
		<get_nearNonce set="method"><f a=""><c path="String"/></f></get_nearNonce>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_peerStreams set="method"><f a=""><c path="Array"><d/></c></f></get_peerStreams>
		<get_soundTransform set="method"><f a=""><c path="flash.media.SoundTransform"/></f></get_soundTransform>
		<get_time set="method"><f a=""><x path="Float"/></f></get_time>
		<get_useHardwareDecoder set="method"><f a=""><x path="Bool"/></f></get_useHardwareDecoder>
		<get_useJitterBuffer set="method"><f a=""><x path="Bool"/></f></get_useJitterBuffer>
		<get_videoCodec set="method"><f a=""><x path="UInt"/></f></get_videoCodec>
		<get_videoReliable set="method"><f a=""><x path="Bool"/></f></get_videoReliable>
		<get_videoSampleAccess set="method"><f a=""><x path="Bool"/></f></get_videoSampleAccess>
		<get_videoStreamSettings set="method"><f a=""><c path="flash.media.VideoStreamSettings"/></f></get_videoStreamSettings>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<play public="1" set="method"><f a="restArgs">
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></play>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:restArgs">
	<c path="String"/>
	<x path="haxe.extern.Rest"><d/></x>
	<x path="Void"/>
</f></send>
		<set_audioReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_audioReliable>
		<set_audioSampleAccess set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_audioSampleAccess>
		<set_backBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_backBufferTime>
		<set_bufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTime>
		<set_bufferTimeMax set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bufferTimeMax>
		<set_checkPolicyFile set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_checkPolicyFile>
		<set_client set="method"><f a="value">
	<d/>
	<d/>
</f></set_client>
		<set_dataReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_dataReliable>
		<set_inBufferSeek set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_inBufferSeek>
		<set_maxPauseBufferTime set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_maxPauseBufferTime>
		<set_multicastAvailabilitySendToAll set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multicastAvailabilitySendToAll>
		<set_multicastAvailabilityUpdatePeriod set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastAvailabilityUpdatePeriod>
		<set_multicastFetchPeriod set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastFetchPeriod>
		<set_multicastPushNeighborLimit set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastPushNeighborLimit>
		<set_multicastRelayMarginDuration set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastRelayMarginDuration>
		<set_multicastWindowDuration set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_multicastWindowDuration>
		<set_soundTransform set="method"><f a="value">
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundTransform"/>
</f></set_soundTransform>
		<set_useHardwareDecoder set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useHardwareDecoder>
		<set_useJitterBuffer set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useJitterBuffer>
		<set_videoReliable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_videoReliable>
		<set_videoSampleAccess set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_videoSampleAccess>
		<set_videoStreamSettings set="method"><f a="value">
	<c path="flash.media.VideoStreamSettings"/>
	<c path="flash.media.VideoStreamSettings"/>
</f></set_videoStreamSettings>
		<step public="1" set="method">
			<f a="frames">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/NetStreamInfo.hx" extern="1" final="1">
		<SRTT public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</SRTT>
		<audioBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBufferByteLength>
		<audioBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBufferLength>
		<audioByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioByteCount>
		<audioBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioBytesPerSecond>
		<audioLossRate public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</audioLossRate>
		<byteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</byteCount>
		<currentBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</currentBytesPerSecond>
		<dataBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBufferByteLength>
		<dataBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBufferLength>
		<dataByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataByteCount>
		<dataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</dataBytesPerSecond>
		<droppedFrames public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</droppedFrames>
		<isLive public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isLive>
		<maxBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</maxBytesPerSecond>
		<metaData public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</metaData>
		<playbackBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</playbackBytesPerSecond>
		<resourceName public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</resourceName>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<videoBufferByteLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBufferByteLength>
		<videoBufferLength public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBufferLength>
		<videoByteCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoByteCount>
		<videoBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</videoBytesPerSecond>
		<videoLossRate public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</videoLossRate>
		<xmpData public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</xmpData>
		<get_SRTT set="method"><f a=""><x path="Float"/></f></get_SRTT>
		<get_audioBufferByteLength set="method"><f a=""><x path="Float"/></f></get_audioBufferByteLength>
		<get_audioBufferLength set="method"><f a=""><x path="Float"/></f></get_audioBufferLength>
		<get_audioByteCount set="method"><f a=""><x path="Float"/></f></get_audioByteCount>
		<get_audioBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_audioBytesPerSecond>
		<get_audioLossRate set="method"><f a=""><x path="Float"/></f></get_audioLossRate>
		<get_byteCount set="method"><f a=""><x path="Float"/></f></get_byteCount>
		<get_currentBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_currentBytesPerSecond>
		<get_dataBufferByteLength set="method"><f a=""><x path="Float"/></f></get_dataBufferByteLength>
		<get_dataBufferLength set="method"><f a=""><x path="Float"/></f></get_dataBufferLength>
		<get_dataByteCount set="method"><f a=""><x path="Float"/></f></get_dataByteCount>
		<get_dataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_dataBytesPerSecond>
		<get_droppedFrames set="method"><f a=""><x path="Float"/></f></get_droppedFrames>
		<get_isLive set="method"><f a=""><x path="Bool"/></f></get_isLive>
		<get_maxBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_maxBytesPerSecond>
		<get_metaData set="method"><f a=""><d/></f></get_metaData>
		<get_playbackBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_playbackBytesPerSecond>
		<get_resourceName set="method"><f a=""><c path="String"/></f></get_resourceName>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<get_videoBufferByteLength set="method"><f a=""><x path="Float"/></f></get_videoBufferByteLength>
		<get_videoBufferLength set="method"><f a=""><x path="Float"/></f></get_videoBufferLength>
		<get_videoByteCount set="method"><f a=""><x path="Float"/></f></get_videoByteCount>
		<get_videoBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_videoBytesPerSecond>
		<get_videoLossRate set="method"><f a=""><x path="Float"/></f></get_videoLossRate>
		<get_xmpData set="method"><f a=""><d/></f></get_xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method">
			<f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive" v="::::::::::::::::::::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isLive : true }</e></m></meta>
		</new>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/NetStreamMulticastInfo.hx" extern="1" final="1">
		<bytesPushedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesPushedFromPeers>
		<bytesPushedToPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sendDataBytesPerSecond>
		<get_bytesPushedFromPeers set="method"><f a=""><x path="Float"/></f></get_bytesPushedFromPeers>
		<get_bytesPushedToPeers set="method"><f a=""><x path="Float"/></f></get_bytesPushedToPeers>
		<get_bytesReceivedFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_bytesReceivedFromIPMulticast>
		<get_bytesReceivedFromServer set="method"><f a=""><x path="Float"/></f></get_bytesReceivedFromServer>
		<get_bytesRequestedByPeers set="method"><f a=""><x path="Float"/></f></get_bytesRequestedByPeers>
		<get_bytesRequestedFromPeers set="method"><f a=""><x path="Float"/></f></get_bytesRequestedFromPeers>
		<get_fragmentsPushedFromPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsPushedFromPeers>
		<get_fragmentsPushedToPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsPushedToPeers>
		<get_fragmentsReceivedFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_fragmentsReceivedFromIPMulticast>
		<get_fragmentsReceivedFromServer set="method"><f a=""><x path="Float"/></f></get_fragmentsReceivedFromServer>
		<get_fragmentsRequestedByPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsRequestedByPeers>
		<get_fragmentsRequestedFromPeers set="method"><f a=""><x path="Float"/></f></get_fragmentsRequestedFromPeers>
		<get_receiveControlBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_receiveControlBytesPerSecond>
		<get_receiveDataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecond>
		<get_receiveDataBytesPerSecondFromIPMulticast set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecondFromIPMulticast>
		<get_receiveDataBytesPerSecondFromServer set="method"><f a=""><x path="Float"/></f></get_receiveDataBytesPerSecondFromServer>
		<get_sendControlBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_sendControlBytesPerSecond>
		<get_sendControlBytesPerSecondToServer set="method"><f a=""><x path="Float"/></f></get_sendControlBytesPerSecondToServer>
		<get_sendDataBytesPerSecond set="method"><f a=""><x path="Float"/></f></get_sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><x path="Float"/></len>
		<offset public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><x path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.Responder" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/URLRequest.hx" extern="1" final="1">
		<contentType public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</contentType>
		<data public="1" get="accessor" set="accessor">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</data>
		<digest public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</digest>
		<method public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</method>
		<requestHeaders public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
			<meta><m n=":flash.property"/></meta>
		</requestHeaders>
		<url public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<get_contentType set="method"><f a=""><c path="String"/></f></get_contentType>
		<get_data set="method"><f a=""><d/></f></get_data>
		<get_digest set="method"><f a=""><c path="String"/></f></get_digest>
		<get_method set="method"><f a=""><c path="String"/></f></get_method>
		<get_requestHeaders set="method"><f a=""><c path="Array"><c path="flash.net.URLRequestHeader"/></c></f></get_requestHeaders>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<set_contentType set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_contentType>
		<set_data set="method"><f a="value">
	<d/>
	<d/>
</f></set_data>
		<set_digest set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_digest>
		<set_method set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_method>
		<set_requestHeaders set="method"><f a="value">
	<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
	<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
</f></set_requestHeaders>
		<set_url set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_url>
		<useRedirectedURL public="1" set="method">
			<f a="sourceRequest:?wholeURL:?pattern:?replace" v=":false::">
				<c path="flash.net.URLRequest"/>
				<x path="Bool"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ wholeURL : false }</e></m></meta>
		</useRedirectedURL>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/net/URLRequestHeader.hx" extern="1" final="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/ApplicationDomain.hx" extern="1" final="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" get="accessor" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" get="accessor" set="null" static="1">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</currentDomain>
		<get_MIN_DOMAIN_MEMORY_LENGTH set="method" static="1"><f a=""><x path="UInt"/></f></get_MIN_DOMAIN_MEMORY_LENGTH>
		<get_currentDomain set="method" static="1"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_currentDomain>
		<domainMemory public="1" get="accessor" set="accessor">
			<c path="flash.utils.ByteArray"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</domainMemory>
		<parentDomain public="1" get="accessor" set="null">
			<c path="flash.system.ApplicationDomain"/>
			<meta><m n=":flash.property"/></meta>
		</parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="flash.utils.Object"/>
</f></getDefinition>
		<getQualifiedDefinitionNames public="1" set="method">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<get_domainMemory set="method"><f a=""><c path="flash.utils.ByteArray"/></f></get_domainMemory>
		<get_parentDomain set="method"><f a=""><c path="flash.system.ApplicationDomain"/></f></get_parentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<set_domainMemory set="method"><f a="value">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
</f></set_domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.Capabilities" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/Capabilities.hx" extern="1">
		<_internal public="1" get="accessor" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</_internal>
		<avHardwareDisable public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</avHardwareDisable>
		<cpuAddressSize public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</cpuAddressSize>
		<cpuArchitecture public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</cpuArchitecture>
		<hasAccessibility public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasAccessibility>
		<hasAudio public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasAudio>
		<hasAudioEncoder public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasAudioEncoder>
		<hasEmbeddedVideo public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasEmbeddedVideo>
		<hasIME public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasIME>
		<hasMP3 public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasMP3>
		<hasPrinting public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasPrinting>
		<hasScreenBroadcast public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasScreenBroadcast>
		<hasScreenPlayback public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasScreenPlayback>
		<hasStreamingAudio public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasStreamingAudio>
		<hasStreamingVideo public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasStreamingVideo>
		<hasTLS public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasTLS>
		<hasVideoEncoder public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</hasVideoEncoder>
		<isDebugger public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</isDebugger>
		<isEmbeddedInAcrobat public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</isEmbeddedInAcrobat>
		<language public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</language>
		<localFileReadDisable public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</localFileReadDisable>
		<manufacturer public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</manufacturer>
		<maxLevelIDC public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</maxLevelIDC>
		<os public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</os>
		<pixelAspectRatio public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</pixelAspectRatio>
		<playerType public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</playerType>
		<screenColor public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</screenColor>
		<screenDPI public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</screenDPI>
		<screenResolutionX public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</screenResolutionX>
		<screenResolutionY public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</screenResolutionY>
		<serverString public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</serverString>
		<supports32BitProcesses public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</supports32BitProcesses>
		<supports64BitProcesses public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</supports64BitProcesses>
		<touchscreenType public="1" get="accessor" set="null" static="1">
			<x path="flash.system.TouchscreenType"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</touchscreenType>
		<version public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</version>
		<get__internal set="method" static="1"><f a=""><x path="UInt"/></f></get__internal>
		<get_avHardwareDisable set="method" static="1"><f a=""><x path="Bool"/></f></get_avHardwareDisable>
		<get_cpuAddressSize set="method" static="1"><f a=""><x path="Float"/></f></get_cpuAddressSize>
		<get_cpuArchitecture set="method" static="1"><f a=""><c path="String"/></f></get_cpuArchitecture>
		<get_hasAccessibility set="method" static="1"><f a=""><x path="Bool"/></f></get_hasAccessibility>
		<get_hasAudio set="method" static="1"><f a=""><x path="Bool"/></f></get_hasAudio>
		<get_hasAudioEncoder set="method" static="1"><f a=""><x path="Bool"/></f></get_hasAudioEncoder>
		<get_hasEmbeddedVideo set="method" static="1"><f a=""><x path="Bool"/></f></get_hasEmbeddedVideo>
		<get_hasIME set="method" static="1"><f a=""><x path="Bool"/></f></get_hasIME>
		<get_hasMP3 set="method" static="1"><f a=""><x path="Bool"/></f></get_hasMP3>
		<get_hasPrinting set="method" static="1"><f a=""><x path="Bool"/></f></get_hasPrinting>
		<get_hasScreenBroadcast set="method" static="1"><f a=""><x path="Bool"/></f></get_hasScreenBroadcast>
		<get_hasScreenPlayback set="method" static="1"><f a=""><x path="Bool"/></f></get_hasScreenPlayback>
		<get_hasStreamingAudio set="method" static="1"><f a=""><x path="Bool"/></f></get_hasStreamingAudio>
		<get_hasStreamingVideo set="method" static="1"><f a=""><x path="Bool"/></f></get_hasStreamingVideo>
		<get_hasTLS set="method" static="1"><f a=""><x path="Bool"/></f></get_hasTLS>
		<get_hasVideoEncoder set="method" static="1"><f a=""><x path="Bool"/></f></get_hasVideoEncoder>
		<get_isDebugger set="method" static="1"><f a=""><x path="Bool"/></f></get_isDebugger>
		<get_isEmbeddedInAcrobat set="method" static="1"><f a=""><x path="Bool"/></f></get_isEmbeddedInAcrobat>
		<get_language set="method" static="1"><f a=""><c path="String"/></f></get_language>
		<get_localFileReadDisable set="method" static="1"><f a=""><x path="Bool"/></f></get_localFileReadDisable>
		<get_manufacturer set="method" static="1"><f a=""><c path="String"/></f></get_manufacturer>
		<get_maxLevelIDC set="method" static="1"><f a=""><c path="String"/></f></get_maxLevelIDC>
		<get_os set="method" static="1"><f a=""><c path="String"/></f></get_os>
		<get_pixelAspectRatio set="method" static="1"><f a=""><x path="Float"/></f></get_pixelAspectRatio>
		<get_playerType set="method" static="1"><f a=""><c path="String"/></f></get_playerType>
		<get_screenColor set="method" static="1"><f a=""><c path="String"/></f></get_screenColor>
		<get_screenDPI set="method" static="1"><f a=""><x path="Float"/></f></get_screenDPI>
		<get_screenResolutionX set="method" static="1"><f a=""><x path="Float"/></f></get_screenResolutionX>
		<get_screenResolutionY set="method" static="1"><f a=""><x path="Float"/></f></get_screenResolutionY>
		<get_serverString set="method" static="1"><f a=""><c path="String"/></f></get_serverString>
		<get_supports32BitProcesses set="method" static="1"><f a=""><x path="Bool"/></f></get_supports32BitProcesses>
		<get_supports64BitProcesses set="method" static="1"><f a=""><x path="Bool"/></f></get_supports64BitProcesses>
		<get_touchscreenType set="method" static="1"><f a=""><x path="flash.system.TouchscreenType"/></f></get_touchscreenType>
		<get_version set="method" static="1"><f a=""><c path="String"/></f></get_version>
		<hasMultiChannelAudio public="1" set="method" static="1">
			<f a="type">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</hasMultiChannelAudio>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.system.ImageDecodingPolicy" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/ImageDecodingPolicy.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
		</meta>
		<impl><class path="flash.system._ImageDecodingPolicy.ImageDecodingPolicy_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/ImageDecodingPolicy.hx" private="1" module="flash.system.ImageDecodingPolicy" extern="1" final="1">
	<ON_DEMAND public="1" set="null" static="1">
		<x path="flash.system.ImageDecodingPolicy"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ON_DEMAND>
	<ON_LOAD public="1" set="null" static="1">
		<x path="flash.system.ImageDecodingPolicy"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ON_LOAD>
	<meta>
		<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.system._ImageDecodingPolicy.ImageDecodingPolicy_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/ImageDecodingPolicy.hx" private="1" module="flash.system.ImageDecodingPolicy" extern="1" final="1">
		<ON_DEMAND public="1" set="null" static="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ON_DEMAND>
		<ON_LOAD public="1" set="null" static="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ON_LOAD>
		<meta>
			<m n=":native"><e>"flash.system.ImageDecodingPolicy"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.system.LoaderContext" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<allowLoadBytesCodeExecution public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<imageDecodingPolicy public="1">
			<x path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<get_allowLoadBytesCodeExecution set="method"><f a=""><x path="Bool"/></f></get_allowLoadBytesCodeExecution>
		<set_allowLoadBytesCodeExecution set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowLoadBytesCodeExecution>
		<new public="1" set="method">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false::">
				<x path="Bool"/>
				<c path="flash.system.ApplicationDomain"/>
				<c path="flash.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" get="accessor" set="null" static="1">
			<c path="flash.system.SecurityDomain"/>
			<meta><m n=":flash.property"/></meta>
		</currentDomain>
		<get_currentDomain set="method" static="1"><f a=""><c path="flash.system.SecurityDomain"/></f></get_currentDomain>
		<domainID public="1" get="accessor" set="null">
			<c path="String"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_3</e></m>
			</meta>
		</domainID>
		<get_domainID set="method"><f a=""><c path="String"/></f></get_domainID>
	</class>
	<abstract path="flash.system.TouchscreenType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/TouchscreenType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.system.TouchscreenType"</e></m>
		</meta>
		<impl><class path="flash.system._TouchscreenType.TouchscreenType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/TouchscreenType.hx" private="1" module="flash.system.TouchscreenType" extern="1" final="1">
	<FINGER public="1" set="null" static="1">
		<x path="flash.system.TouchscreenType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FINGER>
	<NONE public="1" set="null" static="1">
		<x path="flash.system.TouchscreenType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<STYLUS public="1" set="null" static="1">
		<x path="flash.system.TouchscreenType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STYLUS>
	<meta>
		<m n=":native"><e>"flash.system.TouchscreenType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.system._TouchscreenType.TouchscreenType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/system/TouchscreenType.hx" private="1" module="flash.system.TouchscreenType" extern="1" final="1">
		<FINGER public="1" set="null" static="1">
			<x path="flash.system.TouchscreenType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FINGER>
		<NONE public="1" set="null" static="1">
			<x path="flash.system.TouchscreenType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<STYLUS public="1" set="null" static="1">
			<x path="flash.system.TouchscreenType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STYLUS>
		<meta>
			<m n=":native"><e>"flash.system.TouchscreenType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.AntiAliasType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/AntiAliasType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
		</meta>
		<impl><class path="flash.text._AntiAliasType.AntiAliasType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/AntiAliasType.hx" private="1" module="flash.text.AntiAliasType" extern="1" final="1">
	<ADVANCED public="1" set="null" static="1">
		<x path="flash.text.AntiAliasType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADVANCED>
	<NORMAL public="1" set="null" static="1">
		<x path="flash.text.AntiAliasType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<meta>
		<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._AntiAliasType.AntiAliasType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/AntiAliasType.hx" private="1" module="flash.text.AntiAliasType" extern="1" final="1">
		<ADVANCED public="1" set="null" static="1">
			<x path="flash.text.AntiAliasType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADVANCED>
		<NORMAL public="1" set="null" static="1">
			<x path="flash.text.AntiAliasType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<meta>
			<m n=":native"><e>"flash.text.AntiAliasType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.GridFitType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/GridFitType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.GridFitType"</e></m>
		</meta>
		<impl><class path="flash.text._GridFitType.GridFitType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/GridFitType.hx" private="1" module="flash.text.GridFitType" extern="1" final="1">
	<NONE public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<PIXEL public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PIXEL>
	<SUBPIXEL public="1" set="null" static="1">
		<x path="flash.text.GridFitType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBPIXEL>
	<meta>
		<m n=":native"><e>"flash.text.GridFitType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._GridFitType.GridFitType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/GridFitType.hx" private="1" module="flash.text.GridFitType" extern="1" final="1">
		<NONE public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<PIXEL public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PIXEL>
		<SUBPIXEL public="1" set="null" static="1">
			<x path="flash.text.GridFitType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBPIXEL>
		<meta>
			<m n=":native"><e>"flash.text.GridFitType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.StyleSheet" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" get="accessor" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</styleNames>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<x path="flash.utils.Object"/>
</f></getStyle>
		<get_styleNames set="method"><f a=""><c path="Array"><d/></c></f></get_styleNames>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<x path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<x path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.text.TextField" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<alwaysShowSelection public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</alwaysShowSelection>
		<antiAliasType public="1" get="accessor" set="accessor">
			<x path="flash.text.AntiAliasType"/>
			<meta><m n=":flash.property"/></meta>
		</antiAliasType>
		<autoSize public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta><m n=":flash.property"/></meta>
		</autoSize>
		<background public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</background>
		<backgroundColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</backgroundColor>
		<border public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</border>
		<borderColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</borderColor>
		<bottomScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</bottomScrollV>
		<caretIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</caretIndex>
		<condenseWhite public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</condenseWhite>
		<defaultTextFormat public="1" get="accessor" set="accessor">
			<c path="flash.text.TextFormat"/>
			<meta><m n=":flash.property"/></meta>
		</defaultTextFormat>
		<displayAsPassword public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</displayAsPassword>
		<embedFonts public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</embedFonts>
		<gridFitType public="1" get="accessor" set="accessor">
			<x path="flash.text.GridFitType"/>
			<meta><m n=":flash.property"/></meta>
		</gridFitType>
		<htmlText public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</htmlText>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<maxChars public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxChars>
		<maxScrollH public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxScrollH>
		<maxScrollV public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxScrollV>
		<mouseWheelEnabled public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mouseWheelEnabled>
		<multiline public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</multiline>
		<numLines public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</numLines>
		<restrict public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</restrict>
		<scrollH public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</scrollH>
		<scrollV public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</scrollV>
		<selectable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</selectable>
		<selectedText public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</selectedText>
		<selectionBeginIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</selectionBeginIndex>
		<selectionEndIndex public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</selectionEndIndex>
		<sharpness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</sharpness>
		<styleSheet public="1" get="accessor" set="accessor">
			<c path="flash.text.StyleSheet"/>
			<meta><m n=":flash.property"/></meta>
		</styleSheet>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</text>
		<textColor public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</textColor>
		<textHeight public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</textHeight>
		<textInteractionMode public="1" get="accessor" set="null">
			<x path="flash.text.TextInteractionMode"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11</e></m>
			</meta>
		</textInteractionMode>
		<textWidth public="1" get="accessor" set="null">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</textWidth>
		<thickness public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</thickness>
		<type public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFieldType"/>
			<meta><m n=":flash.property"/></meta>
		</type>
		<useRichTextClipboard public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</useRichTextClipboard>
		<wordWrap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":ns">
	<e>"flash.text"</e>
	<e>internal</e>
</m></meta>
		</copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method">
			<f a="?beginIndex:?endIndex" v="-1:-1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</getTextFormat>
		<getTextRuns public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getTextRuns>
		<getXMLText public="1" set="method">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</getXMLText>
		<get_alwaysShowSelection set="method"><f a=""><x path="Bool"/></f></get_alwaysShowSelection>
		<get_antiAliasType set="method"><f a=""><x path="flash.text.AntiAliasType"/></f></get_antiAliasType>
		<get_autoSize set="method"><f a=""><x path="flash.text.TextFieldAutoSize"/></f></get_autoSize>
		<get_background set="method"><f a=""><x path="Bool"/></f></get_background>
		<get_backgroundColor set="method"><f a=""><x path="UInt"/></f></get_backgroundColor>
		<get_border set="method"><f a=""><x path="Bool"/></f></get_border>
		<get_borderColor set="method"><f a=""><x path="UInt"/></f></get_borderColor>
		<get_bottomScrollV set="method"><f a=""><x path="Int"/></f></get_bottomScrollV>
		<get_caretIndex set="method"><f a=""><x path="Int"/></f></get_caretIndex>
		<get_condenseWhite set="method"><f a=""><x path="Bool"/></f></get_condenseWhite>
		<get_defaultTextFormat set="method"><f a=""><c path="flash.text.TextFormat"/></f></get_defaultTextFormat>
		<get_displayAsPassword set="method"><f a=""><x path="Bool"/></f></get_displayAsPassword>
		<get_embedFonts set="method"><f a=""><x path="Bool"/></f></get_embedFonts>
		<get_gridFitType set="method"><f a=""><x path="flash.text.GridFitType"/></f></get_gridFitType>
		<get_htmlText set="method"><f a=""><c path="String"/></f></get_htmlText>
		<get_length set="method"><f a=""><x path="Int"/></f></get_length>
		<get_maxChars set="method"><f a=""><x path="Int"/></f></get_maxChars>
		<get_maxScrollH set="method"><f a=""><x path="Int"/></f></get_maxScrollH>
		<get_maxScrollV set="method"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_mouseWheelEnabled set="method"><f a=""><x path="Bool"/></f></get_mouseWheelEnabled>
		<get_multiline set="method"><f a=""><x path="Bool"/></f></get_multiline>
		<get_numLines set="method"><f a=""><x path="Int"/></f></get_numLines>
		<get_restrict set="method"><f a=""><c path="String"/></f></get_restrict>
		<get_scrollH set="method"><f a=""><x path="Int"/></f></get_scrollH>
		<get_scrollV set="method"><f a=""><x path="Int"/></f></get_scrollV>
		<get_selectable set="method"><f a=""><x path="Bool"/></f></get_selectable>
		<get_selectedText set="method"><f a=""><c path="String"/></f></get_selectedText>
		<get_selectionBeginIndex set="method"><f a=""><x path="Int"/></f></get_selectionBeginIndex>
		<get_selectionEndIndex set="method"><f a=""><x path="Int"/></f></get_selectionEndIndex>
		<get_sharpness set="method"><f a=""><x path="Float"/></f></get_sharpness>
		<get_styleSheet set="method"><f a=""><c path="flash.text.StyleSheet"/></f></get_styleSheet>
		<get_text set="method"><f a=""><c path="String"/></f></get_text>
		<get_textColor set="method"><f a=""><x path="UInt"/></f></get_textColor>
		<get_textHeight set="method"><f a=""><x path="Float"/></f></get_textHeight>
		<get_textInteractionMode set="method"><f a=""><x path="flash.text.TextInteractionMode"/></f></get_textInteractionMode>
		<get_textWidth set="method"><f a=""><x path="Float"/></f></get_textWidth>
		<get_thickness set="method"><f a=""><x path="Float"/></f></get_thickness>
		<get_type set="method"><f a=""><x path="flash.text.TextFieldType"/></f></get_type>
		<get_useRichTextClipboard set="method"><f a=""><x path="Bool"/></f></get_useRichTextClipboard>
		<get_wordWrap set="method"><f a=""><x path="Bool"/></f></get_wordWrap>
		<insertXMLText public="1" set="method">
			<f a="beginIndex:endIndex:richText:?pasting" v=":::false">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pasting : false }</e></m></meta>
		</insertXMLText>
		<pasteRichText public="1" set="method">
			<f a="richText">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns">
	<e>"flash.text"</e>
	<e>internal</e>
</m></meta>
		</pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method">
			<f a="format:?beginIndex:?endIndex" v=":-1:-1">
				<c path="flash.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : -1, beginIndex : -1 }</e></m></meta>
		</setTextFormat>
		<set_alwaysShowSelection set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alwaysShowSelection>
		<set_antiAliasType set="method"><f a="value">
	<x path="flash.text.AntiAliasType"/>
	<x path="flash.text.AntiAliasType"/>
</f></set_antiAliasType>
		<set_autoSize set="method"><f a="value">
	<x path="flash.text.TextFieldAutoSize"/>
	<x path="flash.text.TextFieldAutoSize"/>
</f></set_autoSize>
		<set_background set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<set_backgroundColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_backgroundColor>
		<set_border set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_border>
		<set_borderColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_borderColor>
		<set_condenseWhite set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_condenseWhite>
		<set_defaultTextFormat set="method"><f a="value">
	<c path="flash.text.TextFormat"/>
	<c path="flash.text.TextFormat"/>
</f></set_defaultTextFormat>
		<set_displayAsPassword set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_displayAsPassword>
		<set_embedFonts set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_embedFonts>
		<set_gridFitType set="method"><f a="value">
	<x path="flash.text.GridFitType"/>
	<x path="flash.text.GridFitType"/>
</f></set_gridFitType>
		<set_htmlText set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_htmlText>
		<set_maxChars set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxChars>
		<set_mouseWheelEnabled set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mouseWheelEnabled>
		<set_multiline set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<set_restrict set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_restrict>
		<set_scrollH set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollH>
		<set_scrollV set="method"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollV>
		<set_selectable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectable>
		<set_sharpness set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<set_styleSheet set="method"><f a="value">
	<c path="flash.text.StyleSheet"/>
	<c path="flash.text.StyleSheet"/>
</f></set_styleSheet>
		<set_text set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<set_textColor set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_textColor>
		<set_thickness set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_thickness>
		<set_type set="method"><f a="value">
	<x path="flash.text.TextFieldType"/>
	<x path="flash.text.TextFieldType"/>
</f></set_type>
		<set_useRichTextClipboard set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useRichTextClipboard>
		<set_wordWrap set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.text.TextFieldAutoSize" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldAutoSize.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
		</meta>
		<impl><class path="flash.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldAutoSize.hx" private="1" module="flash.text.TextFieldAutoSize" extern="1" final="1">
	<CENTER public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CENTER>
	<LEFT public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<NONE public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.text.TextFieldAutoSize"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldAutoSize.hx" private="1" module="flash.text.TextFieldAutoSize" extern="1" final="1">
		<CENTER public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CENTER>
		<LEFT public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<NONE public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.text.TextFieldAutoSize"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.text.TextFieldAutoSize"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextFieldType" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldType.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFieldType"</e></m>
		</meta>
		<impl><class path="flash.text._TextFieldType.TextFieldType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldType.hx" private="1" module="flash.text.TextFieldType" extern="1" final="1">
	<DYNAMIC public="1" set="null" static="1">
		<x path="flash.text.TextFieldType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DYNAMIC>
	<INPUT public="1" set="null" static="1">
		<x path="flash.text.TextFieldType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INPUT>
	<meta>
		<m n=":native"><e>"flash.text.TextFieldType"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFieldType.TextFieldType_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFieldType.hx" private="1" module="flash.text.TextFieldType" extern="1" final="1">
		<DYNAMIC public="1" set="null" static="1">
			<x path="flash.text.TextFieldType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DYNAMIC>
		<INPUT public="1" set="null" static="1">
			<x path="flash.text.TextFieldType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INPUT>
		<meta>
			<m n=":native"><e>"flash.text.TextFieldType"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.TextFormat" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormat.hx" extern="1">
		<align public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFormatAlign"/>
			<meta><m n=":flash.property"/></meta>
		</align>
		<blockIndent public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</blockIndent>
		<bold public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</bold>
		<bullet public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</bullet>
		<color public="1" get="accessor" set="accessor">
			<x path="Null"><x path="UInt"/></x>
			<meta><m n=":flash.property"/></meta>
		</color>
		<display public="1" get="accessor" set="accessor">
			<x path="flash.text.TextFormatDisplay"/>
			<meta><m n=":flash.property"/></meta>
		</display>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</font>
		<indent public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</indent>
		<italic public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</italic>
		<kerning public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</kerning>
		<leading public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</leading>
		<leftMargin public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</leftMargin>
		<letterSpacing public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</letterSpacing>
		<rightMargin public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</rightMargin>
		<size public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Float"/></x>
			<meta><m n=":flash.property"/></meta>
		</size>
		<tabStops public="1" get="accessor" set="accessor">
			<c path="Array"><x path="UInt"/></c>
			<meta><m n=":flash.property"/></meta>
		</tabStops>
		<target public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</target>
		<underline public="1" get="accessor" set="accessor">
			<x path="Null"><x path="Bool"/></x>
			<meta><m n=":flash.property"/></meta>
		</underline>
		<url public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</url>
		<get_align set="method"><f a=""><x path="flash.text.TextFormatAlign"/></f></get_align>
		<get_blockIndent set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_blockIndent>
		<get_bold set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_bold>
		<get_bullet set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_bullet>
		<get_color set="method"><f a=""><x path="Null"><x path="UInt"/></x></f></get_color>
		<get_display set="method"><f a=""><x path="flash.text.TextFormatDisplay"/></f></get_display>
		<get_font set="method"><f a=""><c path="String"/></f></get_font>
		<get_indent set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_indent>
		<get_italic set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_italic>
		<get_kerning set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_kerning>
		<get_leading set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_leading>
		<get_leftMargin set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_leftMargin>
		<get_letterSpacing set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_letterSpacing>
		<get_rightMargin set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_rightMargin>
		<get_size set="method"><f a=""><x path="Null"><x path="Float"/></x></f></get_size>
		<get_tabStops set="method"><f a=""><c path="Array"><x path="UInt"/></c></f></get_tabStops>
		<get_target set="method"><f a=""><c path="String"/></f></get_target>
		<get_underline set="method"><f a=""><x path="Null"><x path="Bool"/></x></f></get_underline>
		<get_url set="method"><f a=""><c path="String"/></f></get_url>
		<set_align set="method"><f a="value">
	<x path="flash.text.TextFormatAlign"/>
	<x path="flash.text.TextFormatAlign"/>
</f></set_align>
		<set_blockIndent set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_blockIndent>
		<set_bold set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_bold>
		<set_bullet set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_bullet>
		<set_color set="method"><f a="value">
	<x path="Null"><x path="UInt"/></x>
	<x path="Null"><x path="UInt"/></x>
</f></set_color>
		<set_display set="method"><f a="value">
	<x path="flash.text.TextFormatDisplay"/>
	<x path="flash.text.TextFormatDisplay"/>
</f></set_display>
		<set_font set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<set_indent set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_indent>
		<set_italic set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_italic>
		<set_kerning set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_kerning>
		<set_leading set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_leading>
		<set_leftMargin set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_leftMargin>
		<set_letterSpacing set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_letterSpacing>
		<set_rightMargin set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_rightMargin>
		<set_size set="method"><f a="value">
	<x path="Null"><x path="Float"/></x>
	<x path="Null"><x path="Float"/></x>
</f></set_size>
		<set_tabStops set="method"><f a="value">
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><x path="UInt"/></c>
</f></set_tabStops>
		<set_target set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_target>
		<set_underline set="method"><f a="value">
	<x path="Null"><x path="Bool"/></x>
	<x path="Null"><x path="Bool"/></x>
</f></set_underline>
		<set_url set="method"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_url>
		<new public="1" set="method">
			<f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v=":0:0:false:false:false::::0:0:0:0">
				<c path="String"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="flash.text.TextFormatAlign"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ leading : 0, indent : 0, rightMargin : 0, leftMargin : 0, underline : false, italic : false, bold : false, color : 0, size : 0 }</e></m></meta>
		</new>
	</class>
	<abstract path="flash.text.TextFormatAlign" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatAlign.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
		</meta>
		<impl><class path="flash.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatAlign.hx" private="1" module="flash.text.TextFormatAlign" extern="1" final="1">
	<CENTER public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CENTER>
	<END public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<JUSTIFY public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUSTIFY>
	<LEFT public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<START public="1" set="null" static="1">
		<x path="flash.text.TextFormatAlign"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</START>
	<meta>
		<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatAlign.hx" private="1" module="flash.text.TextFormatAlign" extern="1" final="1">
		<CENTER public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CENTER>
		<END public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<JUSTIFY public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUSTIFY>
		<LEFT public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<START public="1" set="null" static="1">
			<x path="flash.text.TextFormatAlign"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</START>
		<meta>
			<m n=":native"><e>"flash.text.TextFormatAlign"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextFormatDisplay" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatDisplay.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
		</meta>
		<impl><class path="flash.text._TextFormatDisplay.TextFormatDisplay_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatDisplay.hx" private="1" module="flash.text.TextFormatDisplay" extern="1" final="1">
	<BLOCK public="1" set="null" static="1">
		<x path="flash.text.TextFormatDisplay"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BLOCK>
	<INLINE public="1" set="null" static="1">
		<x path="flash.text.TextFormatDisplay"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INLINE>
	<meta>
		<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextFormatDisplay.TextFormatDisplay_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextFormatDisplay.hx" private="1" module="flash.text.TextFormatDisplay" extern="1" final="1">
		<BLOCK public="1" set="null" static="1">
			<x path="flash.text.TextFormatDisplay"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BLOCK>
		<INLINE public="1" set="null" static="1">
			<x path="flash.text.TextFormatDisplay"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INLINE>
		<meta>
			<m n=":native"><e>"flash.text.TextFormatDisplay"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flash.text.TextInteractionMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextInteractionMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
		</meta>
		<impl><class path="flash.text._TextInteractionMode.TextInteractionMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextInteractionMode.hx" private="1" module="flash.text.TextInteractionMode" extern="1" final="1">
	<NORMAL public="1" set="null" static="1">
		<x path="flash.text.TextInteractionMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<SELECTION public="1" set="null" static="1">
		<x path="flash.text.TextInteractionMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECTION>
	<meta>
		<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.text._TextInteractionMode.TextInteractionMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextInteractionMode.hx" private="1" module="flash.text.TextInteractionMode" extern="1" final="1">
		<NORMAL public="1" set="null" static="1">
			<x path="flash.text.TextInteractionMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<SELECTION public="1" set="null" static="1">
			<x path="flash.text.TextInteractionMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECTION>
		<meta>
			<m n=":native"><e>"flash.text.TextInteractionMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" get="accessor" set="null">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method">
			<f a="?includeLineEndings" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getSelectedText>
		<getText public="1" set="method">
			<f a="beginIndex:endIndex:?includeLineEndings" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ includeLineEndings : false }</e></m></meta>
		</getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<get_charCount set="method"><f a=""><x path="Int"/></f></get_charCount>
		<hitTestTextNearPos public="1" set="method">
			<f a="x:y:?maxDistance" v="::0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ maxDistance : 0 }</e></m></meta>
		</hitTestTextNearPos>
		<setSelectColor public="1" set="method">
			<f a="?hexColor" v="16776960">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ hexColor : 16776960 }</e></m></meta>
		</setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/ContextMenu.hx" extern="1" final="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</isSupported>
		<get_isSupported set="method" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<builtInItems public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenuBuiltInItems"/>
			<meta><m n=":flash.property"/></meta>
		</builtInItems>
		<clipboardItems public="1" get="accessor" set="accessor">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</clipboardItems>
		<clipboardMenu public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</clipboardMenu>
		<customItems public="1" get="accessor" set="accessor">
			<c path="Array"><d/></c>
			<meta><m n=":flash.property"/></meta>
		</customItems>
		<link public="1" get="accessor" set="accessor">
			<c path="flash.net.URLRequest"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<get_builtInItems set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></get_builtInItems>
		<get_clipboardItems set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></get_clipboardItems>
		<get_clipboardMenu set="method"><f a=""><x path="Bool"/></f></get_clipboardMenu>
		<get_customItems set="method"><f a=""><c path="Array"><d/></c></f></get_customItems>
		<get_link set="method"><f a=""><c path="flash.net.URLRequest"/></f></get_link>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<set_builtInItems set="method"><f a="value">
	<c path="flash.ui.ContextMenuBuiltInItems"/>
	<c path="flash.ui.ContextMenuBuiltInItems"/>
</f></set_builtInItems>
		<set_clipboardItems set="method"><f a="value">
	<c path="flash.ui.ContextMenuClipboardItems"/>
	<c path="flash.ui.ContextMenuClipboardItems"/>
</f></set_clipboardItems>
		<set_clipboardMenu set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clipboardMenu>
		<set_customItems set="method"><f a="value">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></set_customItems>
		<set_link set="method"><f a="value">
	<c path="flash.net.URLRequest"/>
	<c path="flash.net.URLRequest"/>
</f></set_link>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1" final="1">
		<forwardAndBack public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</forwardAndBack>
		<loop public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</loop>
		<play public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</play>
		<print public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</print>
		<quality public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</quality>
		<rewind public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</rewind>
		<save public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</save>
		<zoom public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<get_forwardAndBack set="method"><f a=""><x path="Bool"/></f></get_forwardAndBack>
		<get_loop set="method"><f a=""><x path="Bool"/></f></get_loop>
		<get_play set="method"><f a=""><x path="Bool"/></f></get_play>
		<get_print set="method"><f a=""><x path="Bool"/></f></get_print>
		<get_quality set="method"><f a=""><x path="Bool"/></f></get_quality>
		<get_rewind set="method"><f a=""><x path="Bool"/></f></get_rewind>
		<get_save set="method"><f a=""><x path="Bool"/></f></get_save>
		<get_zoom set="method"><f a=""><x path="Bool"/></f></get_zoom>
		<set_forwardAndBack set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_forwardAndBack>
		<set_loop set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_loop>
		<set_play set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_play>
		<set_print set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_print>
		<set_quality set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_quality>
		<set_rewind set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_rewind>
		<set_save set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_save>
		<set_zoom set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_zoom>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/ContextMenuClipboardItems.hx" extern="1" final="1">
		<clear public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</clear>
		<copy public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</copy>
		<cut public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</cut>
		<paste public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</paste>
		<selectAll public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<get_clear set="method"><f a=""><x path="Bool"/></f></get_clear>
		<get_copy set="method"><f a=""><x path="Bool"/></f></get_copy>
		<get_cut set="method"><f a=""><x path="Bool"/></f></get_cut>
		<get_paste set="method"><f a=""><x path="Bool"/></f></get_paste>
		<get_selectAll set="method"><f a=""><x path="Bool"/></f></get_selectAll>
		<set_clear set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_clear>
		<set_copy set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_copy>
		<set_cut set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cut>
		<set_paste set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paste>
		<set_selectAll set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectAll>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="flash.ui.KeyLocation" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/KeyLocation.hx">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.ui.KeyLocation"</e></m>
		</meta>
		<impl><class path="flash.ui._KeyLocation.KeyLocation_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/KeyLocation.hx" private="1" module="flash.ui.KeyLocation" extern="1" final="1">
	<D_PAD public="1" set="null" static="1">
		<x path="flash.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D_PAD>
	<LEFT public="1" set="null" static="1">
		<x path="flash.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<NUM_PAD public="1" set="null" static="1">
		<x path="flash.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_PAD>
	<RIGHT public="1" set="null" static="1">
		<x path="flash.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<STANDARD public="1" set="null" static="1">
		<x path="flash.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD>
	<meta>
		<m n=":native"><e>"flash.ui.KeyLocation"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.ui._KeyLocation.KeyLocation_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/KeyLocation.hx" private="1" module="flash.ui.KeyLocation" extern="1" final="1">
		<D_PAD public="1" set="null" static="1">
			<x path="flash.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D_PAD>
		<LEFT public="1" set="null" static="1">
			<x path="flash.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<NUM_PAD public="1" set="null" static="1">
			<x path="flash.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_PAD>
		<RIGHT public="1" set="null" static="1">
			<x path="flash.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<STANDARD public="1" set="null" static="1">
			<x path="flash.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD>
		<meta>
			<m n=":native"><e>"flash.ui.KeyLocation"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.ui.Mouse" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/Mouse.hx" extern="1">
		<cursor public="1" get="accessor" set="accessor" static="1">
			<d/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10</e></m>
			</meta>
		</cursor>
		<supportsCursor public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_1</e></m>
			</meta>
		</supportsCursor>
		<supportsNativeCursor public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash10_2</e></m>
			</meta>
		</supportsNativeCursor>
		<get_cursor set="method" static="1"><f a=""><d/></f></get_cursor>
		<get_supportsCursor set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsCursor>
		<get_supportsNativeCursor set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsNativeCursor>
		<hide public="1" set="method" static="1"><f a=""><x path="Void"/></f></hide>
		<registerCursor public="1" set="method" static="1">
			<f a="name:cursor">
				<c path="String"/>
				<c path="flash.ui.MouseCursorData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</registerCursor>
		<set_cursor set="method" static="1"><f a="value">
	<d/>
	<d/>
</f></set_cursor>
		<show public="1" set="method" static="1"><f a=""><x path="Void"/></f></show>
		<unregisterCursor public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</unregisterCursor>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.ui.MouseCursor" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/MouseCursor.hx" extern="1">
		<ARROW final="1" public="1" set="null" static="1"><c path="String"/></ARROW>
		<AUTO final="1" public="1" set="null" static="1"><c path="String"/></AUTO>
		<BUTTON final="1" public="1" set="null" static="1"><c path="String"/></BUTTON>
		<HAND final="1" public="1" set="null" static="1"><c path="String"/></HAND>
		<IBEAM final="1" public="1" set="null" static="1"><c path="String"/></IBEAM>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/MouseCursorData.hx" extern="1" final="1">
		<data public="1" get="accessor" set="accessor">
			<c path="flash.Vector"><c path="flash.display.BitmapData"/></c>
			<meta><m n=":flash.property"/></meta>
		</data>
		<frameRate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":flash.property"/></meta>
		</frameRate>
		<hotSpot public="1" get="accessor" set="accessor">
			<c path="flash.geom.Point"/>
			<meta><m n=":flash.property"/></meta>
		</hotSpot>
		<get_data set="method"><f a=""><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></f></get_data>
		<get_frameRate set="method"><f a=""><x path="Float"/></f></get_frameRate>
		<get_hotSpot set="method"><f a=""><c path="flash.geom.Point"/></f></get_hotSpot>
		<set_data set="method"><f a="value">
	<c path="flash.Vector"><c path="flash.display.BitmapData"/></c>
	<c path="flash.Vector"><c path="flash.display.BitmapData"/></c>
</f></set_data>
		<set_frameRate set="method"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<set_hotSpot set="method"><f a="value">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></set_hotSpot>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.ui.Multitouch" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/Multitouch.hx" extern="1">
		<inputMode public="1" get="accessor" set="accessor" static="1">
			<x path="flash.ui.MultitouchInputMode"/>
			<meta><m n=":flash.property"/></meta>
		</inputMode>
		<mapTouchToMouse public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</mapTouchToMouse>
		<maxTouchPoints public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</maxTouchPoints>
		<supportedGestures public="1" get="accessor" set="null" static="1">
			<c path="flash.Vector"><c path="String"/></c>
			<meta><m n=":flash.property"/></meta>
		</supportedGestures>
		<supportsGestureEvents public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</supportsGestureEvents>
		<supportsTouchEvents public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</supportsTouchEvents>
		<get_inputMode set="method" static="1"><f a=""><x path="flash.ui.MultitouchInputMode"/></f></get_inputMode>
		<get_mapTouchToMouse set="method" static="1"><f a=""><x path="Bool"/></f></get_mapTouchToMouse>
		<get_maxTouchPoints set="method" static="1"><f a=""><x path="Int"/></f></get_maxTouchPoints>
		<get_supportedGestures set="method" static="1"><f a=""><c path="flash.Vector"><c path="String"/></c></f></get_supportedGestures>
		<get_supportsGestureEvents set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsGestureEvents>
		<get_supportsTouchEvents set="method" static="1"><f a=""><x path="Bool"/></f></get_supportsTouchEvents>
		<set_inputMode set="method" static="1"><f a="value">
	<x path="flash.ui.MultitouchInputMode"/>
	<x path="flash.ui.MultitouchInputMode"/>
</f></set_inputMode>
		<set_mapTouchToMouse set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_mapTouchToMouse>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<abstract path="flash.ui.MultitouchInputMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/MultitouchInputMode.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.ui.MultitouchInputMode"</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
		<impl><class path="flash.ui._MultitouchInputMode.MultitouchInputMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/MultitouchInputMode.hx" private="1" module="flash.ui.MultitouchInputMode" extern="1" final="1">
	<GESTURE public="1" set="null" static="1">
		<x path="flash.ui.MultitouchInputMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GESTURE>
	<NONE public="1" set="null" static="1">
		<x path="flash.ui.MultitouchInputMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<TOUCH_POINT public="1" set="null" static="1">
		<x path="flash.ui.MultitouchInputMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_POINT>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.ui.MultitouchInputMode"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.ui._MultitouchInputMode.MultitouchInputMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/ui/MultitouchInputMode.hx" private="1" module="flash.ui.MultitouchInputMode" extern="1" final="1">
		<GESTURE public="1" set="null" static="1">
			<x path="flash.ui.MultitouchInputMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GESTURE>
		<NONE public="1" set="null" static="1">
			<x path="flash.ui.MultitouchInputMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<TOUCH_POINT public="1" set="null" static="1">
			<x path="flash.ui.MultitouchInputMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_POINT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.ui.MultitouchInputMode"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesAvailable>
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<get_bytesAvailable set="method"><f a=""><x path="UInt"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" get="accessor" set="accessor" static="1">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</defaultObjectEncoding>
		<get_defaultObjectEncoding set="method" static="1"><f a=""><x path="UInt"/></f></get_defaultObjectEncoding>
		<set_defaultObjectEncoding set="method" static="1"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_defaultObjectEncoding>
		<bytesAvailable public="1" get="accessor" set="null">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</bytesAvailable>
		<endian public="1" get="accessor" set="accessor">
			<x path="flash.utils.Endian"/>
			<meta><m n=":flash.property"/></meta>
		</endian>
		<length public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</length>
		<objectEncoding public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</objectEncoding>
		<position public="1" get="accessor" set="accessor">
			<x path="UInt"/>
			<meta><m n=":flash.property"/></meta>
		</position>
		<shareable public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta>
				<m n=":flash.property"/>
				<m n=":require"><e>flash11_4</e></m>
			</meta>
		</shareable>
		<atomicCompareAndSwapIntAt public="1" set="method">
			<f a="byteIndex:expectedValue:newValue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapIntAt>
		<atomicCompareAndSwapLength public="1" set="method">
			<f a="expectedLength:newLength">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":require"><e>flash11_4</e></m></meta>
		</atomicCompareAndSwapLength>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<compress public="1" set="method"><f a="?algorithm">
	<x path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<get_bytesAvailable set="method"><f a=""><x path="UInt"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><x path="flash.utils.Endian"/></f></get_endian>
		<get_length set="method"><f a=""><x path="UInt"/></f></get_length>
		<get_objectEncoding set="method"><f a=""><x path="UInt"/></f></get_objectEncoding>
		<get_position set="method"><f a=""><x path="UInt"/></f></get_position>
		<get_shareable set="method"><f a=""><x path="Bool"/></f></get_shareable>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<set_endian set="method"><f a="value">
	<x path="flash.utils.Endian"/>
	<x path="flash.utils.Endian"/>
</f></set_endian>
		<set_length set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_length>
		<set_objectEncoding set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_objectEncoding>
		<set_position set="method"><f a="value">
	<x path="UInt"/>
	<x path="UInt"/>
</f></set_position>
		<set_shareable set="method"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_shareable>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a="?algorithm">
	<x path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<c path="flash.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.utils.CompressionAlgorithm" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/CompressionAlgorithm.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
		<impl><class path="flash.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/CompressionAlgorithm.hx" private="1" module="flash.utils.CompressionAlgorithm" extern="1" final="1">
	<DEFLATE public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFLATE>
	<LZMA public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LZMA>
	<ZLIB public="1" set="null" static="1">
		<x path="flash.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZLIB>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/CompressionAlgorithm.hx" private="1" module="flash.utils.CompressionAlgorithm" extern="1" final="1">
		<DEFLATE public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFLATE>
		<LZMA public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LZMA>
		<ZLIB public="1" set="null" static="1">
			<x path="flash.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZLIB>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.utils.CompressionAlgorithm"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method">
			<f a="?weakKeys" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ weakKeys : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flash.utils.Endian" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Endian.hx">
		<this><c path="String"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"flash.utils.Endian"</e></m>
		</meta>
		<impl><class path="flash.utils._Endian.Endian_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Endian.hx" private="1" module="flash.utils.Endian" extern="1" final="1">
	<BIG_ENDIAN public="1" set="null" static="1">
		<x path="flash.utils.Endian"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BIG_ENDIAN>
	<LITTLE_ENDIAN public="1" set="null" static="1">
		<x path="flash.utils.Endian"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LITTLE_ENDIAN>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":native"><e>"flash.utils.Endian"</e></m>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flash.utils._Endian.Endian_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Endian.hx" private="1" module="flash.utils.Endian" extern="1" final="1">
		<BIG_ENDIAN public="1" set="null" static="1">
			<x path="flash.utils.Endian"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" set="null" static="1">
			<x path="flash.utils.Endian"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LITTLE_ENDIAN>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"flash.utils.Endian"</e></m>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="flash.utils.Function" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Namespace.hx" extern="1" final="1">
		<prefix public="1" get="accessor" set="null">
			<d/>
			<meta><m n=":flash.property"/></meta>
		</prefix>
		<uri public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":flash.property"/></meta>
		</uri>
		<get_prefix set="method"><f a=""><d/></f></get_prefix>
		<get_uri set="method"><f a=""><c path="String"/></f></get_uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="flash.utils.Object" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/utils/Object.hx">
		<from><icast><d/></icast></from>
		<this><x path="flash.utils.Object"/></this>
		<to><icast><d/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="flash.xml.XML" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/xml/XML.hx" extern="1" final="1">
		<ignoreComments public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreComments>
		<ignoreProcessingInstructions public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreProcessingInstructions>
		<ignoreWhitespace public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</ignoreWhitespace>
		<prettyIndent public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":flash.property"/></meta>
		</prettyIndent>
		<prettyPrinting public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":flash.property"/></meta>
		</prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<get_ignoreComments set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreComments>
		<get_ignoreProcessingInstructions set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreProcessingInstructions>
		<get_ignoreWhitespace set="method" static="1"><f a=""><x path="Bool"/></f></get_ignoreWhitespace>
		<get_prettyIndent set="method" static="1"><f a=""><x path="Int"/></f></get_prettyIndent>
		<get_prettyPrinting set="method" static="1"><f a=""><x path="Bool"/></f></get_prettyPrinting>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<set_ignoreComments set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreComments>
		<set_ignoreProcessingInstructions set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreProcessingInstructions>
		<set_ignoreWhitespace set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_ignoreWhitespace>
		<set_prettyIndent set="method" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_prettyIndent>
		<set_prettyPrinting set="method" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_prettyPrinting>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.xml.XMLList" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/xml/XMLList.hx" extern="1" final="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><x path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toJSON public="1" set="method">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="haxe.CallStack" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.NativeException" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/Exception.hx" module="haxe.Exception" extern="1">
		<errorID get="accessor" set="null">
			<x path="Int"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":flash.property"/>
			</meta>
		</errorID>
		<name>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</name>
		<getStackTrace set="method">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</getStackTrace>
		<get_errorID set="method">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_errorID>
		<new set="method">
			<f a="?message:?id" v=":0">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ id : 0 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":native"><e>"flash.errors.Error"</e></m>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/Exception.hx">
		<extends path="haxe.NativeException"/>
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="28" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__nativeStack>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack>
			<x path="Int"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<c path="flash.errors.Error"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="52"><f a=""><x path="Any"/></f></unwrap>
		<get_native final="1" set="method" line="78"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="40">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":notNull"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<new public="1" get="inline" set="null" line="472"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Json" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/Json.hx" extern="1">
		<parse public="1" set="method" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" set="method" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":native"><e>"JSON"</e></m>
		</meta>
	</class>
	<class path="haxe.Log" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="37" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/NativeStackTrace.hx">
		<normalize set="method" line="53" static="1">
			<f a="stack:?skipItems" v=":0">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ skipItems : 0 }</e></m></meta>
		</normalize>
		<skipLines set="method" line="61" static="1">
			<f a="stack:skip:?pos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</skipLines>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="57" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of `Serializer` by
		setting their `useCache` field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="69" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of `Serializer` by
		setting their `useEnumIndex` field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<BASE64_CODES expr="null" line="72" static="1">
			<x path="haxe.ds.Vector"><x path="Null"><x path="Int"/></x></x>
			<meta><m n=":value"><e>null</e></m></meta>
		</BASE64_CODES>
		<run public="1" set="method" line="582" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

	This is a convenience function for creating a new instance of
	Serializer, serialize `v` into it and obtain the result through a call
	to `toString()`.</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See `USE_CACHE` for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See `USE_ENUM_INDEX` for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="118">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="154"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="174"><f a="v">
	<d/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeClassFields set="method" line="197">
			<f a="v:c">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</serializeClassFields>
		<serializeFields set="method" line="211"><f a="v">
	<a/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="229">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

	All haxe-defined values and objects with the exception of functions can
	be serialized. Serialization of external/native objects is not
	guaranteed to work.

	The values of `this.useCache` and `this.useEnumIndex` may affect
	serialization output.</haxe_doc>
		</serialize>
		<__getField get="inline" set="null" line="556"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></__getField>
		<new public="1" set="method" line="103">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each `Serializer` instance maintains its own cache if `this.useCache` is
		`true`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/std-serialization-format.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/haxe/Timer.hx">
		<delay public="1" set="method" line="144" static="1">
			<f a="f:time_ms">
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>Invokes `f` after `time_ms` milliseconds.

		This is a convenience function for creating a new Timer instance with
		`time_ms` as argument, binding its run() method to `f` and then stopping
		`this` Timer upon the first invocation.

		If `f` is null, the result is unspecified.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="166" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measures the time it takes to execute `f`, in seconds with fractions.

		This is a convenience function for calculating the difference between
		Timer.stamp() before and after the invocation of `f`.

		The difference is passed as argument to Log.trace(), with "s" appended
		to denote the unit. The optional `pos` argument is passed through.

		If `f` is null, the result is unspecified.</haxe_doc>
		</measure>
		<stamp public="1" get="inline" set="null" line="180" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<id><x path="Null"><x path="Int"/></x></id>
		<stop public="1" set="method" line="96">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Stops `this` Timer.

		After calling this method, no additional invocations of `this.run`
		will occur.

		It is not possible to restart `this` Timer once stopped.</haxe_doc>
		</stop>
		<run public="1" set="dynamic" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>This method is invoked repeatedly on `this` Timer.

		It can be overridden in a subclass, or rebound directly to a custom
		function:
			var timer = new haxe.Timer(1000); // 1000ms delay
			timer.run = function() { ... }

		Once bound, it can still be rebound to different functions until `this`
		Timer is stopped through a call to `this.stop`.</haxe_doc>
		</run>
		<new public="1" set="method" line="63">
			<f a="time_ms">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new timer that will run every `time_ms` milliseconds.

		After creating the Timer instance, it calls `this.run` repeatedly,
		with delays of `time_ms` milliseconds, until `this.stop` is called.

		The first invocation occurs after `time_ms` milliseconds, not
		immediately.

		The accuracy of this may be platform-dependent.</haxe_doc>
		</new>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="476"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="479"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<new public="1" set="method" line="474"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="65" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`.
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<CODES expr="null" line="70" static="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</CODES>
		<initCodes set="method" line="72" static="1"><f a=""><c path="flash.utils.ByteArray"/></f></initCodes>
		<run public="1" set="method" line="464" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserializes `v` and returns the according value.

		This is a convenience function for creating a new instance of
		Unserializer with `v` as buffer and calling its `unserialize()` method
		once.</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<readDigits set="method" line="144"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="169"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="184"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum params="T" set="method" line="199"><f a="edecl:tag">
	<x path="Enum"><c path="unserializeEnum.T"/></x>
	<c path="String"/>
	<c path="unserializeEnum.T"/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="231">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ValueException" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Adler32" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/crypto/Adler32.hx">
		<read public="1" set="method" line="60" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<c path="haxe.crypto.Adler32"/>
</f></read>
		<a1><x path="Int"/></a1>
		<a2><x path="Int"/></a2>
		<update public="1" set="method" line="41"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<equals public="1" set="method" line="52"><f a="a">
	<c path="haxe.crypto.Adler32"/>
	<x path="Bool"/>
</f></equals>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Adler32 of the given Bytes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="505" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="535" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns bytes representation of the given String, using specific encoding (UTF-8 by default)</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="597" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<ofHex public="1" set="method" line="614" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Convert hexadecimal string to Bytes.
		Support only straight hex string ( Example: "0FDA14058916052309" )</haxe_doc>
		</ofHex>
		<fastGet public="1" get="inline" set="null" line="635" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read the most efficiently possible the n-th byte of the data.
		Behavior when reading outside of the available data is unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="52"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="69"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method" line="88"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method" line="127"><f a="pos:len:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<sub public="1" set="method" line="147"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="175"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<getDouble public="1" get="inline" set="null" line="226">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getDouble>
		<getFloat public="1" get="inline" set="null" line="248">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setDouble public="1" get="inline" set="null" line="270">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE double precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" get="inline" set="null" line="296">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getUInt16 public="1" get="inline" set="null" line="318">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</getUInt16>
		<setUInt16 public="1" get="inline" set="null" line="330">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 16 bit unsigned integer at given position (in low endian encoding).</haxe_doc>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="343">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt32>
		<getInt64 public="1" get="inline" set="null" line="361">
			<f a="pos">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</getInt64>
		<setInt32 public="1" get="inline" set="null" line="369">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 32 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt32>
		<setInt64 public="1" get="inline" set="null" line="384">
			<f a="pos:v">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Store the 64 bit integer at given position (in low endian encoding).</haxe_doc>
		</setInt64>
		<getString public="1" set="method" line="390"><f a="pos:len:?encoding">
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.io.Encoding"/>
	<c path="String"/>
</f></getString>
		<readString public="1" get="inline" set="null" line="455">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"readString is deprecated, use getString instead"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</readString>
		<toString public="1" set="method" line="463">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns string representation of the bytes as UTF8</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="484"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="500"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="43"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedBytes()</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="haxe.crypto.Base64" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/crypto/Base64.hx">
		<CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</CHARS>
		<BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(CHARS)" line="30" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(CHARS)</e></m></meta>
		</BYTES>
		<decode public="1" set="method" line="48" static="1">
			<f a="str:?complement" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</decode>
		<haxe_doc>Allows one to encode/decode String and bytes using Base64 encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/crypto/BaseCode.hx">
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows one to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.crypto.Sha1" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/crypto/Sha1.hx">
		<encode public="1" set="method" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<str2blks set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>Convert a string to a sequence of 16-word blocks, stored as an array.
		Append padding bits and the length, as described in the SHA1 standard.</haxe_doc>
		</str2blks>
		<doEncode set="method" line="50"><f a="x">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
</f></doEncode>
		<ft set="method" line="142">
			<f a="t:b:c:d">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Perform the appropriate triplet combination function for the current iteration</haxe_doc>
		</ft>
		<kt set="method" line="155">
			<f a="t">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Determine the appropriate additive constant for the current iteration</haxe_doc>
		</kt>
		<hex set="method" line="165"><f a="a">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
</f></hex>
		<new set="method" line="48"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Creates a Sha1 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="263"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="51">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapKeysIterator" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap">
		<h><c path="flash.utils.Dictionary"/></h>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="104">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="111">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="98"><f a="h">
	<c path="flash.utils.Dictionary"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._IntMap.IntMapValuesIterator" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/IntMap.hx" private="1" module="haxe.ds.IntMap">
		<h><c path="flash.utils.Dictionary"/></h>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="130">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="137">
			<f a=""><c path="haxe.ds._IntMap.IntMapValuesIterator.T"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="124"><f a="h">
	<c path="flash.utils.Dictionary"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.IntMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="99">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<clear public="1" set="method" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="137">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/ObjectMap.hx">
		<extends path="flash.utils.Dictionary"/>
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<get public="1" get="inline" set="null" line="31">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="35">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<exists public="1" get="inline" set="null" line="39">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="49">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._ObjectMap.NativePropertyIterator" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/ObjectMap.hx" private="1" module="haxe.ds.ObjectMap">
		<collection><d/></collection>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<hasNext public="1" get="inline" set="null" line="97">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="106">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new set="method" line="95"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<reserved expr="{ }" line="29" static="1">
			<a/>
			<meta><m n=":value"><e>{ }</e></m></meta>
		</reserved>
		<h><d/></h>
		<rh><d/></rh>
		<set public="1" get="inline" set="null" line="39">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="46">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="52">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<setReserved set="method" line="58">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setReserved>
		<getReserved set="method" line="64">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getReserved>
		<existsReserved set="method" line="68">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</existsReserved>
		<remove public="1" set="method" line="74">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="89">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<new public="1" set="method" line="31">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapKeysIterator" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h><d/></h>
		<rh><d/></rh>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<isReserved><x path="Bool"/></isReserved>
		<hasNext public="1" get="inline" set="null" line="147">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="161">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="139"><f a="h:rh">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<class path="haxe.ds._StringMap.StringMapValuesIterator" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/flash/_std/haxe/ds/StringMap.hx" private="1" module="haxe.ds.StringMap">
		<h><d/></h>
		<rh><d/></rh>
		<index><x path="Int"/></index>
		<nextIndex><x path="Int"/></nextIndex>
		<hasNext public="1" get="inline" set="null" line="184">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":has_untyped"/></meta>
		</hasNext>
		<next public="1" get="inline" set="null" line="197">
			<f a=""><c path="haxe.ds._StringMap.StringMapValuesIterator.T"/></f>
			<meta><m n=":has_untyped"/></meta>
		</next>
		<new get="inline" set="null" line="177"><f a="h:rh">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>haxe.ds.StringMap</e></m>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="flash.Vector"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc><![CDATA[A special abstract type that represents "rest" function argument.

	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.BytesBuffer" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/BytesBuffer.hx">
		<b><c path="flash.utils.ByteArray"/></b>
		<getBytes public="1" set="method" line="201">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="haxe.io.Input" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/Input.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<readByte public="1" set="method" line="96" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="119" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<readInt16 public="1" set="method" line="198" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readInt16>
		<readUInt16 public="1" set="method" line="203" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readUInt16>
		<readInt32 public="1" set="method" line="208" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readInt32>
		<readString public="1" set="method" line="213" override="1">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</readString>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.Path" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/io/Path.hx">
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="161" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

		If `path` has no extension, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</extension>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.MapKeyValueIterator" params="K:V" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/iterators/MapKeyValueIterator.hx">
		<map><c path="haxe.IMap">
	<c path="haxe.iterators.MapKeyValueIterator.K"/>
	<c path="haxe.iterators.MapKeyValueIterator.V"/>
</c></map>
		<keys><t path="Iterator"><c path="haxe.iterators.MapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="50">
			<f a=""><a>
	<value><c path="haxe.iterators.MapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.MapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35"><f a="map">
	<c path="haxe.IMap">
		<c path="haxe.iterators.MapKeyValueIterator.K"/>
		<c path="haxe.iterators.MapKeyValueIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate across maps.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<abstract path="haxe.macro.IncludePosition" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.macro.NullSafetyMode" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.NullSafetyMode_Impl_" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<typedef path="haxe.macro.Position" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<enum path="haxe.zip.ExtraField" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/Entry.hx" module="haxe.zip.Entry">
		<FUnknown a="tag:bytes">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</FUnknown>
		<FInfoZipUnicodePath a="name:crc">
			<c path="String"/>
			<x path="Int"/>
		</FInfoZipUnicodePath>
		<FUtf8/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<typedef path="haxe.zip.Entry" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/Entry.hx"><a>
	<fileTime><c path="Date"/></fileTime>
	<fileSize><x path="Int"/></fileSize>
	<fileName><c path="String"/></fileName>
	<extraFields>
		<x path="Null"><c path="haxe.ds.List"><e path="haxe.zip.ExtraField"/></c></x>
		<meta><m n=":optional"/></meta>
	</extraFields>
	<dataSize><x path="Int"/></dataSize>
	<data><x path="Null"><c path="haxe.io.Bytes"/></x></data>
	<crc32><x path="Null"><x path="Int"/></x></crc32>
	<compressed><x path="Bool"/></compressed>
</a></typedef>
	<enum path="haxe.zip.Huffman" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/Huffman.hx">
		<Found a="i"><x path="Int"/></Found>
		<NeedBit a="left:right">
			<e path="haxe.zip.Huffman"/>
			<e path="haxe.zip.Huffman"/>
		</NeedBit>
		<NeedBits a="n:table">
			<x path="Int"/>
			<c path="Array"><e path="haxe.zip.Huffman"/></c>
		</NeedBits>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.zip.HuffTools" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/Huffman.hx" module="haxe.zip.Huffman">
		<treeDepth set="method" line="34"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></treeDepth>
		<treeCompress set="method" line="45"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<e path="haxe.zip.Huffman"/>
</f></treeCompress>
		<treeWalk set="method" line="62"><f a="table:p:cd:d:t">
	<c path="Array"><e path="haxe.zip.Huffman"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
	<x path="Void"/>
</f></treeWalk>
		<treeMake set="method" line="75"><f a="bits:maxbits:v:len">
	<c path="haxe.ds.IntMap"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></treeMake>
		<make public="1" set="method" line="86"><f a="lengths:pos:nlengths:maxbits">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></make>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip._InflateImpl.Window" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<buffer public="1"><c path="haxe.io.Bytes"/></buffer>
		<pos public="1"><x path="Int"/></pos>
		<crc><c path="haxe.crypto.Adler32"/></crc>
		<slide public="1" set="method" line="44"><f a=""><x path="Void"/></f></slide>
		<addBytes public="1" set="method" line="53"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte public="1" set="method" line="60"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<getLastChar public="1" set="method" line="67"><f a=""><x path="Int"/></f></getLastChar>
		<available public="1" set="method" line="71"><f a=""><x path="Int"/></f></available>
		<checksum public="1" set="method" line="75"><f a=""><c path="haxe.crypto.Adler32"/></f></checksum>
		<new public="1" set="method" line="37"><f a="hasCrc">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.zip._InflateImpl.State" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<Head/>
		<Block/>
		<CData/>
		<Flat/>
		<Crc/>
		<Dist/>
		<DistOne/>
		<Done/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.InflateImpl" params="" file="/opt/hostedtoolcache/haxe/4.1.5/x64/std/haxe/zip/InflateImpl.hx">
		<LEN_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]" line="97" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]</e></m></meta>
		</LEN_EXTRA_BITS_TBL>
		<LEN_BASE_VAL_TBL expr="[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]" line="100" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]</e></m></meta>
		</LEN_BASE_VAL_TBL>
		<DIST_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]" line="103" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]</e></m></meta>
		</DIST_EXTRA_BITS_TBL>
		<DIST_BASE_VAL_TBL expr="[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]" line="106" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]</e></m></meta>
		</DIST_BASE_VAL_TBL>
		<CODE_LENGTHS_POS expr="[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]" line="109" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]</e></m></meta>
		</CODE_LENGTHS_POS>
		<FIXED_HUFFMAN expr="null" line="127" static="1">
			<e path="haxe.zip.Huffman"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</FIXED_HUFFMAN>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<state><e path="haxe.zip._InflateImpl.State"/></state>
		<isFinal><x path="Bool"/></isFinal>
		<huffman><e path="haxe.zip.Huffman"/></huffman>
		<huffdist><x path="Null"><e path="haxe.zip.Huffman"/></x></huffdist>
		<htools><c path="haxe.zip.HuffTools"/></htools>
		<len><x path="Int"/></len>
		<dist><x path="Int"/></dist>
		<needed><x path="Int"/></needed>
		<output><c path="haxe.io.Bytes"/></output>
		<outpos><x path="Int"/></outpos>
		<input><c path="haxe.io.Input"/></input>
		<lengths><c path="Array"><x path="Int"/></c></lengths>
		<window><c path="haxe.zip._InflateImpl.Window"/></window>
		<buildFixedHuffman set="method" line="149"><f a=""><e path="haxe.zip.Huffman"/></f></buildFixedHuffman>
		<readBytes public="1" set="method" line="159"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<getBits set="method" line="168"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<getBit set="method" line="179"><f a=""><x path="Bool"/></f></getBit>
		<getRevBits set="method" line="190"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getRevBits>
		<resetBits set="method" line="199"><f a=""><x path="Void"/></f></resetBits>
		<addBytes set="method" line="204"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte set="method" line="211"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<addDistOne set="method" line="218"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></addDistOne>
		<addDist set="method" line="224"><f a="d:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addDist>
		<applyHuffman set="method" line="228"><f a="h">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></applyHuffman>
		<inflateLengths set="method" line="236"><f a="a:max">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></inflateLengths>
		<inflateLoop set="method" line="268"><f a=""><x path="Bool"/></f></inflateLoop>
		<new public="1" set="method" line="129">
			<f a="i:?header:?crc" v=":true:true">
				<c path="haxe.io.Input"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ crc : true, header : true }</e></m></meta>
		</new>
		<haxe_doc>A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Reader" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/haxe/zip/Reader.hx">
		<readZip public="1" set="method" line="192" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<t path="List"><t path="haxe.zip.Entry"/></t>
</f></readZip>
		<unzip public="1" set="method" line="198" static="1"><f a="f">
	<t path="haxe.zip.Entry"/>
	<x path="Null"><c path="haxe.io.Bytes"/></x>
</f></unzip>
		<i><c path="haxe.io.Input"/></i>
		<readZipDate set="method" line="37"><f a=""><c path="Date"/></f></readZipDate>
		<readExtraFields set="method" line="50"><f a="length">
	<x path="Int"/>
	<c path="haxe.ds.List"><e path="haxe.zip.ExtraField"/></c>
</f></readExtraFields>
		<readEntryHeader public="1" set="method" line="84"><f a=""><t path="haxe.zip.Entry"/></f></readEntryHeader>
		<read public="1" set="method" line="121"><f a=""><t path="List"><t path="haxe.zip.Entry"/></t></f></read>
		<new public="1" set="method" line="32"><f a="i">
	<c path="haxe.io.Input"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime._internal.backend.flash.FlashApplication" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/flash/FlashApplication.hx">
		<createFirstWindow static="1"><x path="Bool"/></createFirstWindow>
		<parent><c path="lime.app.Application"/></parent>
		<requestedWindow><x path="Bool"/></requestedWindow>
		<exec public="1" set="method" line="29"><f a=""><x path="Int"/></f></exec>
		<exit public="1" set="method" line="36"><f a=""><x path="Void"/></f></exit>
		<new public="1" set="method" line="17"><f a="parent">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.app.Application</e></m>
		</meta>
	</class>
	<class path="lime._internal.backend.flash.FlashAudioSource" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/flash/FlashAudioSource.hx">
		<channel><c path="flash.media.SoundChannel"/></channel>
		<completed><x path="Bool"/></completed>
		<length><x path="Null"><x path="Int"/></x></length>
		<loops><x path="Int"/></loops>
		<parent><c path="lime.media.AudioSource"/></parent>
		<pauseTime><x path="Int"/></pauseTime>
		<playing><x path="Bool"/></playing>
		<position><c path="lime.math.Vector4"/></position>
		<dispose public="1" set="method" line="26"><f a=""><x path="Void"/></f></dispose>
		<init public="1" set="method" line="28"><f a=""><x path="Void"/></f></init>
		<play public="1" set="method" line="30"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="36"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="45"><f a=""><x path="Void"/></f></stop>
		<getCurrentTime public="1" set="method" line="56"><f a=""><x path="Int"/></f></getCurrentTime>
		<setCurrentTime public="1" set="method" line="68"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setCurrentTime>
		<getGain public="1" set="method" line="82"><f a=""><x path="Float"/></f></getGain>
		<setGain public="1" set="method" line="87"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></setGain>
		<getLength public="1" set="method" line="95"><f a=""><x path="Int"/></f></getLength>
		<setLength public="1" set="method" line="105"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setLength>
		<getLoops public="1" set="method" line="110"><f a=""><x path="Int"/></f></getLoops>
		<setLoops public="1" set="method" line="115"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></setLoops>
		<getPosition public="1" set="method" line="120"><f a=""><c path="lime.math.Vector4"/></f></getPosition>
		<setPosition public="1" set="method" line="127"><f a="value">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></setPosition>
		<new public="1" set="method" line="19"><f a="parent">
	<c path="lime.media.AudioSource"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.media.AudioBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.backend.flash.FlashWindow" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/flash/FlashWindow.hx">
		<windowID expr="0" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</windowID>
		<cacheMouseX><x path="Float"/></cacheMouseX>
		<cacheMouseY><x path="Float"/></cacheMouseY>
		<cacheTime><x path="Int"/></cacheTime>
		<currentTouches expr="new Map&lt;Int,Touch&gt;()">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Touch"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Touch>()]]></e></m></meta>
		</currentTouches>
		<cursor><e path="lime.ui.MouseCursor"/></cursor>
		<frameRate><x path="Float"/></frameRate>
		<mouseLeft><x path="Bool"/></mouseLeft>
		<parent><c path="lime.ui.Window"/></parent>
		<textInputEnabled><x path="Bool"/></textInputEnabled>
		<unusedTouchesPool expr="new List&lt;Touch&gt;()">
			<c path="haxe.ds.List"><c path="lime.ui.Touch"/></c>
			<meta><m n=":value"><e><![CDATA[new List<Touch>()]]></e></m></meta>
		</unusedTouchesPool>
		<alert public="1" set="method" line="63"><f a="message:title">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></alert>
		<close public="1" set="method" line="65"><f a=""><x path="Void"/></f></close>
		<convertKeyCode set="method" line="70"><f a="keyCode">
	<x path="Int"/>
	<x path="lime.ui.KeyCode"/>
</f></convertKeyCode>
		<create set="method" line="198"><f a=""><x path="Void"/></f></create>
		<focus public="1" set="method" line="290"><f a=""><x path="Void"/></f></focus>
		<getCursor public="1" set="method" line="292"><f a=""><e path="lime.ui.MouseCursor"/></f></getCursor>
		<getDisplay public="1" set="method" line="297"><f a=""><c path="lime.system.Display"/></f></getDisplay>
		<getDisplayMode public="1" set="method" line="302"><f a=""><c path="lime.system.DisplayMode"/></f></getDisplayMode>
		<handleApplicationEvent set="method" line="307"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></handleApplicationEvent>
		<handleKeyEvent set="method" line="317"><f a="event">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></handleKeyEvent>
		<handleMouseEvent set="method" line="337"><f a="event">
	<c path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></handleMouseEvent>
		<handleTouchEvent set="method" line="377"><f a="event">
	<c path="flash.events.TouchEvent"/>
	<x path="Void"/>
</f></handleTouchEvent>
		<handleWindowEvent set="method" line="460"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></handleWindowEvent>
		<readPixels public="1" set="method" line="490"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.graphics.Image"/>
</f></readPixels>
		<setCursor public="1" set="method" line="521"><f a="value">
	<e path="lime.ui.MouseCursor"/>
	<e path="lime.ui.MouseCursor"/>
</f></setCursor>
		<setDisplayMode public="1" set="method" line="559"><f a="value">
	<c path="lime.system.DisplayMode"/>
	<c path="lime.system.DisplayMode"/>
</f></setDisplayMode>
		<getFrameRate public="1" set="method" line="564"><f a=""><x path="Float"/></f></getFrameRate>
		<getMouseLock public="1" set="method" line="569"><f a=""><x path="Bool"/></f></getMouseLock>
		<getTextInputEnabled public="1" set="method" line="574"><f a=""><x path="Bool"/></f></getTextInputEnabled>
		<move public="1" set="method" line="579"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<resize public="1" set="method" line="581"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setBorderless public="1" set="method" line="583"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBorderless>
		<setFrameRate public="1" set="method" line="588"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></setFrameRate>
		<setFullscreen public="1" set="method" line="595"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setFullscreen>
		<setIcon public="1" set="method" line="601"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<setMaximized public="1" set="method" line="603"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMaximized>
		<setMinimized public="1" set="method" line="608"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMinimized>
		<setMouseLock public="1" set="method" line="613"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setMouseLock>
		<setResizable public="1" set="method" line="615"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setResizable>
		<setTextInputEnabled public="1" set="method" line="620"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setTextInputEnabled>
		<setTitle public="1" set="method" line="625"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setTitle>
		<warpMouse public="1" set="method" line="630"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></warpMouse>
		<new public="1" set="method" line="52"><f a="parent">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime._internal.backend.flash.FlashApplication</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.graphics.RenderContext</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<typedef path="lime._internal.backend.native.Float32" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><x path="Float"/></typedef>
	<typedef path="lime._internal.backend.native.CFFI" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><d/></typedef>
	<typedef path="lime._internal.backend.native.CFFIPointer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/native/NativeCFFI.hx" module="lime._internal.backend.native.NativeCFFI"><d/></typedef>
	<class path="lime._internal.backend.native.NativeCFFI" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/backend/native/NativeCFFI.hx"><meta>
	<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
	<m n=":noDebug"/>
</meta></class>
	<class path="lime._internal.format.BMP" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/BMP.hx">
		<encode public="1" set="method" line="13" static="1">
			<f a="image:?type" v=":null">
				<c path="lime.graphics.Image"/>
				<e path="lime._internal.format.BMPType"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime._internal.format.BMPType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/BMP.hx" module="lime._internal.format.BMP">
		<RGB/>
		<BITFIELD/>
		<ICO/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime._internal.format.Base64" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/Base64.hx">
		<DICTIONARY expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.split(&quot;&quot;)" line="8" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("")</e></m></meta>
		</DICTIONARY>
		<EXTENDED_DICTIONARY expr="{
	var result = new Array&lt;String&gt;();
	for (a  in  DICTIONARY) {
		for (b  in  DICTIONARY) {
			result.push(a + b);
		};
	};
	result;
}" line="10" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var result = new Array<String>();
	for (a  in  DICTIONARY) {
		for (b  in  DICTIONARY) {
			result.push(a + b);
		};
	};
	result;
}]]></e></m></meta>
		</EXTENDED_DICTIONARY>
		<decode public="1" set="method" line="22" static="1"><f a="source">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></decode>
		<encode public="1" set="method" line="27" static="1"><f a="source">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></encode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime._internal.format.Deflate" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/Deflate.hx">
		<compress public="1" set="method" line="16" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="46" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.GZip" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/GZip.hx">
		<compress public="1" set="method" line="13" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="35" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.JPEG" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/JPEG.hx">
		<decodeBytes public="1" set="method" line="29" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="54" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="79" static="1"><f a="image:quality">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.LZMA" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/LZMA.hx">
		<compress public="1" set="method" line="17" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="40" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.PNG" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/PNG.hx">
		<decodeBytes public="1" set="method" line="29" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="54" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="79" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.format.Zlib" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/format/Zlib.hx">
		<compress public="1" set="method" line="16" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></compress>
		<decompress public="1" set="method" line="46" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decompress>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics.ImageCanvasUtil" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageCanvasUtil.hx">
		<colorTransform public="1" set="method" line="22" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<convertToCanvas public="1" set="method" line="29" static="1">
			<f a="image:?clear" v=":false">
				<c path="lime.graphics.Image"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clear : false }</e></m></meta>
		</convertToCanvas>
		<convertToData public="1" set="method" line="78" static="1">
			<f a="image:?clear" v=":false">
				<c path="lime.graphics.Image"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clear : false }</e></m></meta>
		</convertToData>
		<copyChannel public="1" set="method" line="118" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="127" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<createCanvas public="1" set="method" line="179" static="1"><f a="image:width:height">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createCanvas>
		<createImageData public="1" set="method" line="203" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></createImageData>
		<fillRect public="1" set="method" line="225" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="270" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="277" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="284" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="291" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="298" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<resize public="1" set="method" line="307" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<scroll public="1" set="method" line="332" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method" line="347" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="354" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="361" static="1"><f a="image:rect:bytePointer:format:endian">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.utils.BytePointer"/>
	<x path="lime.graphics.PixelFormat"/>
	<e path="lime.system.Endian"/>
	<x path="Void"/>
</f></setPixels>
		<sync public="1" set="method" line="368" static="1"><f a="image:clear">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sync>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics.ImageDataUtil" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageDataUtil.hx">
		<displaceMap public="1" set="method" line="32" static="1"><f a="target:source:map:mapPoint:componentX:componentY:smooth">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></displaceMap>
		<bilinear set="method" line="137" static="1"><f a="s1:s2:s3:s4:su:sv">
	<x path="lime.math.RGBA"/>
	<x path="lime.math.RGBA"/>
	<x path="lime.math.RGBA"/>
	<x path="lime.math.RGBA"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.RGBA"/>
</f></bilinear>
		<lerpRGBA set="method" line="142" static="1"><f a="v0:v1:x">
	<x path="lime.math.RGBA"/>
	<x path="lime.math.RGBA"/>
	<x path="Float"/>
	<x path="lime.math.RGBA"/>
</f></lerpRGBA>
		<lerp4f set="method" line="153" static="1"><f a="v0:v1:x">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
	<c path="lime.math.Vector4"/>
</f></lerp4f>
		<lerp set="method" line="158" static="1"><f a="v0:v1:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></lerp>
		<colorTransform public="1" set="method" line="163" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="204" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="293" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<fillRect public="1" set="method" line="506" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="556" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<gaussianBlur public="1" set="method" line="639" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?blurX:?blurY:?quality:?strength:?color" v="::::4:4:1:1:null">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ color : null, strength : 1, quality : 1, blurY : 4, blurX : 4 }</e></m></meta>
		</gaussianBlur>
		<getColorBoundsRect public="1" set="method" line="666" static="1"><f a="image:mask:color:findColor:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="lime.math.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method" line="810" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="829" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="847" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="899" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<multiplyAlpha public="1" set="method" line="949" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></multiplyAlpha>
		<resize public="1" set="method" line="975" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<resizeBuffer public="1" set="method" line="1064" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeBuffer>
		<setFormat public="1" set="method" line="1100" static="1"><f a="image:format">
	<c path="lime.graphics.Image"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setFormat>
		<setPixel public="1" set="method" line="1178" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="1206" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="1228" static="1"><f a="image:rect:bytePointer:format:endian">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.utils.BytePointer"/>
	<x path="lime.graphics.PixelFormat"/>
	<e path="lime.system.Endian"/>
	<x path="Void"/>
</f></setPixels>
		<threshold public="1" set="method" line="1285" static="1"><f a="image:sourceImage:sourceRect:destPoint:operation:threshold:color:mask:copySource:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></threshold>
		<unmultiplyAlpha public="1" set="method" line="1399" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></unmultiplyAlpha>
		<__boxBlur set="method" line="1425" static="1"><f a="imgA:imgB:w:h:bx:by">
	<x path="lime.utils.UInt8Array"/>
	<x path="lime.utils.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__boxBlur>
		<__boxBlurH set="method" line="1445" static="1"><f a="imgA:imgB:w:h:r:off">
	<x path="lime.utils.UInt8Array"/>
	<x path="lime.utils.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__boxBlurH>
		<__boxBlurT get="inline" set="null" line="1492" static="1"><f a="imgA:imgB:w:h:r:off">
	<x path="lime.utils.UInt8Array"/>
	<x path="lime.utils.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__boxBlurT>
		<__calculateSourceOffset set="method" line="1544" static="1">
			<f a="sourceRect:destPoint:destX:destY">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns: the offset for translated coordinate in the source image or -1 if the source the coordinate out of the source or destination bounds
	 * Note: destX and destY should be valid coordinates</haxe_doc>
		</__calculateSourceOffset>
		<__getBoxesForGaussianBlur set="method" line="1563" static="1"><f a="sigma:n">
	<x path="Float"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></__getBoxesForGaussianBlur>
		<__pixelCompare get="inline" set="null" line="1582" static="1"><f a="n1:n2">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></__pixelCompare>
		<__translatePixel set="method" line="1630" static="1"><f a="imgB:sourceRect:destRect:destPoint:destX:destY:strength">
	<x path="lime.utils.UInt8Array"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translatePixel>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":access"><e>lime.math.RGBA</e></m>
		</meta>
	</class>
	<class path="lime._internal.graphics._ImageDataUtil.ImageDataView" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil">
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<height public="1" set="null"><x path="Int"/></height>
		<width public="1" set="null"><x path="Int"/></width>
		<byteOffset><x path="Int"/></byteOffset>
		<image><c path="lime.graphics.Image"/></image>
		<rect><c path="lime.math.Rectangle"/></rect>
		<stride><x path="Int"/></stride>
		<tempRect><c path="lime.math.Rectangle"/></tempRect>
		<clip public="1" set="method" line="1689"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clip>
		<hasRow public="1" get="inline" set="null" line="1698"><f a="y">
	<x path="Int"/>
	<x path="Bool"/>
</f></hasRow>
		<offset public="1" set="method" line="1703"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></offset>
		<row public="1" get="inline" set="null" line="1730"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></row>
		<__update set="method" line="1735"><f a=""><x path="Void"/></f></__update>
		<new public="1" set="method" line="1665">
			<f a="image:?rect" v=":null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._internal.graphics._ImageDataUtil.ThresholdOperation" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime._internal.graphics._ImageDataUtil.ThresholdOperation_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil" extern="1" final="1">
	<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1747" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NOT_EQUALS>
	<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1748" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1749" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1750" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN_OR_EQUAL_TO>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1751" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1752" static="1">
		<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN_OR_EQUAL_TO>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime._internal.graphics._ImageDataUtil.ThresholdOperation_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/ImageDataUtil.hx" private="1" module="lime._internal.graphics.ImageDataUtil" extern="1" final="1">
		<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1747" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NOT_EQUALS>
		<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1748" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1749" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1750" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN_OR_EQUAL_TO>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1751" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1752" static="1">
			<x path="lime._internal.graphics._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN_OR_EQUAL_TO>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime._internal.graphics.StackBlur" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/StackBlur.hx">
		<MUL_TABLE expr="[1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1]" line="10" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1]</e></m></meta>
		</MUL_TABLE>
		<SHG_TABLE expr="[0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9]" line="21" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9]</e></m></meta>
		</SHG_TABLE>
		<blur public="1" set="method" line="31" static="1"><f a="dest:source:sourceRect:destPoint:blurX:blurY:quality">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blur>
		<__stackBlurCanvasRGBA set="method" line="37" static="1"><f a="image:width:height:blurX:blurY:quality">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__stackBlurCanvasRGBA>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime._internal.graphics.BlurStack" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/graphics/StackBlur.hx" module="lime._internal.graphics.StackBlur">
		<r public="1"><x path="Int"/></r>
		<g public="1"><x path="Int"/></g>
		<b public="1"><x path="Int"/></b>
		<a public="1"><x path="Int"/></a>
		<n public="1"><c path="lime._internal.graphics.BlurStack"/></n>
		<new public="1" set="method" line="247"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime._internal.macros.AssetsMacro" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/_internal/macros/AssetsMacro.hx"><cacheVersion public="1" set="method" static="1"><f a=""><d/></f></cacheVersion></class>
	<class path="lime.app.IModule" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/IModule.hx" interface="1">
		<__registerLimeModule set="method">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>show</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__registerLimeModule>
		<__unregisterLimeModule set="method">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":dox"><e>show</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__unregisterLimeModule>
	</class>
	<class path="lime.app.Module" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Module.hx">
		<implements path="lime.app.IModule"/>
		<onExit public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>Exit events are dispatched when the application is exiting</haxe_doc>
		</onExit>
		<__registerLimeModule set="method" line="27">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerLimeModule>
		<__unregisterLimeModule set="method" line="29">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__unregisterLimeModule>
		<new public="1" set="method" line="25">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new `Module` instance</haxe_doc>
		</new>
		<haxe_doc>`Module` instances can be added to a running `Application`,
	simplifying support for adding new components, such as a renderer,
	input handler or higher-level framework.</haxe_doc>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app.Application" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Application.hx">
		<extends path="lime.app.Module"/>
		<current public="1" set="null" static="1">
			<c path="lime.app.Application"/>
			<haxe_doc>The current Application instance that is executing</haxe_doc>
		</current>
		<meta public="1">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<haxe_doc>Meta-data values for the application, such as a version or a package name</haxe_doc>
		</meta>
		<modules public="1" set="null">
			<c path="Array"><c path="lime.app.IModule"/></c>
			<haxe_doc>A list of currently attached Module instances</haxe_doc>
		</modules>
		<onUpdate public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>Update events are dispatched each frame (usually just before rendering)</haxe_doc>
		</onUpdate>
		<onCreateWindow public="1" expr="new Event&lt;Window&gt;()">
			<c path="lime.app._Event_lime_ui_Window_Void"><f a="">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Window>()]]></e></m></meta>
			<haxe_doc>Dispatched when a new window has been created by this application</haxe_doc>
		</onCreateWindow>
		<preloader public="1" get="accessor" set="null">
			<c path="lime.utils.Preloader"/>
			<haxe_doc>The Preloader for the current Application</haxe_doc>
		</preloader>
		<window public="1" get="accessor" set="null">
			<c path="lime.ui.Window"/>
			<haxe_doc>The Window associated with this Application, or the first Window
		if there are multiple Windows active</haxe_doc>
		</window>
		<windows public="1" get="accessor" set="null">
			<c path="Array"><c path="lime.ui.Window"/></c>
			<haxe_doc>A list of active Window instances associated with this Application</haxe_doc>
		</windows>
		<__backend>
			<t path="lime.app._Application.ApplicationBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<__preloader>
			<c path="lime.utils.Preloader"/>
			<meta><m n=":noCompletion"/></meta>
		</__preloader>
		<__window>
			<c path="lime.ui.Window"/>
			<meta><m n=":noCompletion"/></meta>
		</__window>
		<__windowByID>
			<t path="Map">
				<x path="Int"/>
				<c path="lime.ui.Window"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__windowByID>
		<__windows>
			<c path="Array"><c path="lime.ui.Window"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__windows>
		<addModule public="1" set="method" line="123">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a new module to the Application
		@param	module	A module to add</haxe_doc>
		</addModule>
		<createWindow public="1" set="method" line="133">
			<f a="attributes">
				<t path="lime.ui.WindowAttributes"/>
				<c path="lime.ui.Window"/>
			</f>
			<haxe_doc>Creates a new Window and adds it to the Application
		@param	attributes	A set of parameters to initialize the window</haxe_doc>
		</createWindow>
		<exec public="1" set="method" line="146">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Execute the Application. On native platforms, this method
		blocks until the application is finished running. On other
		platforms, it will return immediately
		@return	An exit code, 0 if there was no error</haxe_doc>
		</exec>
		<onGamepadAxisMove public="1" set="method" line="159">
			<f a="gamepad:axis:value">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad axis move event is fired
		@param	gamepad	The current gamepad
		@param	axis	The axis that was moved
		@param	value	The axis value (between 0 and 1)</haxe_doc>
		</onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method" line="166">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad button down event is fired
		@param	gamepad	The current gamepad
		@param	button	The button that was pressed</haxe_doc>
		</onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method" line="173">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad button up event is fired
		@param	gamepad	The current gamepad
		@param	button	The button that was released</haxe_doc>
		</onGamepadButtonUp>
		<onGamepadConnect public="1" set="method" line="179">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad is connected
		@param	gamepad	The gamepad that was connected</haxe_doc>
		</onGamepadConnect>
		<onGamepadDisconnect public="1" set="method" line="185">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a gamepad is disconnected
		@param	gamepad	The gamepad that was disconnected</haxe_doc>
		</onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method" line="193">
			<f a="joystick:axis:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick axis move event is fired
		@param	joystick	The current joystick
		@param	axis	The axis that was moved
		@param	value	The axis value (between 0 and 1)</haxe_doc>
		</onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method" line="200">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick button down event is fired
		@param	joystick	The current joystick
		@param	button	The button that was pressed</haxe_doc>
		</onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method" line="207">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick button up event is fired
		@param	joystick	The current joystick
		@param	button	The button that was released</haxe_doc>
		</onJoystickButtonUp>
		<onJoystickConnect public="1" set="method" line="213">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick is connected
		@param	joystick	The joystick that was connected</haxe_doc>
		</onJoystickConnect>
		<onJoystickDisconnect public="1" set="method" line="219">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick is disconnected
		@param	joystick	The joystick that was disconnected</haxe_doc>
		</onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method" line="227">
			<f a="joystick:hat:position">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick hat move event is fired
		@param	joystick	The current joystick
		@param	hat	The hat that was moved
		@param	position	The current hat position</haxe_doc>
		</onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method" line="236">
			<f a="joystick:trackball:x:y">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a joystick axis move event is fired
		@param	joystick	The current joystick
		@param	trackball	The trackball that was moved
		@param	x	The x movement of the trackball (between 0 and 1)
		@param	y	The y movement of the trackball (between 0 and 1)</haxe_doc>
		</onJoystickTrackballMove>
		<onKeyDown public="1" set="method" line="243">
			<f a="keyCode:modifier">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a key down event is fired on the primary window
		@param	keyCode	The code of the key that was pressed
		@param	modifier	The modifier of the key that was pressed</haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" set="method" line="250">
			<f a="keyCode:modifier">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a key up event is fired on the primary window
		@param	keyCode	The code of the key that was released
		@param	modifier	The modifier of the key that was released</haxe_doc>
		</onKeyUp>
		<onModuleExit public="1" set="method" line="255">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when the module is exiting</haxe_doc>
		</onModuleExit>
		<onMouseDown public="1" set="method" line="263">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.ui.MouseButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse down event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse
		@param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" set="method" line="270">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse move event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse</haxe_doc>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="method" line="277">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse move relative event is fired on the primary window
		@param	x	The x movement of the mouse
		@param	y	The y movement of the mouse</haxe_doc>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="method" line="285">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.ui.MouseButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse up event is fired on the primary window
		@param	x	The current x coordinate of the mouse
		@param	y	The current y coordinate of the mouse
		@param	button	The ID of the button that was released</haxe_doc>
		</onMouseUp>
		<onMouseWheel public="1" set="method" line="293">
			<f a="deltaX:deltaY:deltaMode">
				<x path="Float"/>
				<x path="Float"/>
				<e path="lime.ui.MouseWheelMode"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a mouse wheel event is fired on the primary window
		@param	deltaX	The amount of horizontal scrolling (if applicable)
		@param	deltaY	The amount of vertical scrolling (if applicable)
		@param	deltaMode	The units of measurement used</haxe_doc>
		</onMouseWheel>
		<onPreloadComplete public="1" set="method" line="298">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a preload complete event is fired</haxe_doc>
		</onPreloadComplete>
		<onPreloadProgress public="1" set="method" line="305">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a preload progress event is fired
		@param	loaded	The number of items that are loaded
		@param	total	The total number of items will be loaded</haxe_doc>
		</onPreloadProgress>
		<onRenderContextLost public="1" set="method" line="310">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a render context is lost on the primary window</haxe_doc>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="method" line="316">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a render context is restored on the primary window
		@param	context	The render context relevant to the event</haxe_doc>
		</onRenderContextRestored>
		<onTextEdit public="1" set="method" line="324">
			<f a="text:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a text edit event is fired on the primary window
		@param	text	The current replacement text
		@param	start	The starting index for the edit
		@param	length	The length of the edit</haxe_doc>
		</onTextEdit>
		<onTextInput public="1" set="method" line="330">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a text input event is fired on the primary window
		@param	text	The current input text</haxe_doc>
		</onTextInput>
		<onTouchCancel public="1" set="method" line="336">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch cancel event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchCancel>
		<onTouchEnd public="1" set="method" line="342">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch end event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1" set="method" line="348">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch move event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchMove>
		<onTouchStart public="1" set="method" line="354">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a touch start event is fired
		@param	touch	The current touch object</haxe_doc>
		</onTouchStart>
		<onWindowActivate public="1" set="method" line="359">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window activate event is fired on the primary window</haxe_doc>
		</onWindowActivate>
		<onWindowClose public="1" set="method" line="364">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window close event is fired on the primary window</haxe_doc>
		</onWindowClose>
		<onWindowCreate public="1" set="method" line="369">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is created</haxe_doc>
		</onWindowCreate>
		<onWindowDeactivate public="1" set="method" line="374">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window deactivate event is fired on the primary window</haxe_doc>
		</onWindowDeactivate>
		<onWindowDropFile public="1" set="method" line="379">
			<f a="file">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window drop file event is fired on the primary window</haxe_doc>
		</onWindowDropFile>
		<onWindowEnter public="1" set="method" line="384">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window enter event is fired on the primary window</haxe_doc>
		</onWindowEnter>
		<onWindowExpose public="1" set="method" line="389">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window expose event is fired on the primary window</haxe_doc>
		</onWindowExpose>
		<onWindowFocusIn public="1" set="method" line="394">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window focus in event is fired on the primary window</haxe_doc>
		</onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="399">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window focus out event is fired on the primary window</haxe_doc>
		</onWindowFocusOut>
		<onWindowFullscreen public="1" set="method" line="404">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window enters fullscreen</haxe_doc>
		</onWindowFullscreen>
		<onWindowLeave public="1" set="method" line="409">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when a window leave event is fired on the primary window</haxe_doc>
		</onWindowLeave>
		<onWindowMove public="1" set="method" line="416">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window move event is fired on the primary window
		@param	x	The x position of the window in desktop coordinates
		@param	y	The y position of the window in desktop coordinates</haxe_doc>
		</onWindowMove>
		<onWindowMinimize public="1" set="method" line="421">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is minimized</haxe_doc>
		</onWindowMinimize>
		<onWindowResize public="1" set="method" line="428">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a window resize event is fired on the primary window
		@param	width	The width of the window
		@param	height	The height of the window</haxe_doc>
		</onWindowResize>
		<onWindowRestore public="1" set="method" line="433">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Called when the primary window is restored from being minimized or fullscreen</haxe_doc>
		</onWindowRestore>
		<removeModule public="1" set="method" line="439">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes a module from the Application
		@param	module	A module to remove</haxe_doc>
		</removeModule>
		<render public="1" set="method" line="452">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when a render event is fired on the primary window
		@param	context	The render context ready to be rendered</haxe_doc>
		</render>
		<update public="1" set="method" line="458">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Called when an update event is fired on the primary window
		@param	deltaTime	The amount of time in milliseconds that has elapsed since the last update</haxe_doc>
		</update>
		<__addWindow set="method" line="460">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__addWindow>
		<__createWindow set="method" line="506">
			<f a="attributes">
				<t path="lime.ui.WindowAttributes"/>
				<c path="lime.ui.Window"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__createWindow>
		<__registerLimeModule set="method" line="513" override="1">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerLimeModule>
		<__removeWindow set="method" line="539">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__removeWindow>
		<__onGamepadConnect set="method" line="561">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onGamepadConnect>
		<__onJoystickConnect set="method" line="571">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onJoystickConnect>
		<__onModuleExit set="method" line="583">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onModuleExit>
		<__onWindowClose set="method" line="588">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onWindowClose>
		<__unregisterLimeModule set="method" line="598" override="1">
			<f a="application">
				<c path="lime.app.Application"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__unregisterLimeModule>
		<get_preloader get="inline" set="null" line="615">
			<f a=""><c path="lime.utils.Preloader"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_preloader>
		<get_window get="inline" set="null" line="620">
			<f a=""><c path="lime.ui.Window"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_window>
		<get_windows get="inline" set="null" line="625">
			<f a=""><c path="Array"><c path="lime.ui.Window"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_windows>
		<new public="1" set="method" line="96">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Application instance</haxe_doc>
		</new>
		<haxe_doc>The Application class forms the foundation for most Lime projects.
	It is common to extend this class in a main class. It is then possible
	to override "on" functions in the class in order to handle standard events
	that are relevant.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.ui.Window</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.app._Application.ApplicationBackend" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Application.hx" private="1" module="lime.app.Application">
		<c path="lime._internal.backend.flash.FlashApplication"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<class path="lime.app.Event" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Event.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__listeners public="1">
			<c path="Array"><c path="lime.app.Event.T"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__listeners>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<dispatch public="1">
			<d/>
			<haxe_doc><![CDATA[Dispatches a new event callback to all listeners. The signature for the
		`dispatch` method depends upon the type of the `Event`. For example, an
		`Event` of type `Int->Int->Void` will create a `dispatch` method that
		takes two `Int` arguments, like `dispatch (1, 2);`]]></haxe_doc>
		</dispatch>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app.Event.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app.Event.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Event is a strictly-typed signals and slots implementation, used for
	core event dispatching.

	For example:

	```haxe
	var event = new Event<Int->Void> ();
	event.add (function (value:Int):Void { trace (value); });
	event.dispatch (100);

	var event = new Event<Void->Void> ();
	event.add (function () { trace ("callback"); });
	event.dispatch ();
	```]]></haxe_doc>
		<meta>
			<m n=":genericBuild"><e>lime._internal.macros.EventMacro.build()</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app.Future" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Future.hx">
		<ofEvents public="1" params="T" set="method" line="103" static="1">
			<f a="onComplete:?onError:?onProgress" v=":null:null">
				<c path="lime.app._Event_ofEvents_T_Void"><f a="">
	<c path="ofEvents.T"/>
	<x path="Void"/>
</f></c>
				<x path="Null"><c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c></x>
				<x path="Null"><c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></x>
				<c path="lime.app.Future"><c path="ofEvents.T"/></c>
			</f>
			<meta><m n=":value"><e>{ onProgress : null, onError : null }</e></m></meta>
			<haxe_doc>Create a new `Future` instance based on complete and (optionally) error and/or progress `Event` instances</haxe_doc>
		</ofEvents>
		<withError public="1" set="method" line="294" static="1">
			<f a="error">
				<d/>
				<c path="lime.app.Future"><d/></c>
			</f>
			<haxe_doc>Creates a `Future` instance which has finished with an error value
		@param	error	The error value to set
		@return	A new `Future` instance</haxe_doc>
		</withError>
		<withValue public="1" params="T" set="method" line="307" static="1">
			<f a="value">
				<c path="withValue.T"/>
				<c path="lime.app.Future"><c path="withValue.T"/></c>
			</f>
			<haxe_doc>Creates a `Future` instance which has finished with a completion value
		@param	error	The completion value to set
		@return	A new `Future` instance</haxe_doc>
		</withValue>
		<error public="1" set="null">
			<d/>
			<haxe_doc>If the `Future` has finished with an error state, the `error` value</haxe_doc>
		</error>
		<isComplete public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Future` finished with a completion state</haxe_doc>
		</isComplete>
		<isError public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Future` finished with an error state</haxe_doc>
		</isError>
		<value public="1" set="null">
			<c path="lime.app.Future.T"/>
			<haxe_doc>If the `Future` has finished with a completion state, the completion `value`</haxe_doc>
		</value>
		<__completeListeners>
			<c path="Array"><f a="">
	<c path="lime.app.Future.T"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__completeListeners>
		<__errorListeners>
			<c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__errorListeners>
		<__progressListeners>
			<c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":noCompletion"/></meta>
		</__progressListeners>
		<onComplete public="1" set="method" line="121">
			<f a="listener">
				<f a="">
					<c path="lime.app.Future.T"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` completes.

		If the `Future` has already completed, this is called immediately with the result
		@param	listener	A callback method to receive the result value
		@return	The current `Future`</haxe_doc>
		</onComplete>
		<onError public="1" set="method" line="150">
			<f a="listener">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` ends with an error state.

		If the `Future` has already ended with an error, this is called immediately with the error value
		@param	listener	A callback method to receive the error value
		@return	The current `Future`</haxe_doc>
		</onError>
		<onProgress public="1" set="method" line="179">
			<f a="listener">
				<f a=":">
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<haxe_doc>Register a listener for when the `Future` updates progress.

		If the `Future` is already completed, this will not be called.
		@param	listener	A callback method to receive the progress value
		@return	The current `Future`</haxe_doc>
		</onProgress>
		<ready public="1" set="method" line="199">
			<f a="?waitTime" v="-1">
				<x path="Int"/>
				<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
			</f>
			<meta><m n=":value"><e>{ waitTime : -1 }</e></m></meta>
			<haxe_doc>Attempts to block on an asynchronous `Future`, returning when it is completed.
		@param	waitTime	(Optional) A timeout before this call will stop blocking
		@return	This current `Future`</haxe_doc>
		</ready>
		<result public="1" set="method" line="240">
			<f a="?waitTime" v="-1">
				<x path="Int"/>
				<x path="Null"><c path="lime.app.Future.T"/></x>
			</f>
			<meta><m n=":value"><e>{ waitTime : -1 }</e></m></meta>
			<haxe_doc>Attempts to block on an asynchronous `Future`, returning the completion value when it is finished.
		@param	waitTime	(Optional) A timeout before this call will stop blocking
		@return	The completion value, or `null` if the request timed out or blocking is not possible</haxe_doc>
		</result>
		<then public="1" params="U" set="method" line="258">
			<f a="next">
				<f a="">
					<c path="lime.app.Future.T"/>
					<c path="lime.app.Future"><c path="then.U"/></c>
				</f>
				<c path="lime.app.Future"><c path="then.U"/></c>
			</f>
			<haxe_doc>Chains two `Future` instances together, passing the result from the first
		as input for creating/returning a new `Future` instance of a new or the same type</haxe_doc>
		</then>
		<new public="1" set="method" line="73">
			<f a="?work:?async" v="null:false">
				<f a=""><c path="lime.app.Future.T"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false, work : null }</e></m></meta>
			<haxe_doc>Create a new `Future` instance
		@param	work	(Optional) A function to execute
		@param	async	(Optional) If a function is specified, whether to execute it asynchronously where supported</haxe_doc>
		</new>
		<haxe_doc>`Future` is an implementation of Futures and Promises, with the exception that
	in addition to "success" and "failure" states (represented as "complete" and "error"),
	Lime `Future` introduces "progress" feedback as well to increase the value of
	`Future` values.

	```haxe
	var future = Image.loadFromFile ("image.png");
	future.onComplete (function (image) { trace ("Image loaded"); });
	future.onProgress (function (loaded, total) { trace ("Loading: " + loaded + ", " + total); });
	future.onError (function (error) { trace (error); });

	Image.loadFromFile ("image.png").then (function (image) {

		return Future.withValue (image.width);

	}).onComplete (function (width) { trace (width); })
	```

	`Future` values can be chained together for asynchronous processing of values.

	If an error occurs earlier in the chain, the error is propagated to all `onError` callbacks.

	`Future` will call `onComplete` callbacks, even if completion occurred before registering the
	callback. This resolves race conditions, so even functions that return immediately can return
	values using `Future`.

	`Future` values are meant to be immutable, if you wish to update a `Future`, you should create one
	using a `Promise`, and use the `Promise` interface to influence the error, complete or progress state
	of a `Future`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.app.Promise</e></m>
		</meta>
	</class>
	<class path="lime.app._Future.FutureWork" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Future.hx" private="1" module="lime.app.Future">
		<threadPool static="1"><c path="lime.system.ThreadPool"/></threadPool>
		<queue public="1" set="method" line="324" static="1">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</queue>
		<threadPool_doWork set="method" line="338" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_doWork>
		<threadPool_onComplete set="method" line="351" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onComplete>
		<threadPool_onError set="method" line="356" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onError>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lime.app.Promise" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Promise.hx">
		<future public="1" set="null">
			<c path="lime.app.Future"><c path="lime.app.Promise.T"/></c>
			<haxe_doc>The `Future` associated with this `Promise`.

		All subsequent calls to set an error, completion or progress state
		will update the status and notify listeners to this `Future`</haxe_doc>
		</future>
		<isComplete public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Promise` (and related `Future`) has finished with a completion state.
		This will be `false` if the `Promise` has not been resolved with a completion or error state.</haxe_doc>
		</isComplete>
		<isError public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the `Promise` (and related `Future`) has finished with an error state.
		This will be `false` if the `Promise` has not been resolved with a completion or error state.</haxe_doc>
		</isError>
		<complete public="1" set="method" line="97">
			<f a="data">
				<c path="lime.app.Promise.T"/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with a completion state
		@param	data	The completion value
		@return	The current `Promise`</haxe_doc>
		</complete>
		<completeWith public="1" set="method" line="124">
			<f a="future">
				<c path="lime.app.Future"><c path="lime.app.Promise.T"/></c>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with the complete, error and/or progress state
		of another `Future`
		@param	future	The `Future` to use to resolve this `Promise`
		@return	The current `Promise`</haxe_doc>
		</completeWith>
		<error public="1" set="method" line="138">
			<f a="msg">
				<d/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Resolves this `Promise` with an error state
		@param	msg	The error value
		@return	The current `Promise`</haxe_doc>
		</error>
		<progress public="1" set="method" line="165">
			<f a="progress:total">
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
			</f>
			<haxe_doc>Sends progress updates to the related `Future`
		@param	progress	A progress value
		@param	total	A total value. This should be equal or greater to the `progress` value
		@return	The current `Promise`</haxe_doc>
		</progress>
		<get_isComplete set="method" line="182">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isComplete>
		<get_isError set="method" line="187">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isError>
		<new public="1" set="method" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a new `Promise` instance</haxe_doc>
		</new>
		<haxe_doc><![CDATA[`Promise` is an implementation of Futures and Promises, with the exception that
	in addition to "success" and "failure" states (represented as "complete" and "error"),
	Lime `Future` introduces "progress" feedback as well to increase the value of
	`Future` values.

	While `Future` is meant to be read-only, `Promise` can be used to set the state of a future
	for receipients of it's `Future` object. For example:

	```haxe
	function examplePromise ():Future<String> {

		var promise = new Promise<String> ();

		var progress = 0, total = 10;
		var timer = new Timer (100);
		timer.run = function () {

			promise.progress (progress, total);
			progress++;

			if (progress == total) {

				promise.complete ("Done!");
				timer.stop ();

			}

		};

		return promise.future;

	}

	var future = examplePromise ();
	future.onComplete (function (message) { trace (message); });
	future.onProgress (function (loaded, total) { trace ("Progress: " + loaded + ", " + total); });
	```]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.app.Future</e></m>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="lime.app._Event_Array_String__Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/FileDialog.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Array_String__Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="30"><f a="a">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Dynamic_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/ThreadPool.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Dynamic_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="25"><f a="a">
	<d/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Float_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Sensor.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="15"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Int_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="73"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="71"><f a="a:a1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="70"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="74"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Float_Float_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="29"><f a="a:a1:a2">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Float_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Int_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="24"><f a="a:a1">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Int_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Future.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Int_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="103"><f a="a:a1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Application.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="50"><f a="a">
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="28"><f a="a:a1">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_String_Int_Int_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_String_Int_Int_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="81"><f a="a:a1:a2">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_String_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_String_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="59"><f a="a">
	<c path="String"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_Void_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Clipboard.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_Void_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=""><x path="Void"/></f></c></__listeners>
		<dispatch public="1" set="method" line="20"><f a=""><x path="Void"/></f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_graphics_RenderContext_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="76"><f a="a">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_GamepadAxis_Float_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="21"><f a="a:a1">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_GamepadButton_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="22"><f a="a">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Gamepad_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Gamepad.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Gamepad_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="15"><f a="a">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Joystick_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Joystick.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Joystick_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="14"><f a="a">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="65"><f a="a:a1">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Touch_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Touch.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Touch_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="14"><f a="a">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_ui_Window_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Application.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_ui_Window_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="55"><f a="a">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_lime_utils_Resource_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/FileDialog.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_lime_utils_Resource_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="27"><f a="a">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.app._Event_ofEvents_T_Void" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/app/Future.hx">
		<canceled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Whether the event was canceled during the previous dispatch</haxe_doc>
		</canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities>
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__priorities>
		<add public="1" set="method" line="57">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
			<haxe_doc>Adds a new event listener
		@param	listener	A callback that matches the signature of the event
		@param	once	Whether to receive an event dispatch only once, or each time it is fired
		@param	priority	The priority for this listener, a higher priority will be dispatched sooner</haxe_doc>
		</add>
		<cancel public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Marks the event as canceled, and stops the current event dispatch</haxe_doc>
		</cancel>
		<has public="1" set="method" line="126">
			<f a="listener">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether a callback is a listener to this event
		@param	listener	A callback that matches the signature of the event
		@return	Whether the callback is a listener</haxe_doc>
		</has>
		<remove public="1" set="method" line="142">
			<f a="listener">
				<c path="lime.app._Event_ofEvents_T_Void.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an event listener
		@param	listener	A callback that matches the signature of the event</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all event listeners</haxe_doc>
		</removeAll>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.app._Event_ofEvents_T_Void.T"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="103"><f a="a">
	<c path="lime.app._Event_ofEvents_T_Void.T"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Event instance</haxe_doc>
		</new>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.graphics.FlashRenderContext" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/FlashRenderContext.hx">
		<from>
			<icast><c path="flash.display.Sprite"/></icast>
			<icast field="fromRenderContext"><c path="lime.graphics.RenderContext"/></icast>
		</from>
		<this><c path="flash.display.Sprite"/></this>
		<to><icast><c path="flash.display.Sprite"/></icast></to>
		<haxe_doc>The `FlashRenderContext` represents the primary `flash.display.Sprite` instance when
	targeting Flash Player.

	You can convert from `lime.graphics.RenderContext` to `FlashRenderContext` directly
	if desired:

	```haxe
	var sprite:FlashRenderContext = window.context;
	```</haxe_doc>
		<meta>
			<m n=":access"><e>lime.graphics.RenderContext</e></m>
			<m n=":forward"/>
		</meta>
		<impl><class path="lime.graphics._FlashRenderContext.FlashRenderContext_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/FlashRenderContext.hx" private="1" module="lime.graphics.FlashRenderContext" final="1">
	<fromRenderContext set="method" line="22" static="1">
		<f a="context">
			<c path="lime.graphics.RenderContext"/>
			<x path="lime.graphics.FlashRenderContext"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromRenderContext>
	<meta><m n=":access"><e>lime.graphics.RenderContext</e></m></meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._FlashRenderContext.FlashRenderContext_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/FlashRenderContext.hx" private="1" module="lime.graphics.FlashRenderContext" final="1">
		<fromRenderContext set="method" line="22" static="1">
			<f a="context">
				<c path="lime.graphics.RenderContext"/>
				<x path="lime.graphics.FlashRenderContext"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromRenderContext>
		<meta><m n=":access"><e>lime.graphics.RenderContext</e></m></meta>
	</class>
	<class path="lime.graphics.Image" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/Image.hx">
		<fromBase64 public="1" set="method" line="612" static="1">
			<f a="base64:type">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Converts a Base64-encoded `String` into an `Image`, or returns `null` if this is not possible
		@param	base64	A Base64-encoded `String`
		@param	type	A mime-type to describe the image data (such as "image/png")
		@return	A new `Image`, or `null` if conversion was not possible</haxe_doc>
		</fromBase64>
		<fromBitmapData public="1" set="method" line="626" static="1">
			<f a="bitmapData">
				<c path="flash.display.BitmapData"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Creates a new `Image` from a Flash `BitmapData` instance
		@param	bitmapData	A source `bitmapData` to use
		@return		A new `Image` instance</haxe_doc>
		</fromBitmapData>
		<fromBytes public="1" set="method" line="651" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Converts a `Bytes` object to an `Image` instance

		Some platforms (such as Flash and HTML5) cannot convert `Bytes` to an
		`Image` synchronously, and may not work properly.

		`Image.loadFromBytes` works asynchronously, and should work
		consistently on all platforms.
		@param	bytes	A `Bytes` holding encoded image data
		@return	A new `Image` instance</haxe_doc>
		</fromBytes>
		<fromFile public="1" set="method" line="694" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>Loads an `Image` from a path synchronously.

		Some platforms, such as Flash and HTML5, cannot load
		images synchronously.

		`Image.loadFromFile` works asynchronously, and should
		behave consistently on all platforms.
		@param	path	The source file path or URL of an encoded image file
		@return	A new `Image` instance</haxe_doc>
		</fromFile>
		<loadFromBase64 public="1" set="method" line="917" static="1">
			<f a="base64:type">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from a Base64-encoded `String`, asynchronously
		@param	base64	A Base64-encoded string representing encoded image data
		@param	type	The mime type of the encoded data (such as "image/png")
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromBase64>
		<loadFromBytes public="1" set="method" line="940" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from image-encoded `Bytes`, loaded asynchronously
		@param	bytes	A `Bytes` instance
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="1006" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<haxe_doc>Creates a new `Image` instance from a file path or URL, loaded asynchronously
		@param	path	A file path or URL containing an encoded image
		@return	A `Future` to return a new `Image` instance</haxe_doc>
		</loadFromFile>
		<__isGIF set="method" line="1710" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isGIF>
		<__isJPG set="method" line="1718" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isJPG>
		<__isPNG set="method" line="1728" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isPNG>
		<__isWebP set="method" line="1736" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isWebP>
		<buffer public="1">
			<c path="lime.graphics.ImageBuffer"/>
			<haxe_doc>The `ImageBuffer` store that backs the `Image`</haxe_doc>
		</buffer>
		<data public="1" get="accessor" set="accessor">
			<x path="lime.utils.UInt8Array"/>
			<haxe_doc>Retrieves `UInt8Array` data from the `ImageBuffer`. If the `ImageBuffer`
		is not in a data format, it will be converted.</haxe_doc>
		</data>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the `Image` is dirty. This is set to `true` when pixel operations
		have been performed on the underlying `buffer`, and can be set to `false`
		again by your own renderer.</haxe_doc>
		</dirty>
		<format public="1" get="accessor" set="accessor">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>Get or set the `PixelFormat` for the underlying `ImageBuffer`. This can be
		used to convert the `ImageBuffer` to a new format.</haxe_doc>
		</format>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The logical height of the `Image`. This can be smaller than the `height`
		of the underlying `buffer`.</haxe_doc>
		</height>
		<offsetX public="1">
			<x path="Int"/>
			<haxe_doc>The offset X position of the `Image`, from the source `buffer`,
		when the `Image` is smaller than the full size of the source `buffer`</haxe_doc>
		</offsetX>
		<offsetY public="1">
			<x path="Int"/>
			<haxe_doc>The offset Y position of the `Image`, from the source `buffer`,
		when the `Image` is smaller than the full size of the source `buffer`</haxe_doc>
		</offsetY>
		<powerOfTwo public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether the `ImageBuffer` dimensions are both a power-of-two
		(such as 2, 4, 8, 16, so on). Setting this value may resize the underlying
		`buffer`</haxe_doc>
		</powerOfTwo>
		<premultiplied public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether this `Image` has premultiplied alpha. Setting this value
		may multiply or unmultiply data if the underlying `ImageBuffer` uses a
		different format.</haxe_doc>
		</premultiplied>
		<rect public="1" get="accessor" set="null">
			<c path="lime.math.Rectangle"/>
			<haxe_doc>The offset, width and height of this image as a `Rectangle`</haxe_doc>
		</rect>
		<src public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>A higher-level representation of the source `ImageBuffer`. This might be an
		HTML5 Image, CanvasElement or a Flash BitmapData instance.</haxe_doc>
		</src>
		<transparent public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Get or set whether the underlying `ImageBuffer` is transparent.</haxe_doc>
		</transparent>
		<type public="1">
			<e path="lime.graphics.ImageType"/>
			<haxe_doc>The current `ImageType`, representing what is being used to store the `Image`'s graphics</haxe_doc>
		</type>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>The `version` of the `Image` increases each time it is modified, helpful to determining
		whether a cache is out-of-date.</haxe_doc>
		</version>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The logical width of the `Image`. This can be smaller than the `width`
		of the underlying `buffer`.</haxe_doc>
		</width>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>A convenience property, unused internally, which may be helpful for different renderer
		implementations</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>A convenience property, unused internally, which may be helpful for different renderer
		implementations</haxe_doc>
		</y>
		<clone public="1" set="method" line="285">
			<f a=""><c path="lime.graphics.Image"/></f>
			<haxe_doc>Creates a duplicate copy of this `Image` and `ImageBuffer`
		@return	A new `Image` instance</haxe_doc>
		</clone>
		<colorTransform public="1" set="method" line="315">
			<f a="rect:colorMatrix">
				<c path="lime.math.Rectangle"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies a color transform to the underlying `ImageBuffer` data
		@param	rect	The target rectangle to transform
		@param	colorMatrix	A `ColorMatrix` for color offset and/or multiplication</haxe_doc>
		</colorTransform>
		<copyChannel public="1" set="method" line="348">
			<f a="sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<e path="lime.graphics.ImageChannel"/>
				<e path="lime.graphics.ImageChannel"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copy a color channel from one `Image` to another. This can also be within the same `Image` instance.
		@param	sourceImage	The `Image` to copy from
		@param	sourceRect	The source rectangle to copy from in the `sourceImage`
		@param	destPoint	The destination point to apply the channel in the current `Image`
		@param	sourceChannel	The source color channel to copy the data from
		@param	destChannel	The destination color channel to apply the data into</haxe_doc>
		</copyChannel>
		<copyPixels public="1" set="method" line="406">
			<f a="sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v=":::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
			<haxe_doc>Copies pixels from one `Image` to another. The source `Image` can also be this `Image`
		@param	sourceImage	The source `Image` to copy from
		@param	sourceRect	The source rectangle to use when copying
		@param	destPoint	The destination point to use when copying
		@param	alphaImage	(Optional) A different `Image` to use as the alpha channel while copying
		@param	alphaPoint	(Optional) A point in the alpha image to use when copying
		@param	mergeAlpha	(Optional) Whether to blend the source and destination alpha (`true`), or to replace the destination alpha (`false`)</haxe_doc>
		</copyPixels>
		<encode public="1" set="method" line="506">
			<f a="?format:?quality" v="null:90">
				<e path="lime.graphics.ImageFileFormat"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ quality : 90, format : null }</e></m></meta>
			<haxe_doc>Encodes this `Image` into an image file format, such as PNG or JPEG.
		@param	format	(Optional) An `ImageFileFormat` to encode into (default is `PNG`)
		@param	quality	(Optional) A quality value to use when encoding as JPEG (from 0 to 100)
		@return	`Bytes` for the encoded `Image`, or `null` if encoding was not successful</haxe_doc>
		</encode>
		<fillRect public="1" set="method" line="531">
			<f a="rect:color:?format" v="::null">
				<c path="lime.math.Rectangle"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Fill a rectangle in the `Image` with a solid color
		@param	rect	A destination rectangle in this `Image` to fill
		@param	color	The color to use when filling this `Image`
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</fillRect>
		<floodFill public="1" set="method" line="576">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Applies a flood fill to this `Image`, starting with the point specified.

		A flood fill behaves similarly to the "paint can" tool in many image editors,
		the fill will apply the chosen color to neighboring pixels of the same color.
		@param	x	The target x coordinate within the `Image` to use with the fill
		@param	y	The target y coordinate within the `Image` to use with the fill
		@param	color	The color to use when performing the fill
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</floodFill>
		<getColorBoundsRect public="1" set="method" line="735">
			<f a="mask:color:?findColor:?format" v="::true:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ format : null, findColor : true }</e></m></meta>
			<haxe_doc>Finds a region in the `Image` that includes pixels all of a certain color (when `findColor` is `true`) or
		excludes a certain color (`findColor` is `false`)
		@param	mask	A hexadecimal mask to use when comparing colors. You can use this to compare all of a color, or only certain color channels
		@param	color	The color value to use in comparisons
		@param	findColor	(Optional) Whether to find a region that does match the color (`true`) or excludes it (`false`)
		@param	format	(Optional) The `PixelFormat` that the `color` and `mask` are encoded in (default is `RGBA`)
		@return	The matching bounds `Rectangle`, or `null` if no matching region is found</haxe_doc>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="767">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a 24-bit pixel from the `Image` (red, green and blue, but no alpha)
		@param	x	The `x` location to fetch
		@param	y	The `y` location to fetch
		@param	format	(Optional) The `PixelFormat` to encode the return value in (default is `RGBA`)
		@return	The specified pixel, or `0` if it is out-of-bounds</haxe_doc>
		</getPixel>
		<getPixel32 public="1" set="method" line="809">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a 32-bit pixel from the `Image`, including alpha
		@param	x	The `x` location to fetch
		@param	y	The `y` location to fetch
		@param	format	(Optional) The `PixelFormat` to encode the return value in (default is `RGBA`)
		@return	The specified pixel, or `0` if it is out-of-bounds</haxe_doc>
		</getPixel32>
		<getPixels public="1" set="method" line="850">
			<f a="rect:?format" v=":null">
				<c path="lime.math.Rectangle"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Gets a region of pixels from the `Image`, as `Bytes`
		@param	rect	The source `Rectangle` to read from
		@param	format	(Optional) The `PixelFormat` to use when writing to the `Bytes` object (default is `RGBA`)
		@return	A `Bytes` object representing the region, or `null` if it is not possible to read</haxe_doc>
		</getPixels>
		<merge public="1" set="method" line="1078">
			<f a="sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Blits a second `Image` onto this one, using optional color multipliers
		@param	sourceImage	An `Image` instance to copy from
		@param	sourceRect	The source rectangle to use when copying
		@param	destPoint	The destination point in this `Image` to copy into
		@param	redMultiplier	A red multiplier to use when blitting
		@param	greenMultiplier	A red multiplier to use when blitting
		@param	blueMultiplier	A red multiplier to use when blitting
		@param	alphaMultiplier	A red multiplier to use when blitting</haxe_doc>
		</merge>
		<resize public="1" set="method" line="1113">
			<f a="newWidth:newHeight">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Resizes the current `Image`, reallocating the `ImageBuffer` to a new size.
		The resize algorithm for most platforms is bilinear.
		@param	newWidth	A new width for the `Image`
		@param	newHeight	A new height for the `Image`</haxe_doc>
		</resize>
		<scroll public="1" set="method" line="1153">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scrolls the content of this `Image`.

		Pixels on the edges of the scroll will remain repeated, while others
		within the scroll area will be shifted

		@param	x	The amount of horizontal scroll to apply
		@param	y	The amount of vertical scroll to apply</haxe_doc>
		</scroll>
		<setPixel public="1" set="method" line="1179">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Sets a pixel in the current `Image` in 24-bit color format (red, green, blue, no alpha)
		@param	x	The x coordinate of the pixel
		@param	y	The y coordinate of the pixel
		@param	color	The color to use
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</setPixel>
		<setPixel32 public="1" set="method" line="1216">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
			<haxe_doc>Sets a pixel in the current `Image` in 32-bit color format (includes alpha)
		@param	x	The x coordinate of the pixel
		@param	y	The y coordinate of the pixel
		@param	color	The color to use
		@param	format	(Optional) The `PixelFormat` that `color` is encoded in (default is `RGBA`)</haxe_doc>
		</setPixel32>
		<setPixels public="1" set="method" line="1253">
			<f a="rect:bytePointer:?format:?endian" v="::null:null">
				<c path="lime.math.Rectangle"/>
				<x path="lime.utils.BytePointer"/>
				<x path="lime.graphics.PixelFormat"/>
				<e path="lime.system.Endian"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endian : null, format : null }</e></m></meta>
			<haxe_doc>Sets a region of pixels at once using a `BytePointer`
		@param	rect	The region of pixels in this `Image` to replace with the incoming bytes
		@param	bytePointer	A `BytePointer` object referencing the `Bytes` and position to read from
		@param	format	(Optional) The `PixelFormat` that the pixels are encoded in (default is `RGBA`)
		@param	endian (Optional) The endianness of the incoming bytes (default is the system endianness)</haxe_doc>
		</setPixels>
		<threshold public="1" set="method" line="1359">
			<f a="sourceImage:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource:?format" v=":::::0x00000000:0xFFFFFFFF:false:null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null, copySource : false, mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
			<haxe_doc><![CDATA[Tests pixel values in an image against a specified threshold and sets
		pixels that pass the test to new color values. Using the
		`threshold()` method, you can isolate and replace color ranges
		in an image and perform other logical operations on image pixels.

		The `threshold()` method's test logic is as follows:

		 1. If `((pixelValue & mask) operation(threshold & mask))`,
		then set the pixel to `color`;
		 2. Otherwise, if `copySource == true`, then set the pixel to
		corresponding pixel value from `sourceBitmap`.

		The `operation` parameter specifies the comparison operator
		to use for the threshold test. For example, by using "==" as the
		`operation` parameter, you can isolate a specific color value
		in an image. Or by using `{operation: "<", mask: 0xFF000000,
		threshold: 0x7F000000, color: 0x00000000}`, you can set all
		destination pixels to be fully transparent when the source image pixel's
		alpha is less than 0x7F. You can use this technique for animated
		transitions and other effects.

		@param	sourceImage	The input bitmap image to use. The source image can be a different `Image` object or it can refer to the current `Image` instance.
		@param	sourceRect	A rectangle that defines the area of the source image to use as input.
		@param	destPoint	The point within the destination image (the current `Image` instance) that corresponds to the upper-left corner of the source rectangle.
		@param	operation	One of the following comparison operators, passed as a `String`: "<", "<=", ">", ">=", "==", "!="
		@param	threshold	The value that each pixel is tested against to see if it meets or exceeds the threshhold.
		@param	color	The color value that a pixel is set to if the threshold test succeeds. The default value is 0x00000000.
		@param	mask	The mask to use to isolate a color component.
		@param	copySource	If the value is `true`, pixel values from the source image are copied to the destination when the threshold test fails. If the value is `false`, the source image is not copied when the threshold test fails.
		@return	The number of pixels that were changed.]]></haxe_doc>
		</threshold>
		<__clipRect set="method" line="1401">
			<f a="r">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__clipRect>
		<__fromBase64 set="method" line="1438">
			<f a="base64:type:?onload" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromBase64>
		<__fromBytes set="method" line="1473">
			<f a="bytes:?onload" v=":null">
				<c path="haxe.io.Bytes"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromBytes>
		<__fromFile set="method" line="1530">
			<f a="path:?onload:?onerror" v=":null:null">
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ onerror : null, onload : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromFile>
		<__fromImageBuffer set="method" line="1692">
			<f a="buffer">
				<c path="lime.graphics.ImageBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromImageBuffer>
		<get_data set="method" line="1744">
			<f a=""><x path="lime.utils.UInt8Array"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_data>
		<set_data set="method" line="1759">
			<f a="value">
				<x path="lime.utils.UInt8Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_data>
		<get_format set="method" line="1764">
			<f a=""><x path="lime.graphics.PixelFormat"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_format>
		<set_format set="method" line="1769">
			<f a="value">
				<x path="lime.graphics.PixelFormat"/>
				<x path="lime.graphics.PixelFormat"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_format>
		<get_powerOfTwo set="method" line="1785">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_powerOfTwo>
		<set_powerOfTwo set="method" line="1792">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_powerOfTwo>
		<get_premultiplied set="method" line="1842">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_premultiplied>
		<set_premultiplied set="method" line="1847">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_premultiplied>
		<get_rect set="method" line="1883">
			<f a=""><c path="lime.math.Rectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_rect>
		<get_src set="method" line="1888">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="1900">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<get_transparent set="method" line="1905">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_transparent>
		<set_transparent set="method" line="1911">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_transparent>
		<new public="1" set="method" line="219">
			<f a="?buffer:?offsetX:?offsetY:?width:?height:?color:?type" v="null:0:0:-1:-1:null:null">
				<c path="lime.graphics.ImageBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="lime.graphics.ImageType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : null, color : null, height : -1, width : -1, offsetY : 0, offsetX : 0, buffer : null }</e></m></meta>
			<haxe_doc>Creates a new `Image` instance.

		If `buffer` is null, but `width` and `height` are set, a new `ImageBuffer` is allocated matching the `color` requested.
		@param	buffer	(Optional) The `ImageBuffer` this `Image` represents
		@param	offsetX	(Optional) A logical offset value within the `ImageBuffer` dimensions
		@param	offsetY	(Optional) A logical offset value within the `ImageBuffer` dimensions
		@param	width	(Optional) A logical width value within the `ImageBuffer` dimensions
		@param	height	(Optional) A logical height value within the `ImageBuffer` dimensions
		@param	color	(Optional) A fill color to use if the `buffer` property is `null`
		@param	type	(Optional) An `ImageType` to use for this `Image`</haxe_doc>
		</new>
		<haxe_doc>`Image` is a convenience class for working with bitmap images in Lime.

	Although `ImageBuffer` holds the actual bitmap data, `Image` includes convenience methods for
	loading from files, loading from bytes, and performing many pixel operations over an
	`ImageBuffer` instance.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":autoBuild"><e>lime._internal.macros.AssetsMacro.embedImage()</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":allow"><e>lime._internal.graphics.ImageCanvasUtil</e></m>
			<m n=":allow"><e>lime._internal.graphics.ImageDataUtil</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.math.ColorMatrix</e></m>
			<m n=":access"><e>lime.math.Rectangle</e></m>
			<m n=":access"><e>lime.math.Vector2</e></m>
		</meta>
	</class>
	<class path="lime.graphics.ImageBuffer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/ImageBuffer.hx">
		<bitsPerPixel public="1">
			<x path="Int"/>
			<haxe_doc>The number of bits per pixel in this image data</haxe_doc>
		</bitsPerPixel>
		<data public="1">
			<x path="lime.utils.UInt8Array"/>
			<haxe_doc>The data for this image, represented as a `UInt8Array`</haxe_doc>
		</data>
		<format public="1">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>The `PixelFormat` for this image data</haxe_doc>
		</format>
		<height public="1">
			<x path="Int"/>
			<haxe_doc>The height of this image data</haxe_doc>
		</height>
		<premultiplied public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the image data has premultiplied alpha</haxe_doc>
		</premultiplied>
		<src public="1" get="accessor" set="accessor">
			<d/>
			<haxe_doc>The data for this image, represented as a `js.html.CanvasElement`, `js.html.Image` or `flash.display.BitmapData`</haxe_doc>
		</src>
		<stride public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The stride, or number of data values (in bytes) per row in the image data</haxe_doc>
		</stride>
		<transparent public="1">
			<x path="Bool"/>
			<haxe_doc>Whether this image data is transparent</haxe_doc>
		</transparent>
		<width public="1">
			<x path="Int"/>
			<haxe_doc>The width of this image data</haxe_doc>
		</width>
		<__srcBitmapData>
			<c path="flash.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBitmapData>
		<__srcCanvas>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCanvas>
		<__srcContext>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcContext>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcImage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImage>
		<__srcImageData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImageData>
		<clone public="1" set="method" line="127">
			<f a=""><c path="lime.graphics.ImageBuffer"/></f>
			<haxe_doc>Creates a duplicate of this `ImageBuffer`

		If the current `ImageBuffer` has `data` or `src` information, this will be
		cloned as well.
		@return	A new `ImageBuffer` with duplicate values</haxe_doc>
		</clone>
		<get_src set="method" line="189">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="201">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<get_stride set="method" line="222">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_stride>
		<new public="1" set="method" line="109">
			<f a="?data:?width:?height:?bitsPerPixel:?format" v="null:0:0:32:null">
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null, bitsPerPixel : 32, height : 0, width : 0, data : null }</e></m></meta>
			<haxe_doc>Creates a new `ImageBuffer` instance
		@param	data	(Optional) Initial `UInt8Array` data
		@param	width	(Optional) An initial `width` value
		@param	height	(Optional) An initial `height` value
		@param	bitsPerPixel	(Optional) The `bitsPerPixel` of the data (default is 32)
		@param	format	(Optional) The `PixelFormat` of this image buffer</haxe_doc>
		</new>
		<haxe_doc>`ImageBuffer` is a simple object for storing image data.

	For higher-level operations, use the `Image` class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":allow"><e>lime.graphics.Image</e></m>
		</meta>
	</class>
	<enum path="lime.graphics.ImageChannel" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/ImageChannel.hx">
		<RED><haxe_doc>The red color channel</haxe_doc></RED>
		<GREEN><haxe_doc>The green color channel</haxe_doc></GREEN>
		<BLUE><haxe_doc>The blue color channel</haxe_doc></BLUE>
		<ALPHA><haxe_doc>The alpha color channel</haxe_doc></ALPHA>
		<haxe_doc>An enum with values for standard image color channels</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="lime.graphics.ImageFileFormat" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/ImageFileFormat.hx">
		<BMP><haxe_doc>An image file encoded in the BMP file format</haxe_doc></BMP>
		<JPEG><haxe_doc>An image file encoded in the JPEG file format</haxe_doc></JPEG>
		<PNG><haxe_doc>An image file encoded in the PNG file format</haxe_doc></PNG>
		<haxe_doc>An enum with values for image encoding formats</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.graphics.ImageType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/ImageType.hx">
		<CANVAS><haxe_doc>The source image data is stored in a `js.html.Image` or `js.html.CanvasElement`</haxe_doc></CANVAS>
		<DATA><haxe_doc>The source image data is stored in a `UInt8Array`</haxe_doc></DATA>
		<FLASH><haxe_doc>The source image data is stored in a `flash.display.BitmapData`</haxe_doc></FLASH>
		<CUSTOM><haxe_doc>The source image data is stored in a custom format</haxe_doc></CUSTOM>
		<haxe_doc>An enum containing values for the underlying image type
	represented by an `ImageBuffer`</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.graphics.PixelFormat" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/PixelFormat.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>An enum containing different pixel encoding formats for image data</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1" final="1">
	<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="11" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit RGBA color order</haxe_doc>
	</RGBA32>
	<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="16" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit ARGB color order</haxe_doc>
	</ARGB32>
	<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>An image encoded in 32-bit BGRA color order</haxe_doc>
	</BGRA32>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1" final="1">
		<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="11" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit RGBA color order</haxe_doc>
		</RGBA32>
		<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="16" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit ARGB color order</haxe_doc>
		</ARGB32>
		<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="21" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>An image encoded in 32-bit BGRA color order</haxe_doc>
		</BGRA32>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.graphics.RenderContext" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/RenderContext.hx">
		<attributes public="1" set="null">
			<t path="lime.graphics.RenderContextAttributes"/>
			<haxe_doc>Additional information about the current context</haxe_doc>
		</attributes>
		<flash public="1" set="null">
			<x path="lime.graphics.FlashRenderContext"/>
			<haxe_doc>Access to the current Cairo render context, if available</haxe_doc>
		</flash>
		<type public="1" set="null">
			<x path="lime.graphics.RenderContextType"/>
			<haxe_doc>Access to the current OpenGL render API, if available</haxe_doc>
		</type>
		<version public="1" set="null"><c path="String"/></version>
		<window public="1" set="null">
			<c path="lime.ui.Window"/>
			<haxe_doc>Access to the current WebGL render API, if available</haxe_doc>
		</window>
		<new set="method" line="91">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<haxe_doc>The `RenderContext` provides access to rendering for a Lime `Window`.

	Only one render context type is used at once, but when `OPENGL` or
	`OPENGLES` is the context type, compatibility contexts for other
	forms of GL (such as WebGL) may be available also.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.graphics.RenderContextAttributes" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/RenderContextAttributes.hx">
		<a>
			<vsync>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether vertical-sync (VSync) is enabled</haxe_doc>
			</vsync>
			<version>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
			</version>
			<type>
				<x path="Null"><x path="lime.graphics.RenderContextType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of render context requested</haxe_doc>
			</type>
			<stencil>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether a stencil buffer is enabled</haxe_doc>
			</stencil>
			<hardware>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether hardware acceleration is allowed</haxe_doc>
			</hardware>
			<depth>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether a depth buffer is enabled</haxe_doc>
			</depth>
			<colorDepth>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The color depth of the rendering context in bits</haxe_doc>
			</colorDepth>
			<background>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional `background` property to be provided to rendering,
		a value of `null` means no background color.</haxe_doc>
			</background>
			<antialiasing>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether to enable anti-aliasing, `0` is disabled, `2` enables
		2x2 anti-aliasing or `4` enables 4x4 anti-aliasing.</haxe_doc>
			</antialiasing>
		</a>
		<haxe_doc>Additional options possible for a render context</haxe_doc>
	</typedef>
	<abstract path="lime.graphics.RenderContextType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/RenderContextType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<haxe_doc>An enum for possible render context types</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._RenderContextType.RenderContextType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/RenderContextType.hx" private="1" module="lime.graphics.RenderContextType" extern="1" final="1">
	<CAIRO public="1" get="inline" set="null" expr="cast &quot;cairo&quot;" line="11" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "cairo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a Cairo render context</haxe_doc>
	</CAIRO>
	<CANVAS public="1" get="inline" set="null" expr="cast &quot;canvas&quot;" line="16" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "canvas"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an HTML5 canvas render context</haxe_doc>
	</CANVAS>
	<DOM public="1" get="inline" set="null" expr="cast &quot;dom&quot;" line="21" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "dom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an HTML5 DOM render context</haxe_doc>
	</DOM>
	<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="26" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "flash"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a Flash render context</haxe_doc>
	</FLASH>
	<OPENGL public="1" get="inline" set="null" expr="cast &quot;opengl&quot;" line="31" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "opengl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an OpenGL render context</haxe_doc>
	</OPENGL>
	<OPENGLES public="1" get="inline" set="null" expr="cast &quot;opengles&quot;" line="36" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "opengles"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes an OpenGL ES render context</haxe_doc>
	</OPENGLES>
	<WEBGL public="1" get="inline" set="null" expr="cast &quot;webgl&quot;" line="41" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "webgl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a WebGL render context</haxe_doc>
	</WEBGL>
	<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="46" static="1">
		<x path="lime.graphics.RenderContextType"/>
		<meta>
			<m n=":value"><e>cast "custom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Describes a custom render context</haxe_doc>
	</CUSTOM>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._RenderContextType.RenderContextType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/graphics/RenderContextType.hx" private="1" module="lime.graphics.RenderContextType" extern="1" final="1">
		<CAIRO public="1" get="inline" set="null" expr="cast &quot;cairo&quot;" line="11" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "cairo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a Cairo render context</haxe_doc>
		</CAIRO>
		<CANVAS public="1" get="inline" set="null" expr="cast &quot;canvas&quot;" line="16" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "canvas"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an HTML5 canvas render context</haxe_doc>
		</CANVAS>
		<DOM public="1" get="inline" set="null" expr="cast &quot;dom&quot;" line="21" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "dom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an HTML5 DOM render context</haxe_doc>
		</DOM>
		<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="26" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "flash"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a Flash render context</haxe_doc>
		</FLASH>
		<OPENGL public="1" get="inline" set="null" expr="cast &quot;opengl&quot;" line="31" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "opengl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an OpenGL render context</haxe_doc>
		</OPENGL>
		<OPENGLES public="1" get="inline" set="null" expr="cast &quot;opengles&quot;" line="36" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "opengles"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes an OpenGL ES render context</haxe_doc>
		</OPENGLES>
		<WEBGL public="1" get="inline" set="null" expr="cast &quot;webgl&quot;" line="41" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "webgl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a WebGL render context</haxe_doc>
		</WEBGL>
		<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="46" static="1">
			<x path="lime.graphics.RenderContextType"/>
			<meta>
				<m n=":value"><e>cast "custom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Describes a custom render context</haxe_doc>
		</CUSTOM>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="lime.math.ARGB" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ARGB.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.BGRA"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.RGBA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in an ARGB
	(alpha, red, green, blue) color format.

	```haxe
	var color:ARGB = 0xFF883300;
	trace (color.a); // 0xFF
	trace (color.r); // 0x88
	trace (color.g); // 0x33
	trace (color.b); // 0x00

	var convert:BGRA = color; // 0x003388FF
	```</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="lime.math._ARGB.ARGB_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ARGB.hx" private="1" module="lime.math.ARGB" final="1">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="51" static="1">
		<f a="?argb" v="0">
			<x path="Int"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta>
			<m n=":value"><e>{ argb : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new ARGB instance
		@param	argb	(Optional) An ARGB color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="64" static="1">
		<f a="a:r:g:b">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.ARGB"/>
		</f>
		<haxe_doc>Creates a new ARGB instance from component values
		@param	a	An alpha component value
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@return	A new ARGB instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="74" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="94" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `ARGB` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="121" static="1">
		<f a="this:a:r:g:b">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `ARGB` color to new component values
		@param	a	The alpha component value to set
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="129" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="145" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `ARGB` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromBGRA get="inline" set="null" line="174" static="1">
		<f a="bgra">
			<x path="lime.math.BGRA"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<__fromRGBA get="inline" set="null" line="179" static="1">
		<f a="rgba">
			<x path="lime.math.RGBA"/>
			<x path="lime.math.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="185" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="190" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="196" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="201" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="207" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="212" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="218" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="223" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
</class></impl>
	</abstract>
	<class path="lime.math._ARGB.ARGB_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ARGB.hx" private="1" module="lime.math.ARGB" final="1">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="51" static="1">
			<f a="?argb" v="0">
				<x path="Int"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta>
				<m n=":value"><e>{ argb : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new ARGB instance
		@param	argb	(Optional) An ARGB color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="64" static="1">
			<f a="a:r:g:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.ARGB"/>
			</f>
			<haxe_doc>Creates a new ARGB instance from component values
		@param	a	An alpha component value
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@return	A new ARGB instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="74" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="94" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `ARGB` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="121" static="1">
			<f a="this:a:r:g:b">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `ARGB` color to new component values
		@param	a	The alpha component value to set
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="129" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="145" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `ARGB` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromBGRA get="inline" set="null" line="174" static="1">
			<f a="bgra">
				<x path="lime.math.BGRA"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<__fromRGBA get="inline" set="null" line="179" static="1">
			<f a="rgba">
				<x path="lime.math.RGBA"/>
				<x path="lime.math.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="185" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="190" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="196" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="201" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="207" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="212" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="218" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="223" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
	</class>
	<abstract path="lime.math.BGRA" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/BGRA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.ARGB"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.RGBA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in a BGRA
	(blue, green, red, alpha) color format.

	```haxe
	var color:BGRA = 0x003388FF;
	trace (color.b); // 0x00
	trace (color.g); // 0x33
	trace (color.r); // 0x88
	trace (color.a); // 0xFF

	var convert:ARGB = color; // 0xFF883300
	```</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="lime.math._BGRA.BGRA_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/BGRA.hx" private="1" module="lime.math.BGRA" final="1">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="51" static="1">
		<f a="?bgra" v="0">
			<x path="Int"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta>
			<m n=":value"><e>{ bgra : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new BGRA instance
		@param	bgra	(Optional) A BGRA color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="64" static="1">
		<f a="b:g:r:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.BGRA"/>
		</f>
		<haxe_doc>Creates a new BGRA instance from component values
		@param	b	A blue component value
		@param	g	A green component value
		@param	r	A red component value
		@param	a	An alpha component value
		@return	A new BGRA instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="74" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="94" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `BGRA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="121" static="1">
		<f a="this:b:g:r:a">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `BGRA` color to new component values
		@param	b	The blue component vlaue to set
		@param	g	The green component value to set
		@param	r	The red component value to set
		@param	a	The alpha component value to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="129" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="145" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `BGRA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="174" static="1">
		<f a="argb">
			<x path="lime.math.ARGB"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromRGBA get="inline" set="null" line="179" static="1">
		<f a="rgba">
			<x path="lime.math.RGBA"/>
			<x path="lime.math.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="185" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="190" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="196" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="201" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="207" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="212" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="218" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="223" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
</class></impl>
	</abstract>
	<class path="lime.math._BGRA.BGRA_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/BGRA.hx" private="1" module="lime.math.BGRA" final="1">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="51" static="1">
			<f a="?bgra" v="0">
				<x path="Int"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta>
				<m n=":value"><e>{ bgra : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new BGRA instance
		@param	bgra	(Optional) A BGRA color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="64" static="1">
			<f a="b:g:r:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.BGRA"/>
			</f>
			<haxe_doc>Creates a new BGRA instance from component values
		@param	b	A blue component value
		@param	g	A green component value
		@param	r	A red component value
		@param	a	An alpha component value
		@return	A new BGRA instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="74" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="94" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `BGRA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="121" static="1">
			<f a="this:b:g:r:a">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `BGRA` color to new component values
		@param	b	The blue component vlaue to set
		@param	g	The green component value to set
		@param	r	The red component value to set
		@param	a	The alpha component value to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="129" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="145" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `BGRA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="174" static="1">
			<f a="argb">
				<x path="lime.math.ARGB"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromRGBA get="inline" set="null" line="179" static="1">
			<f a="rgba">
				<x path="lime.math.RGBA"/>
				<x path="lime.math.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="185" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="190" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="196" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="201" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="207" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="212" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="218" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="223" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
	</class>
	<abstract path="lime.math.ColorMatrix" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ColorMatrix.hx">
		<from><icast><x path="lime.utils.Float32Array"/></icast></from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<haxe_doc>`ColorMatrix` is a 4x5 matrix containing color multiplication
	and offset values for tinting and other kinds of color
	manipulation. In addition to using the multiplier, offset and
	`color` properties, it can be edited directly as a `Float32Array`</haxe_doc>
		<impl><class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix" final="1">
	<__alphaTable static="1"><x path="lime.utils.UInt8Array"/></__alphaTable>
	<__blueTable static="1"><x path="lime.utils.UInt8Array"/></__blueTable>
	<__greenTable static="1"><x path="lime.utils.UInt8Array"/></__greenTable>
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="20" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
	</__identity>
	<__redTable static="1"><x path="lime.utils.UInt8Array"/></__redTable>
	<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current alpha multiplication value (default is 1.0)</haxe_doc>
	</alphaMultiplier>
	<alphaOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current alpha offset value (default is 0)</haxe_doc>
	</alphaOffset>
	<blueMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current blue multiplication value (default is 1.0)</haxe_doc>
	</blueMultiplier>
	<blueOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current blue offset value (default is 0)</haxe_doc>
	</blueOffset>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets or sets a color offset for tinting.

		This will change the red, green and blue multipliers
		to zero, and affect the red, green and blue offset
		values.</haxe_doc>
	</color>
	<greenMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current green multiplication value (default is 1.0)</haxe_doc>
	</greenMultiplier>
	<greenOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current green offset value (default is 0)</haxe_doc>
	</greenOffset>
	<redMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current red multiplication value (default is 1.0)</haxe_doc>
	</redMultiplier>
	<redOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The current red offset value (default is 0)</haxe_doc>
	</redOffset>
	<_new public="1" set="method" line="78" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new `ColorMatrix` instance
		@param	data	(Optional) Initial `Float32Array` data to use</haxe_doc>
	</_new>
	<clone public="1" set="method" line="94" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a duplicate of the current `ColorMatrix` instance
		@return	A new `ColorMatrix` instance</haxe_doc>
	</clone>
	<concat public="1" set="method" line="103" static="1">
		<f a="this:second">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Adds the color multipliers from a second `ColorMatrix` to the current one
		@param	second	The `ColorMatrix` to `concat` to the current one</haxe_doc>
	</concat>
	<copyFrom public="1" set="method" line="115" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `ColorMatrix` values to the same as another one
		@param	other	The `ColorMatrix` to copy from</haxe_doc>
	</copyFrom>
	<identity public="1" set="method" line="123" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Resets to default values</haxe_doc>
	</identity>
	<getAlphaTable public="1" set="method" line="167" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		alpha values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `alphaMultipler` and `alphaOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.alphaOffset = 12;

		var alphaTable = colorMatrix.getAlphaTable ();
		trace (alphaTable[0]); // 12
		trace (alphaTable[1]); // 13
		```</haxe_doc>
	</getAlphaTable>
	<getBlueTable public="1" set="method" line="208" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		blue values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `blueMultiplier` and `blueOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.blueOffset = 16;

		var blueTable = colorMatrix.getBlueTable ();
		trace (blueTable[0]); // 16
		trace (blueTable[1]); // 17
		```</haxe_doc>
	</getBlueTable>
	<getGreenTable public="1" set="method" line="248" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		green values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `greenMultiplier` and `greenOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.greenOffset = 16;

		var greenTable = colorMatrix.getGreenTable ();
		trace (greenTable[0]); // 16
		trace (greenTable[1]); // 17
		```</haxe_doc>
	</getGreenTable>
	<getRedTable public="1" set="method" line="288" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		red values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `redMultiplier` and `redOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.redOffset = 16;

		var redTable = colorMatrix.getRedTable ();
		trace (redTable[0]); // 16
		trace (redTable[1]); // 17
		```</haxe_doc>
	</getRedTable>
	<__toFlashColorTransform set="method" line="308" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<c path="flash.geom.ColorTransform"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__toFlashColorTransform>
	<get_alphaMultiplier get="inline" set="null" line="318" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_alphaMultiplier>
	<set_alphaMultiplier get="inline" set="null" line="323" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_alphaMultiplier>
	<get_alphaOffset get="inline" set="null" line="328" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_alphaOffset>
	<set_alphaOffset get="inline" set="null" line="333" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_alphaOffset>
	<get_blueMultiplier get="inline" set="null" line="338" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_blueMultiplier>
	<set_blueMultiplier get="inline" set="null" line="343" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_blueMultiplier>
	<get_blueOffset get="inline" set="null" line="348" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_blueOffset>
	<set_blueOffset get="inline" set="null" line="353" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_blueOffset>
	<get_color set="method" line="358" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_color>
	<set_color set="method" line="363" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_color>
	<get_greenMultiplier get="inline" set="null" line="376" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_greenMultiplier>
	<set_greenMultiplier get="inline" set="null" line="381" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_greenMultiplier>
	<get_greenOffset get="inline" set="null" line="386" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_greenOffset>
	<set_greenOffset get="inline" set="null" line="391" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_greenOffset>
	<get_redMultiplier get="inline" set="null" line="396" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_redMultiplier>
	<set_redMultiplier get="inline" set="null" line="401" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_redMultiplier>
	<get_redOffset get="inline" set="null" line="406" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_redOffset>
	<set_redOffset get="inline" set="null" line="411" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_redOffset>
	<get public="1" set="method" line="416" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="421" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix" final="1">
		<__alphaTable static="1"><x path="lime.utils.UInt8Array"/></__alphaTable>
		<__blueTable static="1"><x path="lime.utils.UInt8Array"/></__blueTable>
		<__greenTable static="1"><x path="lime.utils.UInt8Array"/></__greenTable>
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="20" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
		</__identity>
		<__redTable static="1"><x path="lime.utils.UInt8Array"/></__redTable>
		<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current alpha multiplication value (default is 1.0)</haxe_doc>
		</alphaMultiplier>
		<alphaOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current alpha offset value (default is 0)</haxe_doc>
		</alphaOffset>
		<blueMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current blue multiplication value (default is 1.0)</haxe_doc>
		</blueMultiplier>
		<blueOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current blue offset value (default is 0)</haxe_doc>
		</blueOffset>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets or sets a color offset for tinting.

		This will change the red, green and blue multipliers
		to zero, and affect the red, green and blue offset
		values.</haxe_doc>
		</color>
		<greenMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current green multiplication value (default is 1.0)</haxe_doc>
		</greenMultiplier>
		<greenOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current green offset value (default is 0)</haxe_doc>
		</greenOffset>
		<redMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current red multiplication value (default is 1.0)</haxe_doc>
		</redMultiplier>
		<redOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>The current red offset value (default is 0)</haxe_doc>
		</redOffset>
		<_new public="1" set="method" line="78" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new `ColorMatrix` instance
		@param	data	(Optional) Initial `Float32Array` data to use</haxe_doc>
		</_new>
		<clone public="1" set="method" line="94" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a duplicate of the current `ColorMatrix` instance
		@return	A new `ColorMatrix` instance</haxe_doc>
		</clone>
		<concat public="1" set="method" line="103" static="1">
			<f a="this:second">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Adds the color multipliers from a second `ColorMatrix` to the current one
		@param	second	The `ColorMatrix` to `concat` to the current one</haxe_doc>
		</concat>
		<copyFrom public="1" set="method" line="115" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `ColorMatrix` values to the same as another one
		@param	other	The `ColorMatrix` to copy from</haxe_doc>
		</copyFrom>
		<identity public="1" set="method" line="123" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Resets to default values</haxe_doc>
		</identity>
		<getAlphaTable public="1" set="method" line="167" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		alpha values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `alphaMultipler` and `alphaOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.alphaOffset = 12;

		var alphaTable = colorMatrix.getAlphaTable ();
		trace (alphaTable[0]); // 12
		trace (alphaTable[1]); // 13
		```</haxe_doc>
		</getAlphaTable>
		<getBlueTable public="1" set="method" line="208" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		blue values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `blueMultiplier` and `blueOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.blueOffset = 16;

		var blueTable = colorMatrix.getBlueTable ();
		trace (blueTable[0]); // 16
		trace (blueTable[1]); // 17
		```</haxe_doc>
		</getBlueTable>
		<getGreenTable public="1" set="method" line="248" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		green values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `greenMultiplier` and `greenOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.greenOffset = 16;

		var greenTable = colorMatrix.getGreenTable ();
		trace (greenTable[0]); // 16
		trace (greenTable[1]); // 17
		```</haxe_doc>
		</getGreenTable>
		<getRedTable public="1" set="method" line="288" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns a reference to a `UInt8Array` table for transforming
		red values using the current matrix.

		The table is 256 values in length, and includes values based
		on the `redMultiplier` and `redOffset` values of the matrix.

		The values are constrained within 0 and 255.

		For example:

		```haxe
		var colorMatrix = new ColorMatrix ();
		colorMatrix.redOffset = 16;

		var redTable = colorMatrix.getRedTable ();
		trace (redTable[0]); // 16
		trace (redTable[1]); // 17
		```</haxe_doc>
		</getRedTable>
		<__toFlashColorTransform set="method" line="308" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<c path="flash.geom.ColorTransform"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__toFlashColorTransform>
		<get_alphaMultiplier get="inline" set="null" line="318" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_alphaMultiplier>
		<set_alphaMultiplier get="inline" set="null" line="323" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_alphaMultiplier>
		<get_alphaOffset get="inline" set="null" line="328" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_alphaOffset>
		<set_alphaOffset get="inline" set="null" line="333" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_alphaOffset>
		<get_blueMultiplier get="inline" set="null" line="338" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_blueMultiplier>
		<set_blueMultiplier get="inline" set="null" line="343" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_blueMultiplier>
		<get_blueOffset get="inline" set="null" line="348" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_blueOffset>
		<set_blueOffset get="inline" set="null" line="353" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_blueOffset>
		<get_color set="method" line="358" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_color>
		<set_color set="method" line="363" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_color>
		<get_greenMultiplier get="inline" set="null" line="376" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_greenMultiplier>
		<set_greenMultiplier get="inline" set="null" line="381" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_greenMultiplier>
		<get_greenOffset get="inline" set="null" line="386" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_greenOffset>
		<set_greenOffset get="inline" set="null" line="391" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_greenOffset>
		<get_redMultiplier get="inline" set="null" line="396" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_redMultiplier>
		<set_redMultiplier get="inline" set="null" line="401" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_redMultiplier>
		<get_redOffset get="inline" set="null" line="406" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_redOffset>
		<set_redOffset get="inline" set="null" line="411" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_redOffset>
		<get public="1" set="method" line="416" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="421" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.math.Matrix3" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Matrix3.hx">
		<__identity expr="new Matrix3()" line="56" static="1">
			<c path="lime.math.Matrix3"/>
			<meta><m n=":value"><e>new Matrix3()</e></m></meta>
		</__identity>
		<a public="1">
			<x path="Float"/>
			<haxe_doc>The matrix a component, used in scaling and skewing (default is 1)</haxe_doc>
		</a>
		<b public="1">
			<x path="Float"/>
			<haxe_doc>The matrix b component, used in rotation and skewing (default is 0)</haxe_doc>
		</b>
		<c public="1">
			<x path="Float"/>
			<haxe_doc>The matrix c component, used in rotation and skewing (default is 0)</haxe_doc>
		</c>
		<d public="1">
			<x path="Float"/>
			<haxe_doc>The matrix d component, used in scaling and skewing (default is 1)</haxe_doc>
		</d>
		<tx public="1">
			<x path="Float"/>
			<haxe_doc>The matrix tx component, used in translation (default is 0)</haxe_doc>
		</tx>
		<ty public="1">
			<x path="Float"/>
			<haxe_doc>The matrix ty component, used in translation (default is 0)</haxe_doc>
		</ty>
		<clone public="1" get="inline" set="null" line="81">
			<f a=""><c path="lime.math.Matrix3"/></f>
			<haxe_doc>Creates a duplicate of the current `Matrix3`
		@return	A duplicate `Matrix3` instance</haxe_doc>
		</clone>
		<concat public="1" set="method" line="92">
			<f a="m">
				<c path="lime.math.Matrix3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Concatenates the values of a second matrix to the current
		`Matrix3`, combining the effects of both. This is the same
		as matrix multiplication. The second matrix is not modified.
		@param	m	A second `Matrix3` to concatenate to the current instance</haxe_doc>
		</concat>
		<copyColumnFrom public="1" set="method" line="114">
			<f a="column:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the `x` and `y` components from a `Vector4` instance
		to the `a`/`c`, `b`/`d` or the `tx`/`ty` column of the current
		matrix
		@param	column	The column to copy into (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="143">
			<f a="column:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies a column of the current matrix into a `Vector4`
		instance. The `w` value will not be modified.
		@param	column	The column to copy from (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy to</haxe_doc>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="174">
			<f a="sourceMatrix3">
				<c path="lime.math.Matrix3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the values of another `Matrix3` and
		applies it to the current instance
		@param	sourceMatrix3	The `Matrix3` to copy from</haxe_doc>
		</copyFrom>
		<copyRowFrom public="1" set="method" line="190">
			<f a="row:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the values of a `Vector4` instance into a row
		of the current matrix
		@param	row	The row to copy into (0 or 1)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyRowFrom>
		<copyRowTo public="1" set="method" line="216">
			<f a="row:vector4">
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies a row of the current matrix into a `Vector4`
		instance. The `w` value will not be modified.
		@param	row	The row to copy into (0, 1 or 2)
		@param	vector4	The `Vector4` instance to copy from</haxe_doc>
		</copyRowTo>
		<createBox public="1" set="method" line="251">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
			<haxe_doc>Applies a two-dimensional transformation to the current matrix.

		This is the same as calling `identity()`, `rotate()`, `scale()`
		then `translate()` with these values.
		@param	scaleX	An x scale transformation value
		@param	scaleY	A y scale transformation value
		@param	rotation (Optional) A rotation value (default is 0)
		@param	tx	(Optional) A translate x value (default is 0)
		@param	ty	(Optional) A translate y value (default is 0)</haxe_doc>
		</createBox>
		<createGradientBox public="1" set="method" line="284">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
			<haxe_doc>Creates a matrix to use for a linear gradient fill
		@param	width	The width of the gradient fill
		@param	height	The height of the gradient fill
		@param	rotation	(Optional) A rotation for the gradient fill (default is 0)
		@param	tx	(Optional) An x offset for the gradient fill (default is 0)
		@param	ty	(Optional) A y offset for the gradient fill (default is 0)
		@return	A new `Matrix` instance</haxe_doc>
		</createGradientBox>
		<equals public="1" set="method" line="314">
			<f a="matrix3">
				<c path="lime.math.Matrix3"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Check if two matrices have the same values
		@return	Whether both matrices are equal</haxe_doc>
		</equals>
		<deltaTransformVector public="1" set="method" line="325">
			<f a="Vector2:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Vector2` instance by the current matrix,
		without considering the `tx` and `ty` values of the matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	A new `Vector2` instance representing the transformed values</haxe_doc>
		</deltaTransformVector>
		<identity public="1" set="method" line="336">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Resets the matrix to default identity values</haxe_doc>
		</identity>
		<invert public="1" set="method" line="350">
			<f a=""><c path="lime.math.Matrix3"/></f>
			<haxe_doc>Inverts the values of the current matrix
		@return	The current matrix instance</haxe_doc>
		</invert>
		<rotate public="1" set="method" line="387">
			<f a="theta">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies rotation to the current matrix
		@param	theta	A rotation value in degrees</haxe_doc>
		</rotate>
		<scale public="1" set="method" line="424">
			<f a="sx:sy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the current matrix
		@param	sx	The x scale to apply
		@param	sy	The y scale to apply</haxe_doc>
		</scale>
		<setRotation get="inline" set="null" line="443">
			<f a="theta:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ scale : 1 }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</setRotation>
		<setTo public="1" get="inline" set="null" line="460">
			<f a="a:b:c:d:tx:ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the values of the current matrix
		@param	a	The new matrix a value
		@param	b	The new matrix b value
		@param	c	The new matrix c value
		@param	d	The new matrix d value
		@param	tx	The new matrix tx value
		@param	ty	The new matrix ty value</haxe_doc>
		</setTo>
		<to3DString public="1" get="inline" set="null" line="470">
			<f a="?roundPixels" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ roundPixels : false }</e></m>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</to3DString>
		<toString public="1" get="inline" set="null" line="504">
			<f a=""><c path="String"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</toString>
		<transformRect public="1" set="method" line="517">
			<f a="rect:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Rectangle` instance by the current matrix
		and returns `Rectangle` with the bounds of the transformed
		rectangle.
		@param	transform	A `Matrix3` instance to transform by
		@param	result	(Optional) A `Rectangle` instance to use for the result
		@return	A `Rectangle` represented the transformed bounds</haxe_doc>
		</transformRect>
		<transformVector public="1" set="method" line="559">
			<f a="pos:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Transforms a `Vector2` instance by the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	A new `Vector2` instance representing the transformed values</haxe_doc>
		</transformVector>
		<translate public="1" get="inline" set="null" line="572">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adjusts the `tx` and `ty` of the current matrix
		@param	dx	The x amount to translate
		@param	dy	The y amount to translate</haxe_doc>
		</translate>
		<new public="1" set="method" line="67">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
			<haxe_doc>Creates a new `Matrix` instance
		@param	a	(Optional) An initial a component value (default is 1)
		@param	b	(Optional) An initial b component value (default is 0)
		@param	c	(Optional) An initial c component value (default is 0)
		@param	d	(Optional) An initial d component value (default is 1)
		@param	tx	(Optional) An initial tx component value (default is 0)
		@param	ty	(Optional) An initial ty component value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>`Matrix3` is a 3x3 transformation matrix particularly useful for
	two-dimensional transformation. It can be used for rotation, scale
	and skewing of a two-dimensional object.

	Although a 3x3 matrix is represented, configurable values can be
	considered as a 3x2 matrix:

	```
	[ a, c, tx ]
	[ c, d, ty ]
	[ 0, 0,  1 ]
	```</haxe_doc>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.math.Matrix4" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Matrix4.hx">
		<from>
			<icast><x path="lime.utils.Float32Array"/></icast>
			<icast field="fromMatrix3"><c path="lime.math.Matrix3"/></icast>
		</from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<haxe_doc>`Matrix4` is a 4x4 matrix, useful for 3D calculations</haxe_doc>
		<impl><class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4" final="1">
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="11" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
	</__identity>
	<determinant public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets the determinant of the matrix</haxe_doc>
	</determinant>
	<position public="1" get="accessor" set="accessor" static="1">
		<c path="lime.math.Vector4"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Gets or sets the position value of this matrix</haxe_doc>
	</position>
	<_new public="1" set="method" line="27" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new matrix instance
		@param	data	(Optional) A `Float32Array` of 16 values to use for this matrix</haxe_doc>
	</_new>
	<append public="1" set="method" line="43" static="1">
		<f a="this:lhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Appends a second matrix by multiplying its values against the current one
		@param	lhs	A second matrix instance</haxe_doc>
	</append>
	<appendRotation public="1" set="method" line="105" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Appends rotation to the current matrix
		@param	degrees	A rotation value (in degrees)
		@param	axis	The coordinate position of the rotation axis
		@param	pivotPoint	(Optional) A pivot point to use in the rotation</haxe_doc>
	</appendRotation>
	<appendScale public="1" set="method" line="124" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Appends a scale value to the current matrix
		@param	xScale	The x scale to append
		@param	yScale	The y scale to append
		@param	zScale	The z scale to append</haxe_doc>
	</appendScale>
	<appendTranslation public="1" set="method" line="137" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Increases the position/translation of the current matrix
		@param	x	The x amount to offset the current position
		@param	y	The y amount to offset the current position
		@param	z	The z amount to offset the current position</haxe_doc>
	</appendTranslation>
	<clone public="1" set="method" line="148" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a duplicate of the current `Matrix4`
		@return	A new `Matrix4` with the same values as the current matrix</haxe_doc>
	</clone>
	<copyColumnFrom public="1" set="method" line="158" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a column of data from a `Vector4` instance into the values of this matrix
		@param	column	The column to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
	</copyColumnFrom>
	<copyColumnTo public="1" set="method" line="196" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a column of data from the current matrix into a `Vector4` instance
		@param	column	The column to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
	</copyColumnTo>
	<copyFrom public="1" set="method" line="233" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies the values of another `Matrix4` into the current matrix
		@param	other	A `Matrix4` instance to copy from</haxe_doc>
	</copyFrom>
	<copyRowFrom public="1" set="method" line="243" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a row of data from a `Vector4` instance into the values of this matrix
		@param	row	The row to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
	</copyRowFrom>
	<copyRowTo public="1" set="method" line="281" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Copies a row of data from the current matrix into a `Vector4` instance
		@param	column	The row to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
	</copyRowTo>
	<create2D public="1" set="method" line="323" static="1">
		<f a="this:a:b:c:d:?tx:?ty" v=":::::0:0">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ ty : 0, tx : 0 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Resets the current matrix using two-dimensional transform values
		@param	a	A two-dimensional matrix a value
		@param	b	A two-dimensional matrix b value
		@param	c	A two-dimensional matrix c value
		@param	d	A two-dimensional matrix d value
		@param	tx	(Optional) A two-dimensional matrix tx value (default is 0)
		@param	ty	(Optional) A two-dimensional matrix ty value (default is 0)</haxe_doc>
	</create2D>
	<createOrtho public="1" set="method" line="355" static="1">
		<f a="this:left:right:bottom:top:zNear:zFar">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Initializes this matrix with values for an orthographic projection, useful in rendering
		@param	left	The left (or x0) coordinate for the projection
		@param	right	The right (or x1) coordinate for the projection
		@param	bottom	The bottom (or y0) coordinate for the projection
		@param	top	The top (or y1) coordinate for the projection
		@param	zNear	The near depth-clipping plane position
		@param	zFar	The far depth-clipping plane position</haxe_doc>
	</createOrtho>
	<deltaTransformVector public="1" set="method" line="485" static="1">
		<f a="this:v:?result" v="::null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":value"><e>{ result : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
	</deltaTransformVector>
	<fromMatrix3 public="1" set="method" line="495" static="1">
		<f a="matrix3">
			<c path="lime.math.Matrix3"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromMatrix3>
	<identity public="1" set="method" line="505" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Resets the current matrix using default identity values</haxe_doc>
	</identity>
	<interpolate public="1" set="method" line="533" static="1">
		<f a="thisMat:toMat:percent:?result" v=":::null">
			<x path="lime.math.Matrix4"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="lime.math.Matrix4"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":value"><e>{ result : null }</e></m></meta>
		<haxe_doc>Interpolates from one `Matrix4` instance to another, given a percentage between the two
		@param	thisMat	The first `Matrix4` object to start from
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percent	The percentage value to interpolate by
		@param	result	(Optional) A `Matrix4` instance to use when returning the result
		@return	A `Matrix4` with the resulting value</haxe_doc>
	</interpolate>
	<interpolateTo public="1" set="method" line="550" static="1">
		<f a="this:toMat:percent">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Interpolates the current matrix toward another matrix, resetting the values of the current matrix
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percetn	The percentage value to interpolate by</haxe_doc>
	</interpolateTo>
	<invert public="1" set="method" line="562" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Attempts to invert the current matrix, so long as the determinant is greater than zero
		@return	Whether the `invert` operation was successful</haxe_doc>
	</invert>
	<pointAt public="1" set="method" line="615" static="1">
		<f a="this:pos:?at:?up" v="::null:null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ up : null, at : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Sets the matrix values as a transformation orientated toward a certain vector position
		@param	pos	A target vector position in absolute coordinates
		@param	at	(Optional) A vector relative to this matrix which defines the current direction
		@param	up	(Optional) A vector relative to this matrix which defines the "up" direction</haxe_doc>
	</pointAt>
	<prepend public="1" set="method" line="682" static="1">
		<f a="this:rhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends a right-hand matrix to the current matrix
		@param	rhx	A right-hand `Matrix4` to append</haxe_doc>
	</prepend>
	<prependRotation public="1" set="method" line="744" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Prepends rotation to this matrix
		@param	degrees	The rotation amount in degrees
		@param	axis	The rotation axis
		@param	pivotPoint	(Optional) A pivot point for the rotation</haxe_doc>
	</prependRotation>
	<prependScale public="1" set="method" line="763" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends scale to this matrix
		@param	xScale	An x scale value
		@param	yScale	A y scale value
		@param	zScale	A z scale value</haxe_doc>
	</prependScale>
	<prependTranslation public="1" set="method" line="776" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Prepends translation values to this matrix
		@param	x	An x translation value
		@param	y	A y translation value
		@param	z	A z translation value</haxe_doc>
	</prependTranslation>
	<transformVector public="1" set="method" line="870" static="1">
		<f a="this:v:?result" v="::null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":value"><e>{ result : null }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Transforms a `Vector4` instance using the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	The resulting `Vector4` instance</haxe_doc>
	</transformVector>
	<transformVectors public="1" set="method" line="886" static="1">
		<f a="this:ain:aout">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Transforms a series of [x, y, z] value pairs at once
		@param	ain	An input `Float32Array` to transform
		@param	aout	An output `Float32Array` to write to</haxe_doc>
	</transformVectors>
	<transpose public="1" set="method" line="908" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Transposes the current matrix</haxe_doc>
	</transpose>
	<__getAxisRotation set="method" line="918" static="1">
		<f a="this:x:y:z:degrees">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__getAxisRotation>
	<__swap get="inline" set="null" line="948" static="1">
		<f a="this:a:b">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</__swap>
	<get_determinant set="method" line="956" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_determinant>
	<get_position set="method" line="966" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_position>
	<set_position set="method" line="971" static="1">
		<f a="this:val">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_position>
	<get public="1" set="method" line="979" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="984" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4" final="1">
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="11" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
		</__identity>
		<determinant public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets the determinant of the matrix</haxe_doc>
		</determinant>
		<position public="1" get="accessor" set="accessor" static="1">
			<c path="lime.math.Vector4"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Gets or sets the position value of this matrix</haxe_doc>
		</position>
		<_new public="1" set="method" line="27" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new matrix instance
		@param	data	(Optional) A `Float32Array` of 16 values to use for this matrix</haxe_doc>
		</_new>
		<append public="1" set="method" line="43" static="1">
			<f a="this:lhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Appends a second matrix by multiplying its values against the current one
		@param	lhs	A second matrix instance</haxe_doc>
		</append>
		<appendRotation public="1" set="method" line="105" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Appends rotation to the current matrix
		@param	degrees	A rotation value (in degrees)
		@param	axis	The coordinate position of the rotation axis
		@param	pivotPoint	(Optional) A pivot point to use in the rotation</haxe_doc>
		</appendRotation>
		<appendScale public="1" set="method" line="124" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Appends a scale value to the current matrix
		@param	xScale	The x scale to append
		@param	yScale	The y scale to append
		@param	zScale	The z scale to append</haxe_doc>
		</appendScale>
		<appendTranslation public="1" set="method" line="137" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Increases the position/translation of the current matrix
		@param	x	The x amount to offset the current position
		@param	y	The y amount to offset the current position
		@param	z	The z amount to offset the current position</haxe_doc>
		</appendTranslation>
		<clone public="1" set="method" line="148" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a duplicate of the current `Matrix4`
		@return	A new `Matrix4` with the same values as the current matrix</haxe_doc>
		</clone>
		<copyColumnFrom public="1" set="method" line="158" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a column of data from a `Vector4` instance into the values of this matrix
		@param	column	The column to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="196" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a column of data from the current matrix into a `Vector4` instance
		@param	column	The column to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="233" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies the values of another `Matrix4` into the current matrix
		@param	other	A `Matrix4` instance to copy from</haxe_doc>
		</copyFrom>
		<copyRowFrom public="1" set="method" line="243" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a row of data from a `Vector4` instance into the values of this matrix
		@param	row	The row to copy into (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy from</haxe_doc>
		</copyRowFrom>
		<copyRowTo public="1" set="method" line="281" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Copies a row of data from the current matrix into a `Vector4` instance
		@param	column	The row to copy (0, 1, 2 or 3)
		@param	vector	The `Vector4` copy to</haxe_doc>
		</copyRowTo>
		<create2D public="1" set="method" line="323" static="1">
			<f a="this:a:b:c:d:?tx:?ty" v=":::::0:0">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ ty : 0, tx : 0 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Resets the current matrix using two-dimensional transform values
		@param	a	A two-dimensional matrix a value
		@param	b	A two-dimensional matrix b value
		@param	c	A two-dimensional matrix c value
		@param	d	A two-dimensional matrix d value
		@param	tx	(Optional) A two-dimensional matrix tx value (default is 0)
		@param	ty	(Optional) A two-dimensional matrix ty value (default is 0)</haxe_doc>
		</create2D>
		<createOrtho public="1" set="method" line="355" static="1">
			<f a="this:left:right:bottom:top:zNear:zFar">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Initializes this matrix with values for an orthographic projection, useful in rendering
		@param	left	The left (or x0) coordinate for the projection
		@param	right	The right (or x1) coordinate for the projection
		@param	bottom	The bottom (or y0) coordinate for the projection
		@param	top	The top (or y1) coordinate for the projection
		@param	zNear	The near depth-clipping plane position
		@param	zFar	The far depth-clipping plane position</haxe_doc>
		</createOrtho>
		<deltaTransformVector public="1" set="method" line="485" static="1">
			<f a="this:v:?result" v="::null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":value"><e>{ result : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
		</deltaTransformVector>
		<fromMatrix3 public="1" set="method" line="495" static="1">
			<f a="matrix3">
				<c path="lime.math.Matrix3"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromMatrix3>
		<identity public="1" set="method" line="505" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Resets the current matrix using default identity values</haxe_doc>
		</identity>
		<interpolate public="1" set="method" line="533" static="1">
			<f a="thisMat:toMat:percent:?result" v=":::null">
				<x path="lime.math.Matrix4"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="lime.math.Matrix4"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Interpolates from one `Matrix4` instance to another, given a percentage between the two
		@param	thisMat	The first `Matrix4` object to start from
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percent	The percentage value to interpolate by
		@param	result	(Optional) A `Matrix4` instance to use when returning the result
		@return	A `Matrix4` with the resulting value</haxe_doc>
		</interpolate>
		<interpolateTo public="1" set="method" line="550" static="1">
			<f a="this:toMat:percent">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Interpolates the current matrix toward another matrix, resetting the values of the current matrix
		@param	toMat	The second `Matrix4` object to interpolate toward
		@param	percetn	The percentage value to interpolate by</haxe_doc>
		</interpolateTo>
		<invert public="1" set="method" line="562" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Attempts to invert the current matrix, so long as the determinant is greater than zero
		@return	Whether the `invert` operation was successful</haxe_doc>
		</invert>
		<pointAt public="1" set="method" line="615" static="1">
			<f a="this:pos:?at:?up" v="::null:null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ up : null, at : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Sets the matrix values as a transformation orientated toward a certain vector position
		@param	pos	A target vector position in absolute coordinates
		@param	at	(Optional) A vector relative to this matrix which defines the current direction
		@param	up	(Optional) A vector relative to this matrix which defines the "up" direction</haxe_doc>
		</pointAt>
		<prepend public="1" set="method" line="682" static="1">
			<f a="this:rhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends a right-hand matrix to the current matrix
		@param	rhx	A right-hand `Matrix4` to append</haxe_doc>
		</prepend>
		<prependRotation public="1" set="method" line="744" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Prepends rotation to this matrix
		@param	degrees	The rotation amount in degrees
		@param	axis	The rotation axis
		@param	pivotPoint	(Optional) A pivot point for the rotation</haxe_doc>
		</prependRotation>
		<prependScale public="1" set="method" line="763" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends scale to this matrix
		@param	xScale	An x scale value
		@param	yScale	A y scale value
		@param	zScale	A z scale value</haxe_doc>
		</prependScale>
		<prependTranslation public="1" set="method" line="776" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Prepends translation values to this matrix
		@param	x	An x translation value
		@param	y	A y translation value
		@param	z	A z translation value</haxe_doc>
		</prependTranslation>
		<transformVector public="1" set="method" line="870" static="1">
			<f a="this:v:?result" v="::null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":value"><e>{ result : null }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Transforms a `Vector4` instance using the current matrix
		@param	result	(Optional) An existing `Vector2` instance to fill with the result
		@return	The resulting `Vector4` instance</haxe_doc>
		</transformVector>
		<transformVectors public="1" set="method" line="886" static="1">
			<f a="this:ain:aout">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Transforms a series of [x, y, z] value pairs at once
		@param	ain	An input `Float32Array` to transform
		@param	aout	An output `Float32Array` to write to</haxe_doc>
		</transformVectors>
		<transpose public="1" set="method" line="908" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Transposes the current matrix</haxe_doc>
		</transpose>
		<__getAxisRotation set="method" line="918" static="1">
			<f a="this:x:y:z:degrees">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__getAxisRotation>
		<__swap get="inline" set="null" line="948" static="1">
			<f a="this:a:b">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</__swap>
		<get_determinant set="method" line="956" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_determinant>
		<get_position set="method" line="966" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_position>
		<set_position set="method" line="971" static="1">
			<f a="this:val">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_position>
		<get public="1" set="method" line="979" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="984" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<abstract path="lime.math.RGBA" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/RGBA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.ARGB"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.BGRA"/></icast>
		</from>
		<this><x path="UInt"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>A utility for storing, accessing and converting colors in an RGBA
	(red, green, blue, alpha) color format.

	```haxe
	var color:RGBA = 0x883300FF;
	trace (color.r); // 0x88
	trace (color.g); // 0x33
	trace (color.b); // 0x00
	trace (color.a); // 0xFF

	var convert:ARGB = color; // 0xFF883300
	```</haxe_doc>
		<meta>
			<m n=":allow"><e>lime.math</e></m>
			<m n=":transitive"/>
		</meta>
		<impl><class path="lime.math._RGBA.RGBA_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/RGBA.hx" private="1" module="lime.math.RGBA" final="1">
	<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
	<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the alpha component of the color</haxe_doc>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the blue component of the color</haxe_doc>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the green component of the color</haxe_doc>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Accesses the red component of the color</haxe_doc>
	</r>
	<_new public="1" get="inline" set="null" line="104" static="1">
		<f a="?rgba" v="0">
			<x path="Int"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta>
			<m n=":value"><e>{ rgba : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
		<haxe_doc>Creates a new RGBA instance
		@param	rgba	(Optional) An RGBA color value</haxe_doc>
	</_new>
	<create public="1" get="inline" set="null" line="117" static="1">
		<f a="r:g:b:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.math.RGBA"/>
		</f>
		<haxe_doc>Creates a new RGBA instance from component values
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@param	a	An alpha component value
		@return	A new RGBA instance</haxe_doc>
	</create>
	<multiplyAlpha public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="150" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Reads a value from a `UInt8Array` into the current `RGBA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</readUInt8>
	<set public="1" get="inline" set="null" line="177" static="1">
		<f a="this:r:g:b:a">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Sets the current `RGBA` color to new component values
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set
		@param	a	The alpha component value to set</haxe_doc>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="185" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="201" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="UInt"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>Writes the current `RGBA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="230" static="1">
		<f a="argb">
			<x path="lime.math.ARGB"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromBGRA get="inline" set="null" line="235" static="1">
		<f a="bgra">
			<x path="lime.math.BGRA"/>
			<x path="lime.math.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<get_a get="inline" set="null" line="241" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_a>
	<set_a get="inline" set="null" line="246" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_a>
	<get_b get="inline" set="null" line="252" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_b>
	<set_b get="inline" set="null" line="257" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_b>
	<get_g get="inline" set="null" line="263" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_g>
	<set_g get="inline" set="null" line="268" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_g>
	<get_r get="inline" set="null" line="274" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_r>
	<set_r get="inline" set="null" line="279" static="1">
		<f a="this:value">
			<x path="UInt"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_r>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":allow"><e>lime.math</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils.ArrayBufferView" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx">
		<type public="1" expr="TypedArrayType.None">
			<x path="lime.utils.TypedArrayType"/>
			<meta><m n=":value"><e>TypedArrayType.None</e></m></meta>
		</type>
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<length public="1"><x path="Int"/></length>
		<bytesPerElement set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bytesPerElement>
		<initTypedArray get="inline" set="null" line="45">
			<f a="view">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initTypedArray>
		<initBuffer get="inline" set="null" line="76">
			<f a="in_buffer:?in_byteOffset:?len" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta>
				<m n=":value"><e>{ len : null, in_byteOffset : 0 }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</initBuffer>
		<initArray params="T" get="inline" set="null" line="112">
			<f a="array">
				<c path="Array"><c path="initArray.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initArray>
		<set public="1" params="T" get="inline" set="null" line="129">
			<f a="?view:?array:?offset" v="null:null:0">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="Array"><c path="set.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0, array : null, view : null }</e></m></meta>
		</set>
		<cloneBuffer get="inline" set="null" line="149">
			<f a="src:?srcByteOffset" v=":0">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ srcByteOffset : 0 }</e></m></meta>
		</cloneBuffer>
		<subarray params="T_subarray" get="inline" set="null" line="163">
			<f a="begin:?end" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="subarray.T_subarray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":generic"/>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</subarray>
		<bytesForType get="inline" set="null" line="208"><f a="type">
	<x path="lime.utils.TypedArrayType"/>
	<x path="Int"/>
</f></bytesForType>
		<toString get="inline" set="null" line="246"><f a=""><c path="String"/></f></toString>
		<toByteLength get="inline" set="null" line="268"><f a="elemCount">
	<x path="Int"/>
	<x path="Int"/>
</f></toByteLength>
		<copyFromArray set="method" line="278">
			<f a="array:?offset" v=":0">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</copyFromArray>
		<new get="inline" set="null" line="20">
			<f a="?elements:in_type" v="null:">
				<x path="Int"/>
				<x path="lime.utils.TypedArrayType"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ elements : null }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.utils.TAError" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<RangeError/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="lime.math._RGBA.RGBA_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/RGBA.hx" private="1" module="lime.math.RGBA" final="1">
		<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
		<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the alpha component of the color</haxe_doc>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the blue component of the color</haxe_doc>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the green component of the color</haxe_doc>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Accesses the red component of the color</haxe_doc>
		</r>
		<_new public="1" get="inline" set="null" line="104" static="1">
			<f a="?rgba" v="0">
				<x path="Int"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta>
				<m n=":value"><e>{ rgba : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>Creates a new RGBA instance
		@param	rgba	(Optional) An RGBA color value</haxe_doc>
		</_new>
		<create public="1" get="inline" set="null" line="117" static="1">
			<f a="r:g:b:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.math.RGBA"/>
			</f>
			<haxe_doc>Creates a new RGBA instance from component values
		@param	r	A red component value
		@param	g	A green component value
		@param	b	A blue component value
		@param	a	An alpha component value
		@return	A new RGBA instance</haxe_doc>
		</create>
		<multiplyAlpha public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Multiplies the red, green and blue components by the current alpha component</haxe_doc>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="150" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Reads a value from a `UInt8Array` into the current `RGBA` color
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to read
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</readUInt8>
		<set public="1" get="inline" set="null" line="177" static="1">
			<f a="this:r:g:b:a">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Sets the current `RGBA` color to new component values
		@param	r	The red component value to set
		@param	g	The green component value to set
		@param	b	The blue component vlaue to set
		@param	a	The alpha component value to set</haxe_doc>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="185" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Divides the current red, green and blue components by the alpha component</haxe_doc>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="201" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="UInt"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>Writes the current `RGBA` color into a `UInt8Array`
		@param	data	A `UInt8Array` instance
		@param	offset	An offset into the `UInt8Array` to write
		@param	format	(Optional) The `PixelFormat` represented by the `UInt8Array` data
		@param	premultiplied	(Optional) Whether the data is stored in premultiplied alpha format</haxe_doc>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="230" static="1">
			<f a="argb">
				<x path="lime.math.ARGB"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromBGRA get="inline" set="null" line="235" static="1">
			<f a="bgra">
				<x path="lime.math.BGRA"/>
				<x path="lime.math.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<get_a get="inline" set="null" line="241" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_a>
		<set_a get="inline" set="null" line="246" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_a>
		<get_b get="inline" set="null" line="252" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_b>
		<set_b get="inline" set="null" line="257" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_b>
		<get_g get="inline" set="null" line="263" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_g>
		<set_g get="inline" set="null" line="268" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_g>
		<get_r get="inline" set="null" line="274" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_r>
		<set_r get="inline" set="null" line="279" static="1">
			<f a="this:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_r>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>lime.math</e></m>
		</meta>
	</class>
	<class path="lime.math.Rectangle" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the bottom (y + height) value of the `Rectangle`</haxe_doc>
		</bottom>
		<bottomRight public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the bottom-right (x + width, y + height) as a `Vector2`</haxe_doc>
		</bottomRight>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the height of the rectangle</haxe_doc>
		</height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the left (x) of the rectangle</haxe_doc>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the right (x + width) of the rectangle</haxe_doc>
		</right>
		<size public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the size (width, height) as a `Vector2`</haxe_doc>
		</size>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>Get or set the top (y) of the rectangle</haxe_doc>
		</top>
		<topLeft public="1" get="accessor" set="accessor">
			<c path="lime.math.Vector2"/>
			<haxe_doc>Get or set the top-left (x, y) as a `Vector2`</haxe_doc>
		</topLeft>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the width of the rectangle</haxe_doc>
		</width>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the x of the rectangle</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>Get or set the y of the rectangle</haxe_doc>
		</y>
		<clone public="1" set="method" line="94">
			<f a=""><c path="lime.math.Rectangle"/></f>
			<haxe_doc>Creates a clone of this `Rectangle`
		@return	A new `Rectangle` instance</haxe_doc>
		</clone>
		<contains public="1" set="method" line="105">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains the specified (x, y) point
		@param	x	The x coordinate to test
		@param	y	The y coordinate to test
		@return	Whether the point is contained in the rectangle</haxe_doc>
		</contains>
		<containsPoint public="1" set="method" line="110">
			<f a="point">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"Use containsVector"</e></m>
			</meta>
		</containsPoint>
		<containsRect public="1" set="method" line="122">
			<f a="rect">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains another rectangle
		This will return `false` if the second rectangle only
		overlaps but is not fully contained within the current rectangle
		@param	rect	A second `Rectangle` instance to test
		@return	Whether the `rect` is contained within the current `Rectangle`</haxe_doc>
		</containsRect>
		<containsVector public="1" set="method" line="139">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether this rectangle contains the specified vector
		@param	vector	The vector to test
		@return	Whether the vector is contained in the rectangle</haxe_doc>
		</containsVector>
		<copyFrom public="1" set="method" line="148">
			<f a="sourceRect">
				<c path="lime.math.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the x, y, width and height of another `Rectangle`
		@param	sourceRect	Another `Rectangle` instance</haxe_doc>
		</copyFrom>
		<equals public="1" set="method" line="162">
			<f a="toCompare">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks whether the current `Rectangle` and another
		instance have equal values
		@param	toCompare	Another `Rectangle` to compare with
		@return	Whether both rectangles are not `null` and have equal values</haxe_doc>
		</equals>
		<inflate public="1" set="method" line="173">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increases the size of the current rectangle by
		the given delta x and y values
		@param	dx	A delta x value to increase the size by
		@param	dy	A delta y value to increase the size by</haxe_doc>
		</inflate>
		<inflateVector public="1" set="method" line="186">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increases the size of the current rectangle by
		the given delta vector values
		@param	vector	A delta vector to increase the size by</haxe_doc>
		</inflateVector>
		<intersection public="1" set="method" line="200">
			<f a="toIntersect:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Returns a new rectangle with the area where the current
		`Rectangle` and another `Rectangle` instance overlap.
		If they do not overlap, the returned `Rectangle` will
		be empty
		@param	toIntersect	Another `Rectangle` instance to intersect with
		@param	result	(Optional) A `Rectangle` instance to use for the result
		@return	A `Rectangle` of the intersection area</haxe_doc>
		</intersection>
		<intersects public="1" set="method" line="234">
			<f a="toIntersect">
				<c path="lime.math.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns if the current `Rectangle` overlaps with another instance
		@param	toIntersect	Another `Rectangle` to compare with
		@return	Whether the rectangles intersect</haxe_doc>
		</intersects>
		<isEmpty public="1" set="method" line="254">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[Whether this rectangle is empty
		@return	`true` if the width or height is <= 0]]></haxe_doc>
		</isEmpty>
		<offset public="1" set="method" line="264">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the rectangle by offset x and values
		@param	dx	A delta x value
		@param	dy	A delta y value</haxe_doc>
		</offset>
		<offsetVector public="1" set="method" line="274">
			<f a="vector">
				<c path="lime.math.Vector2"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the rectangle by the values of a `Vector2`
		@param	dx	A delta vector</haxe_doc>
		</offsetVector>
		<setEmpty public="1" set="method" line="283">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Makes this rectangle empty</haxe_doc>
		</setEmpty>
		<setTo public="1" set="method" line="295">
			<f a="xa:ya:widtha:heighta">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the values of this rectangle at once
		@param	xa	A new x value
		@param	ya	A new y value
		@param	widtha	A new width value
		@param	heighta	A new height value</haxe_doc>
		</setTo>
		<union public="1" set="method" line="310">
			<f a="toUnion:?result" v=":null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Combines two rectangles together, returning the
		minimum `Rectangle` that contains both rectangles
		@param	toUnion	A second `Rectangle` to unify
		@param	result	(Optional) A `Rectangle` instance for the result
		@return	A `Rectangle` that contains the dimensions of both rectangles</haxe_doc>
		</union>
		<__toFlashRectangle set="method" line="335">
			<f a=""><t path="flash.geom._Rectangle.FlashRectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toFlashRectangle>
		<get_bottom set="method" line="345">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottom>
		<set_bottom set="method" line="350">
			<f a="b">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottom>
		<get_bottomRight set="method" line="356">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottomRight>
		<set_bottomRight set="method" line="361">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottomRight>
		<get_left set="method" line="368">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_left>
		<set_left set="method" line="373">
			<f a="l">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_left>
		<get_right set="method" line="380">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_right>
		<set_right set="method" line="385">
			<f a="r">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_right>
		<get_size set="method" line="391">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<set_size set="method" line="396">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<get_top set="method" line="403">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_top>
		<set_top set="method" line="408">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_top>
		<get_topLeft set="method" line="415">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_topLeft>
		<set_topLeft set="method" line="420">
			<f a="p">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_topLeft>
		<new public="1" set="method" line="82">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Create a new `Rectangle` instance
		@param	x	(Optional) Initial x value (default is 0)
		@param	y	(Optional) Initial y value (default is 0)
		@param	width	(Optional) Initial width value (default is 0)
		@param	height	(Optional) Initial height value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>The `Rectangle` class provides a simple object for storing
	and manipulating a logical rectangle for calculations</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.math.Vector2" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Vector2.hx">
		<distance public="1" set="method" line="81" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the distance between two `Vector2` points
		@param	pt1	A `Vector2` instance
		@param	pt2	A second `Vector2` instance
		@return	The distance between each `Vector2`</haxe_doc>
		</distance>
		<interpolate public="1" set="method" line="106" static="1">
			<f a="pt1:pt2:f:?result" v=":::null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<x path="Float"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Interpolates between two points, given a specified percentage value
		@param	pt1	A `Vector2` instance
		@param	pt2	A second `Vector2` instance
		@param	f	A percentage value to interpolate
		@param	result	(Optional) A `Vector2` instance to use for the result
		@return	A `Vector2` instance holding the interpolated value</haxe_doc>
		</interpolate>
		<polar public="1" set="method" line="149" static="1">
			<f a="len:angle:?result" v="::null">
				<x path="Float"/>
				<x path="Float"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Converts a polar coordinate to into a cartesian `Vector2` instance
		@param	len	The length of the polar value
		@param	angle	The angle of the polar value
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance in cartesian coordinates</haxe_doc>
		</polar>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Gets the length of this vector from (0, 0) to (x, y)</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Gets the square of the length of this vector, which
		avoids use of `Math.sqrt` for faster performance</haxe_doc>
		</lengthSquared>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x coodinate for this vector</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y coodinate for this vector</haxe_doc>
		</y>
		<add public="1" set="method" line="59">
			<f a="v:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Adds the current vector to a second `Vector2` instance
		and returns the result
		@param	v	A `Vector2` instance to add
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance that combines both vector values</haxe_doc>
		</add>
		<clone public="1" set="method" line="70">
			<f a=""><c path="lime.math.Vector2"/></f>
			<haxe_doc>Clones the current `Vector2`
		@return	A new `Vector2` instance with the same values as the current one</haxe_doc>
		</clone>
		<equals public="1" set="method" line="93">
			<f a="toCompare">
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Whether this `Vector2` has the same values as another instance
		@param	toCompare	A `Vector2` instance to compare against
		@return	Whether the values of each vector are equal</haxe_doc>
		</equals>
		<normalize public="1" set="method" line="117">
			<f a="thickness">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Normalizes this vector between the current length and a set scale value
		@param	thickness	The scaling value. . For example, if the current vector is `(0, 5)` and you normalize it to 1, the normalized value will be `(0, 1)`</haxe_doc>
		</normalize>
		<offset public="1" set="method" line="136">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Offsets the current value of this vector
		@param	dx	An offset x value
		@param	dy	An offset y value</haxe_doc>
		</offset>
		<setTo public="1" get="inline" set="null" line="161">
			<f a="xa:ya">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets this `Vector2` to new values
		@param	xa	An `x` value
		@param	ya	A `y` value</haxe_doc>
		</setTo>
		<subtract public="1" set="method" line="173">
			<f a="v:?result" v=":null">
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Subtracts the current vector from another `Vector2` instance
		@param	v	A `Vector2` instance to subtract from the current vector
		@param	result	(Optional) A `Vector2` instance to store the result
		@return	A `Vector2` instance containing the subtracted values</haxe_doc>
		</subtract>
		<__toFlashPoint set="method" line="180">
			<f a=""><c path="flash.geom.Point"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toFlashPoint>
		<get_length set="method" line="190">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<get_lengthSquared set="method" line="195">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthSquared>
		<new public="1" set="method" line="46">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>Creates a new `Vector` instance
		@param	x	(Optional) An initial `x` value (default is 0)
		@param	y	(Optional) An initial `y` value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>The `Vector2` class can be used for calculating math with
	basic (x, y) coordinates</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.math.Vector4" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/math/Vector4.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the x axis (1, 0, 0)</haxe_doc>
		</X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the y axis (0, 1, 0)</haxe_doc>
		</Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1">
			<c path="lime.math.Vector4"/>
			<haxe_doc>A constant representing the z axis (0, 0, 1)</haxe_doc>
		</Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="94" static="1">
			<f a="a:b">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the angle between two `Vector4` coordinates
		@param	a	A `Vector4` instance
		@param	b	A second `Vector4` instance
		@return	The calculated angle</haxe_doc>
		</angleBetween>
		<distance public="1" get="inline" set="null" line="155" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the distance between two vectors
		@param	pt1	A `Vector4` instance
		@param	pt2	A second `Vector4` instance
		@return	The distance between each vector</haxe_doc>
		</distance>
		<distanceSquared public="1" get="inline" set="null" line="171" static="1">
			<f a="pt1:pt2">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the squared distance between two vectors,
		(avoids the use of `Math.sqrt` for faster performance)
		@param	pt1	A `Vector4` instance
		@param	pt2	A second `Vector4` instance
		@return	The square of the distance between each vector</haxe_doc>
		</distanceSquared>
		<get_X_AXIS get="inline" set="null" line="324" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="329" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="334" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Get the length of this vector</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>Get the squared length of this vector
		(avoiding the use of `Math.sqrt` for faster
		performance)</haxe_doc>
		</lengthSquared>
		<w public="1">
			<x path="Float"/>
			<haxe_doc>The w component value</haxe_doc>
		</w>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>The x component value</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>The y component value</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>The z component value</haxe_doc>
		</z>
		<add public="1" get="inline" set="null" line="81">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Adds two `Vector4` instances together and returns the result
		@param	a	A `Vector4` instance to add to the current one
		@param	result	(Optional) A `Vector4` instance to store the result
		@return	A `Vector4` instance with the added value</haxe_doc>
		</add>
		<clone public="1" get="inline" set="null" line="108">
			<f a=""><c path="lime.math.Vector4"/></f>
			<haxe_doc>Creates a new `Vector4` instance with the same values as the current one
		@return	A new `Vector4` instance with the same values</haxe_doc>
		</clone>
		<copyFrom public="1" get="inline" set="null" line="117">
			<f a="sourceVector4">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the x, y and z component values of another `Vector4` instance
		@param	sourceVector4	A `Vector4` instance to copy from</haxe_doc>
		</copyFrom>
		<crossProduct public="1" get="inline" set="null" line="130">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Performs vector multiplication between this vector and another `Vector4` instance
		@param	a	A `Vector4` instance to multiply by
		@param	result	(Optional) A `Vector4` to use for the result
		@return	A `Vector4` instance with the result</haxe_doc>
		</crossProduct>
		<decrementBy public="1" get="inline" set="null" line="142">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Decrements the x, y and z component values by those in another `Vector4` instance
		@param	a	A `Vector4` instance to decrement the current vector by</haxe_doc>
		</decrementBy>
		<dotProduct public="1" get="inline" set="null" line="185">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calculates the dot product of the current vector with another `Vector4` instance
		@param	a	A `Vector4` instance to use in the dot product
		@return	The calculated dot product value</haxe_doc>
		</dotProduct>
		<equals public="1" get="inline" set="null" line="198">
			<f a="toCompare:?allFour" v=":false">
				<c path="lime.math.Vector4"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
			<haxe_doc>Whether two `Vector4` instances have equal component values.

		Comparing the w component value is optional.
		@param	toCompare	A `Vector4` instance to compare against
		@param	allFour	(Optional) Whether to compare against the w component (default is false)
		@return	Whether both instances have equal values</haxe_doc>
		</equals>
		<incrementBy public="1" get="inline" set="null" line="207">
			<f a="a">
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increments the x, y and z component values by those in a second `Vector4` instance
		@param	a	A `Vector4` instance to increment the current vector by</haxe_doc>
		</incrementBy>
		<nearEquals public="1" get="inline" set="null" line="222">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
			<haxe_doc>Whether two `Vector4` instances have nearly equal component values.
		Comparison is performed within a given tolerance value.
		@param	toCompare	A `Vector4` instance to compare against
		@param	tolerance	A floating point value determining how near the values must be to be considered near equal
		@param	allFour	(Optional) Whether to compare against the w component (default is false)
		@return	Whether both instances have equal values, within the given tolerance</haxe_doc>
		</nearEquals>
		<negate public="1" get="inline" set="null" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Negates the x, y and z values of the current vector
		(multiplying each value by -1)</haxe_doc>
		</negate>
		<normalize public="1" get="inline" set="null" line="245">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Divides the x, y and z component values by the
		length of the vector</haxe_doc>
		</normalize>
		<project public="1" get="inline" set="null" line="263">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Divides the x, y and z component values by the
		w component value</haxe_doc>
		</project>
		<scaleBy public="1" get="inline" set="null" line="274">
			<f a="s">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the x, y and z component values by a scale value
		@param	s	The amount of scale to apply</haxe_doc>
		</scaleBy>
		<setTo public="1" get="inline" set="null" line="287">
			<f a="xa:ya:za">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the x, y and z component values
		@param	xa	An x value
		@param	ya	A y value
		@param	za	A z value</haxe_doc>
		</setTo>
		<subtract public="1" get="inline" set="null" line="301">
			<f a="a:?result" v=":null">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":value"><e>{ result : null }</e></m></meta>
			<haxe_doc>Subtracts the values of a second `Vector4` instance
		from the current one
		@param	a	A second `Vector4` instance to substract
		@param	result	(Optional) A `Vector4` instance to store the result
		@return	A `Vector4` instance containing the subtracted value</haxe_doc>
		</subtract>
		<toString public="1" get="inline" set="null" line="308">
			<f a=""><c path="String"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</toString>
		<get_length get="inline" set="null" line="314">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<get_lengthSquared get="inline" set="null" line="319">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthSquared>
		<new public="1" set="method" line="67">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0., z : 0., y : 0., x : 0. }</e></m></meta>
			<haxe_doc>Creates a new `Vector4` instance
		@param	x	(Optional) An initial x value (default is 0)
		@param	y	(Optional) An initial y value (default is 0)
		@param	z	(Optional) An initial z value (default is 0)
		@param	w	(Optional) An initial w value (default is 0)</haxe_doc>
		</new>
		<haxe_doc>`Vector4` is a vector suitable for three-dimensional
	math, containing (x, y, z, w) components</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.media.AudioBuffer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioBuffer.hx">
		<fromBase64 public="1" set="method" line="69" static="1"><f a="base64String">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromBase64>
		<fromBytes public="1" set="method" line="115" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="148" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></fromFile>
		<fromFiles public="1" set="method" line="199" static="1"><f a="paths">
	<c path="Array"><c path="String"/></c>
	<c path="lime.media.AudioBuffer"/>
</f></fromFiles>
		<fromVorbisFile public="1" set="method" line="240" static="1"><f a="vorbisFile">
	<d/>
	<c path="lime.media.AudioBuffer"/>
</f></fromVorbisFile>
		<loadFromFile public="1" set="method" line="246" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadFromFile>
		<loadFromFiles public="1" set="method" line="310" static="1"><f a="paths">
	<c path="Array"><c path="String"/></c>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadFromFiles>
		<__getCodec set="method" line="342" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></__getCodec>
		<bitsPerSample public="1"><x path="Int"/></bitsPerSample>
		<channels public="1"><x path="Int"/></channels>
		<data public="1"><x path="lime.utils.UInt8Array"/></data>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<__srcAudio>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcAudio>
		<__srcBuffer>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBuffer>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcHowl>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcHowl>
		<__srcSound>
			<c path="flash.media.Sound"/>
			<meta><m n=":noCompletion"/></meta>
		</__srcSound>
		<__srcVorbisFile>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcVorbisFile>
		<dispose public="1" set="method" line="62"><f a=""><x path="Void"/></f></dispose>
		<get_src set="method" line="367">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_src>
		<set_src set="method" line="384">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_src>
		<new public="1" set="method" line="60"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.utils.Assets</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.media.AudioContext" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioContext.hx">
		<custom public="1"><d/></custom>
		<flash public="1" set="null"><c path="lime.media.FlashAudioContext"/></flash>
		<type public="1" set="null"><x path="lime.media.AudioContextType"/></type>
		<new public="1" set="method" line="24">
			<f a="?type" v="null">
				<x path="lime.media.AudioContextType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.media.FlashAudioContext</e></m>
			<m n=":access"><e>lime.media.HTML5AudioContext</e></m>
			<m n=":access"><e>lime.media.OpenALAudioContext</e></m>
			<m n=":access"><e>lime.media.WebAudioContext</e></m>
		</meta>
	</class>
	<abstract path="lime.media.AudioContextType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioContextType.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.media._AudioContextType.AudioContextType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioContextType.hx" private="1" module="lime.media.AudioContextType" extern="1" final="1">
	<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="5" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "flash"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLASH>
	<HTML5 public="1" get="inline" set="null" expr="cast &quot;html5&quot;" line="6" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "html5"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HTML5>
	<OPENAL public="1" get="inline" set="null" expr="cast &quot;openal&quot;" line="7" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "openal"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPENAL>
	<WEB public="1" get="inline" set="null" expr="cast &quot;web&quot;" line="8" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "web"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WEB>
	<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="9" static="1">
		<x path="lime.media.AudioContextType"/>
		<meta>
			<m n=":value"><e>cast "custom"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUSTOM>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.media._AudioContextType.AudioContextType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioContextType.hx" private="1" module="lime.media.AudioContextType" extern="1" final="1">
		<FLASH public="1" get="inline" set="null" expr="cast &quot;flash&quot;" line="5" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "flash"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLASH>
		<HTML5 public="1" get="inline" set="null" expr="cast &quot;html5&quot;" line="6" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "html5"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HTML5>
		<OPENAL public="1" get="inline" set="null" expr="cast &quot;openal&quot;" line="7" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "openal"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPENAL>
		<WEB public="1" get="inline" set="null" expr="cast &quot;web&quot;" line="8" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "web"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WEB>
		<CUSTOM public="1" get="inline" set="null" expr="cast &quot;custom&quot;" line="9" static="1">
			<x path="lime.media.AudioContextType"/>
			<meta>
				<m n=":value"><e>cast "custom"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUSTOM>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.media.AudioManager" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioManager.hx">
		<context public="1" static="1"><c path="lime.media.AudioContext"/></context>
		<init public="1" set="method" line="22" static="1">
			<f a="?context" v="null">
				<c path="lime.media.AudioContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</init>
		<resume public="1" set="method" line="56" static="1"><f a=""><x path="Void"/></f></resume>
		<shutdown public="1" set="method" line="74" static="1"><f a=""><x path="Void"/></f></shutdown>
		<suspend public="1" set="method" line="99" static="1"><f a=""><x path="Void"/></f></suspend>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.media.AudioSource" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioSource.hx">
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<buffer public="1"><c path="lime.media.AudioBuffer"/></buffer>
		<currentTime public="1" get="accessor" set="accessor"><x path="Int"/></currentTime>
		<gain public="1" get="accessor" set="accessor"><x path="Float"/></gain>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<loops public="1" get="accessor" set="accessor"><x path="Int"/></loops>
		<offset public="1"><x path="Int"/></offset>
		<position public="1" get="accessor" set="accessor"><c path="lime.math.Vector4"/></position>
		<__backend>
			<t path="lime.media._AudioSource.AudioSourceBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<dispose public="1" set="method" line="45"><f a=""><x path="Void"/></f></dispose>
		<init set="method" line="50">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</init>
		<play public="1" set="method" line="55"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="60"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="65"><f a=""><x path="Void"/></f></stop>
		<get_currentTime set="method" line="71">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentTime>
		<set_currentTime set="method" line="76">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_currentTime>
		<get_gain set="method" line="81">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_gain>
		<set_gain set="method" line="86">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_gain>
		<get_length set="method" line="91">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<set_length set="method" line="96">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_length>
		<get_loops set="method" line="101">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_loops>
		<set_loops set="method" line="106">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_loops>
		<get_position set="method" line="111">
			<f a=""><c path="lime.math.Vector4"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_position>
		<set_position set="method" line="116">
			<f a="value">
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_position>
		<new public="1" set="method" line="25">
			<f a="?buffer:?offset:?length:?loops" v="null:0:null:0">
				<c path="lime.media.AudioBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, length : null, offset : 0, buffer : null }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.media._AudioSource.AudioSourceBackend" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/AudioSource.hx" private="1" module="lime.media.AudioSource">
		<c path="lime._internal.backend.flash.FlashAudioSource"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<class path="lime.media.FlashAudioContext" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/media/FlashAudioContext.hx">
		<createBuffer public="1" set="method" line="12">
			<f a="?stream:?context" v="null:null">
				<d/>
				<d/>
				<c path="lime.media.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ context : null, stream : null }</e></m></meta>
		</createBuffer>
		<getBytesLoaded public="1" set="method" line="23"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="UInt"/>
</f></getBytesLoaded>
		<getBytesTotal public="1" set="method" line="35"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Int"/>
</f></getBytesTotal>
		<getID3 public="1" set="method" line="47"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<d/>
</f></getID3>
		<getIsBuffering public="1" set="method" line="59"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsBuffering>
		<getIsURLInaccessible public="1" set="method" line="71"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsURLInaccessible>
		<getLength public="1" set="method" line="83"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Float"/>
</f></getLength>
		<getURL public="1" set="method" line="95"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<c path="String"/>
</f></getURL>
		<close public="1" set="method" line="107"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Void"/>
</f></close>
		<extract public="1" set="method" line="117">
			<f a="buffer:target:length:?startPosition" v=":::-1">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ startPosition : -1 }</e></m></meta>
		</extract>
		<load public="1" set="method" line="129">
			<f a="buffer:stream:?context" v="::null">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadCompressedDataFromByteArray public="1" set="method" line="139"><f a="buffer:bytes:bytesLength">
	<c path="lime.media.AudioBuffer"/>
	<d/>
	<x path="UInt"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="149">
			<f a="buffer:bytes:samples:?format:?stereo:?sampleRate" v=":::null:true:44100">
				<c path="lime.media.AudioBuffer"/>
				<d/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sampleRate : 44100, stereo : true, format : null }</e></m></meta>
		</loadPCMFromByteArray>
		<play public="1" set="method" line="160">
			<f a="buffer:?startTime:?loops:?sndTransform" v=":0:0:null">
				<c path="lime.media.AudioBuffer"/>
				<x path="Float"/>
				<x path="Int"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ sndTransform : null, loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<new set="method" line="10">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.net.HTTPRequest" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/HTTPRequest.hx">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><c path="haxe.io.Bytes"/></data>
		<enableResponseHeaders public="1"><x path="Bool"/></enableResponseHeaders>
		<followRedirects public="1"><x path="Bool"/></followRedirects>
		<formData public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></formData>
		<headers public="1"><c path="Array"><c path="lime.net.HTTPRequestHeader"/></c></headers>
		<method public="1"><x path="lime.net.HTTPRequestMethod"/></method>
		<responseData public="1"><c path="lime.net.HTTPRequest.T"/></responseData>
		<responseHeaders public="1"><c path="Array"><c path="lime.net.HTTPRequestHeader"/></c></responseHeaders>
		<responseStatus public="1"><x path="Int"/></responseStatus>
		<timeout public="1"><x path="Int"/></timeout>
		<uri public="1"><c path="String"/></uri>
		<userAgent public="1"><c path="String"/></userAgent>
		<withCredentials public="1"><x path="Bool"/></withCredentials>
		<cancel public="1" set="method" line="67"><f a=""><x path="Void"/></f></cancel>
		<load public="1" set="method" line="74">
			<f a="?uri" v="null">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.net.HTTPRequest.T"/></c>
			</f>
			<meta><m n=":value"><e>{ uri : null }</e></m></meta>
		</load>
		<new public="1" set="method" line="48">
			<f a="?uri" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ uri : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.net.HTTPRequestHeader" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/HTTPRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="12">
			<f a="name:?value" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.net.HTTPRequestMethod" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/HTTPRequestMethod.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net._HTTPRequestMethod.HTTPRequestMethod_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/HTTPRequestMethod.hx" private="1" module="lime.net.HTTPRequestMethod" extern="1" final="1">
	<DELETE public="1" get="inline" set="null" expr="cast &quot;DELETE&quot;" line="5" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "DELETE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<GET public="1" get="inline" set="null" expr="cast &quot;GET&quot;" line="6" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "GET"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GET>
	<HEAD public="1" get="inline" set="null" expr="cast &quot;HEAD&quot;" line="7" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "HEAD"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEAD>
	<OPTIONS public="1" get="inline" set="null" expr="cast &quot;OPTIONS&quot;" line="8" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "OPTIONS"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPTIONS>
	<POST public="1" get="inline" set="null" expr="cast &quot;POST&quot;" line="9" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "POST"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POST>
	<PUT public="1" get="inline" set="null" expr="cast &quot;PUT&quot;" line="10" static="1">
		<x path="lime.net.HTTPRequestMethod"/>
		<meta>
			<m n=":value"><e>cast "PUT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PUT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.net._HTTPRequestMethod.HTTPRequestMethod_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/HTTPRequestMethod.hx" private="1" module="lime.net.HTTPRequestMethod" extern="1" final="1">
		<DELETE public="1" get="inline" set="null" expr="cast &quot;DELETE&quot;" line="5" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "DELETE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<GET public="1" get="inline" set="null" expr="cast &quot;GET&quot;" line="6" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "GET"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GET>
		<HEAD public="1" get="inline" set="null" expr="cast &quot;HEAD&quot;" line="7" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "HEAD"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEAD>
		<OPTIONS public="1" get="inline" set="null" expr="cast &quot;OPTIONS&quot;" line="8" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "OPTIONS"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPTIONS>
		<POST public="1" get="inline" set="null" expr="cast &quot;POST&quot;" line="9" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "POST"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POST>
		<PUT public="1" get="inline" set="null" expr="cast &quot;PUT&quot;" line="10" static="1">
			<x path="lime.net.HTTPRequestMethod"/>
			<meta>
				<m n=":value"><e>cast "PUT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PUT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.net.URIParser" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/URIParser.hx">
		<URI_REGEX public="1" expr="~/^(?:([^:/?#]+):)?(?://((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/" line="10" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(?:([^:/?#]+):)?(?://((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/</e></m></meta>
		</URI_REGEX>
		<QUERY_REGEX public="1" expr="~/(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*)/" line="11" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e><![CDATA[~/(?:^|&)([^&=]*)=?([^&]*)/]]></e></m></meta>
		</QUERY_REGEX>
		<parseQuery public="1" set="method" line="59" static="1"><f a="query">
	<c path="String"/>
	<c path="Array"><t path="lime.net.KVPair"/></c>
</f></parseQuery>
		<source public="1"><c path="String"/></source>
		<protocol public="1"><c path="String"/></protocol>
		<authority public="1"><c path="String"/></authority>
		<userInfo public="1"><c path="String"/></userInfo>
		<user public="1"><c path="String"/></user>
		<password public="1"><c path="String"/></password>
		<host public="1"><c path="String"/></host>
		<port public="1"><c path="String"/></port>
		<relative public="1"><c path="String"/></relative>
		<path public="1"><c path="String"/></path>
		<directory public="1"><c path="String"/></directory>
		<file public="1"><c path="String"/></file>
		<query public="1"><c path="String"/></query>
		<anchor public="1"><c path="String"/></anchor>
		<queryArray public="1"><c path="Array"><t path="lime.net.KVPair"/></c></queryArray>
		<new public="1" set="method" line="29"><f a="uri">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.net.KVPair" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/URIParser.hx" module="lime.net.URIParser">
		<a>
			<v><c path="String"/></v>
			<k><c path="String"/></k>
		</a>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="lime.net.oauth.OAuthClient" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthClient.hx">
		<version public="1"><x path="lime.net.oauth.OAuthVersion"/></version>
		<consumer public="1"><c path="lime.net.oauth.OAuthConsumer"/></consumer>
		<generateNonce public="1" set="method" line="34"><f a=""><c path="String"/></f></generateNonce>
		<new public="1" set="method" line="12"><f a="version:consumer">
	<x path="lime.net.oauth.OAuthVersion"/>
	<c path="lime.net.oauth.OAuthConsumer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuthConsumer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthConsumer.hx">
		<key public="1"><c path="String"/></key>
		<secret public="1"><c path="String"/></secret>
		<new public="1" set="method" line="8"><f a="key:secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.net.oauth.OAuthSignatureMethod" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthSignatureMethod.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net.oauth._OAuthSignatureMethod.OAuthSignatureMethod_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthSignatureMethod.hx" private="1" module="lime.net.oauth.OAuthSignatureMethod" extern="1" final="1">
	<HMAC_SHA1 public="1" get="inline" set="null" expr="cast &quot;HMAC-SHA1&quot;" line="6" static="1">
		<x path="lime.net.oauth.OAuthSignatureMethod"/>
		<meta>
			<m n=":value"><e>cast "HMAC-SHA1"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HMAC_SHA1>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.net.oauth._OAuthSignatureMethod.OAuthSignatureMethod_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthSignatureMethod.hx" private="1" module="lime.net.oauth.OAuthSignatureMethod" extern="1" final="1">
		<HMAC_SHA1 public="1" get="inline" set="null" expr="cast &quot;HMAC-SHA1&quot;" line="6" static="1">
			<x path="lime.net.oauth.OAuthSignatureMethod"/>
			<meta>
				<m n=":value"><e>cast "HMAC-SHA1"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HMAC_SHA1>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.net.oauth.RequestToken" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<secret public="1" set="null"><c path="String"/></secret>
		<new public="1" set="method" line="8"><f a="token:secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.AccessToken" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<new public="1" set="method" line="19"><f a="token">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuth1AccessToken" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<extends path="lime.net.oauth.AccessToken"/>
		<secret public="1" set="null"><c path="String"/></secret>
		<new public="1" set="method" line="29"><f a="token:?secret">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.OAuth2AccessToken" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<extends path="lime.net.oauth.AccessToken"/>
		<expires public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</expires>
		<new public="1" set="method" line="40"><f a="token:?expires">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.net.oauth.RefreshToken" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthToken.hx" module="lime.net.oauth.OAuthToken">
		<token public="1" set="null"><c path="String"/></token>
		<new public="1" set="method" line="51"><f a="token">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.net.oauth.OAuthVersion" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthVersion.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.net.oauth._OAuthVersion.OAuthVersion_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthVersion.hx" private="1" module="lime.net.oauth.OAuthVersion" extern="1" final="1">
	<V1 public="1" get="inline" set="null" expr="cast &quot;1.0&quot;" line="5" static="1">
		<x path="lime.net.oauth.OAuthVersion"/>
		<meta>
			<m n=":value"><e>cast "1.0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V1>
	<V2 public="1" get="inline" set="null" expr="cast &quot;2.0&quot;" line="6" static="1">
		<x path="lime.net.oauth.OAuthVersion"/>
		<meta>
			<m n=":value"><e>cast "2.0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V2>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.net.oauth._OAuthVersion.OAuthVersion_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/net/oauth/OAuthVersion.hx" private="1" module="lime.net.oauth.OAuthVersion" extern="1" final="1">
		<V1 public="1" get="inline" set="null" expr="cast &quot;1.0&quot;" line="5" static="1">
			<x path="lime.net.oauth.OAuthVersion"/>
			<meta>
				<m n=":value"><e>cast "1.0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V1>
		<V2 public="1" get="inline" set="null" expr="cast &quot;2.0&quot;" line="6" static="1">
			<x path="lime.net.oauth.OAuthVersion"/>
			<meta>
				<m n=":value"><e>cast "2.0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V2>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.system.BackgroundWorker" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/BackgroundWorker.hx">
		<MESSAGE_COMPLETE expr="&quot;__COMPLETE__&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__COMPLETE__"</e></m></meta>
		</MESSAGE_COMPLETE>
		<MESSAGE_ERROR expr="&quot;__ERROR__&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ERROR__"</e></m></meta>
		</MESSAGE_ERROR>
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<completed public="1" set="null"><x path="Bool"/></completed>
		<doWork public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</doWork>
		<onComplete public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onProgress>
		<__runMessage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__runMessage>
		<cancel public="1" set="method" line="41"><f a=""><x path="Void"/></f></cancel>
		<run public="1" set="method" line="50">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</run>
		<sendComplete public="1" set="method" line="71">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="87">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="101">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendProgress>
		<__doWork set="method" line="113">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__doWork>
		<__update set="method" line="133">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__update>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.system.Clipboard" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Clipboard.hx">
		<onUpdate public="1" expr="new Event&lt;Void&gt;()" line="20" static="1">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onUpdate>
		<text public="1" get="accessor" set="accessor" static="1"><c path="String"/></text>
		<_text static="1"><c path="String"/></_text>
		<__update set="method" line="24" static="1"><f a=""><x path="Void"/></f></__update>
		<get_text set="method" line="53" static="1"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="64" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<class path="lime.system.Display" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Display.hx">
		<bounds public="1" set="null">
			<c path="lime.math.Rectangle"/>
			<haxe_doc>* The desktop area represented by this display, with the upper-leftmost display at 0,0</haxe_doc>
		</bounds>
		<currentMode public="1" set="null">
			<c path="lime.system.DisplayMode"/>
			<haxe_doc>* The current display mode</haxe_doc>
		</currentMode>
		<id public="1" set="null"><x path="Int"/></id>
		<dpi public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Pixel density of the display</haxe_doc>
		</dpi>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The name of the device, such as "Samsung SyncMaster P2350", "iPhone 6", "Oculus Rift DK2", etc.</haxe_doc>
		</name>
		<supportedModes public="1" set="null">
			<c path="Array"><c path="lime.system.DisplayMode"/></c>
			<haxe_doc>* All of the display modes supported by this device</haxe_doc>
		</supportedModes>
		<new set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.system.DisplayMode" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/DisplayMode.hx">
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* vertical resolution</haxe_doc>
		</height>
		<pixelFormat public="1" set="null">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>* pixel format</haxe_doc>
		</pixelFormat>
		<refreshRate public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* refresh rate in Hz</haxe_doc>
		</refreshRate>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* horizontal resolution</haxe_doc>
		</width>
		<new set="method" line="31">
			<f a="width:height:refreshRate:pixelFormat">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system.Endian" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.system.Locale" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Locale.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<impl><class path="lime.system._Locale.Locale_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Locale.hx" private="1" module="lime.system.Locale" final="1">
	<currentLocale public="1" get="accessor" set="accessor" static="1">
		<x path="lime.system.Locale"/>
		<meta><m n=":isVar"/></meta>
	</currentLocale>
	<systemLocale public="1" get="accessor" set="null" static="1"><x path="lime.system.Locale"/></systemLocale>
	<__systemLocale static="1"><x path="lime.system.Locale"/></__systemLocale>
	<language public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</language>
	<region public="1" get="accessor" set="null" static="1">
		<c path="String"/>
		<meta><m n=":impl"/></meta>
	</region>
	<_new public="1" set="method" line="18" static="1">
		<f a="value">
			<c path="String"/>
			<x path="lime.system.Locale"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<equals set="method" line="23" static="1">
		<f a="a:b">
			<x path="lime.system.Locale"/>
			<x path="lime.system.Locale"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equals>
	<__init set="method" line="54" static="1"><f a=""><x path="Void"/></f></__init>
	<get_language set="method" line="92" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_language>
	<get_region set="method" line="117" static="1">
		<f a="this">
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_region>
	<get_currentLocale set="method" line="153" static="1"><f a=""><x path="lime.system.Locale"/></f></get_currentLocale>
	<set_currentLocale set="method" line="160" static="1"><f a="value">
	<x path="lime.system.Locale"/>
	<x path="lime.system.Locale"/>
</f></set_currentLocale>
	<get_systemLocale set="method" line="167" static="1"><f a=""><x path="lime.system.Locale"/></f></get_systemLocale>
</class></impl>
	</abstract>
	<class path="lime.system._Locale.Locale_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Locale.hx" private="1" module="lime.system.Locale" final="1">
		<currentLocale public="1" get="accessor" set="accessor" static="1">
			<x path="lime.system.Locale"/>
			<meta><m n=":isVar"/></meta>
		</currentLocale>
		<systemLocale public="1" get="accessor" set="null" static="1"><x path="lime.system.Locale"/></systemLocale>
		<__systemLocale static="1"><x path="lime.system.Locale"/></__systemLocale>
		<language public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
		</language>
		<region public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<meta><m n=":impl"/></meta>
		</region>
		<_new public="1" set="method" line="18" static="1">
			<f a="value">
				<c path="String"/>
				<x path="lime.system.Locale"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<equals set="method" line="23" static="1">
			<f a="a:b">
				<x path="lime.system.Locale"/>
				<x path="lime.system.Locale"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equals>
		<__init set="method" line="54" static="1"><f a=""><x path="Void"/></f></__init>
		<get_language set="method" line="92" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_language>
		<get_region set="method" line="117" static="1">
			<f a="this">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_region>
		<get_currentLocale set="method" line="153" static="1"><f a=""><x path="lime.system.Locale"/></f></get_currentLocale>
		<set_currentLocale set="method" line="160" static="1"><f a="value">
	<x path="lime.system.Locale"/>
	<x path="lime.system.Locale"/>
</f></set_currentLocale>
		<get_systemLocale set="method" line="167" static="1"><f a=""><x path="lime.system.Locale"/></f></get_systemLocale>
	</class>
	<class path="lime.system.Sensor" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/Sensor.hx">
		<sensorByID expr="new Map&lt;Int,Sensor&gt;()" line="11" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.system.Sensor"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Sensor>()]]></e></m></meta>
		</sensorByID>
		<sensors expr="new Array&lt;Sensor&gt;()" line="12" static="1">
			<c path="Array"><c path="lime.system.Sensor"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Sensor>()]]></e></m></meta>
		</sensors>
		<getSensors public="1" set="method" line="24" static="1">
			<f a="?type" v="null">
				<e path="lime.system.SensorType"/>
				<c path="Array"><c path="lime.system.Sensor"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</getSensors>
		<registerSensor set="method" line="46" static="1"><f a="type:id">
	<e path="lime.system.SensorType"/>
	<x path="Int"/>
	<c path="lime.system.Sensor"/>
</f></registerSensor>
		<id public="1"><x path="Int"/></id>
		<onUpdate public="1" expr="new Event&lt;Float -&gt; Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Float_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Float>()]]></e></m></meta>
		</onUpdate>
		<type public="1"><e path="lime.system.SensorType"/></type>
		<new set="method" line="18">
			<f a="type:id">
				<e path="lime.system.SensorType"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system.SensorType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/SensorType.hx">
		<ACCELEROMETER/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.system.System" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/System.hx">
		<allowScreenTimeout public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></allowScreenTimeout>
		<applicationDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationDirectory>
		<applicationStorageDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationStorageDirectory>
		<desktopDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></desktopDirectory>
		<deviceModel public="1" get="accessor" set="null" static="1"><c path="String"/></deviceModel>
		<deviceVendor public="1" get="accessor" set="null" static="1"><c path="String"/></deviceVendor>
		<disableCFFI public="1" static="1"><x path="Bool"/></disableCFFI>
		<documentsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></documentsDirectory>
		<endianness public="1" get="accessor" set="null" static="1"><e path="lime.system.Endian"/></endianness>
		<fontsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></fontsDirectory>
		<numDisplays public="1" get="accessor" set="null" static="1"><x path="Int"/></numDisplays>
		<platformLabel public="1" get="accessor" set="null" static="1"><c path="String"/></platformLabel>
		<platformName public="1" get="accessor" set="null" static="1"><c path="String"/></platformName>
		<platformVersion public="1" get="accessor" set="null" static="1"><c path="String"/></platformVersion>
		<userDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></userDirectory>
		<__applicationDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__applicationDirectory>
		<__applicationEntryPoint static="1">
			<t path="Map">
				<c path="String"/>
				<x path="haxe.Function"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__applicationEntryPoint>
		<__applicationStorageDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__applicationStorageDirectory>
		<__desktopDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__desktopDirectory>
		<__deviceModel static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__deviceModel>
		<__deviceVendor static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__deviceVendor>
		<__directories expr="new Map&lt;SystemDirectory,String&gt;()" line="68" static="1">
			<x path="haxe.ds.Map">
				<x path="lime.system._System.SystemDirectory"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<SystemDirectory,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</__directories>
		<__documentsDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__documentsDirectory>
		<__endianness static="1">
			<e path="lime.system.Endian"/>
			<meta><m n=":noCompletion"/></meta>
		</__endianness>
		<__fontsDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontsDirectory>
		<__platformLabel static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformLabel>
		<__platformName static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformName>
		<__platformVersion static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__platformVersion>
		<__userDirectory static="1">
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__userDirectory>
		<getDisplay public="1" set="method" line="164" static="1"><f a="id">
	<x path="Int"/>
	<c path="lime.system.Display"/>
</f></getDisplay>
		<getTimer public="1" set="method" line="262" static="1"><f a=""><x path="Int"/></f></getTimer>
		<openFile public="1" set="method" line="292" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></openFile>
		<openURL public="1" set="method" line="315" static="1">
			<f a="url:?target" v=":&quot;_blank&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ target : "_blank" }</e></m></meta>
		</openURL>
		<__copyMissingFields set="method" line="334" static="1">
			<f a="target:source">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__copyMissingFields>
		<__getDirectory set="method" line="347" static="1">
			<f a="type">
				<x path="lime.system._System.SystemDirectory"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getDirectory>
		<__parseBool get="inline" set="null" line="524" static="1">
			<f a="value">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__parseBool>
		<__registerEntryPoint set="method" line="529" static="1">
			<f a="projectName:entryPoint">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__registerEntryPoint>
		<__runProcess set="method" line="539" static="1">
			<f a="command:?args" v=":null">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ args : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__runProcess>
		<get_allowScreenTimeout set="method" line="557" static="1"><f a=""><x path="Bool"/></f></get_allowScreenTimeout>
		<set_allowScreenTimeout set="method" line="566" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowScreenTimeout>
		<get_applicationDirectory set="method" line="575" static="1"><f a=""><c path="String"/></f></get_applicationDirectory>
		<get_applicationStorageDirectory set="method" line="585" static="1"><f a=""><c path="String"/></f></get_applicationStorageDirectory>
		<get_deviceModel set="method" line="595" static="1"><f a=""><c path="String"/></f></get_deviceModel>
		<get_deviceVendor set="method" line="630" static="1"><f a=""><c path="String"/></f></get_deviceVendor>
		<get_desktopDirectory set="method" line="656" static="1"><f a=""><c path="String"/></f></get_desktopDirectory>
		<get_documentsDirectory set="method" line="666" static="1"><f a=""><c path="String"/></f></get_documentsDirectory>
		<get_endianness set="method" line="676" static="1"><f a=""><e path="lime.system.Endian"/></f></get_endianness>
		<get_fontsDirectory set="method" line="697" static="1"><f a=""><c path="String"/></f></get_fontsDirectory>
		<get_numDisplays set="method" line="707" static="1"><f a=""><x path="Int"/></f></get_numDisplays>
		<get_platformLabel set="method" line="716" static="1"><f a=""><c path="String"/></f></get_platformLabel>
		<get_platformName set="method" line="740" static="1"><f a=""><c path="String"/></f></get_platformName>
		<get_platformVersion set="method" line="778" static="1"><f a=""><c path="String"/></f></get_platformVersion>
		<get_userDirectory set="method" line="806" static="1"><f a=""><c path="String"/></f></get_userDirectory>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.system.Display</e></m>
			<m n=":access"><e>lime.system.DisplayMode</e></m>
		</meta>
	</class>
	<abstract path="lime.system._System.SystemDirectory" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/System.hx" private="1" module="lime.system.System">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.system._System.SystemDirectory_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/System.hx" private="1" module="lime.system.System" extern="1" final="1">
	<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="819" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="820" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION_STORAGE>
	<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="821" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESKTOP>
	<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="822" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOCUMENTS>
	<FONTS public="1" get="inline" set="null" expr="cast 4" line="823" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONTS>
	<USER public="1" get="inline" set="null" expr="cast 5" line="824" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.system._System.SystemDirectory_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/System.hx" private="1" module="lime.system.System" extern="1" final="1">
		<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="819" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="820" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION_STORAGE>
		<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="821" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESKTOP>
		<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="822" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOCUMENTS>
		<FONTS public="1" get="inline" set="null" expr="cast 4" line="823" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONTS>
		<USER public="1" get="inline" set="null" expr="cast 5" line="824" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.system.ThreadPool" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/ThreadPool.hx">
		<currentThreads public="1" set="null"><x path="Int"/></currentThreads>
		<doWork public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</doWork>
		<maxThreads public="1"><x path="Int"/></maxThreads>
		<minThreads public="1"><x path="Int"/></minThreads>
		<onComplete public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onProgress>
		<onRun public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app._Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onRun>
		<queue public="1" set="method" line="68">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</queue>
		<sendComplete public="1" set="method" line="99">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="112">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="125">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendProgress>
		<runWork set="method" line="138">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ state : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</runWork>
		<new public="1" set="method" line="41">
			<f a="?minThreads:?maxThreads" v="0:1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxThreads : 1, minThreads : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<enum path="lime.system._ThreadPool.ThreadPoolMessageType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<COMPLETE/>
		<ERROR/>
		<EXIT/>
		<PROGRESS/>
		<WORK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.system._ThreadPool.ThreadPoolMessage" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<state public="1"><d/></state>
		<type public="1"><e path="lime.system._ThreadPool.ThreadPoolMessageType"/></type>
		<new public="1" set="method" line="239"><f a="type:state">
	<e path="lime.system._ThreadPool.ThreadPoolMessageType"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.text.Font" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Font.hx">
		<fromBytes public="1" set="method" line="120" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.text.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="134" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></fromFile>
		<loadFromBytes public="1" set="method" line="148" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromBytes>
		<loadFromFile public="1" set="method" line="153" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromFile>
		<loadFromName public="1" set="method" line="169" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFromName>
		<ascender public="1"><x path="Int"/></ascender>
		<descender public="1"><x path="Int"/></descender>
		<height public="1"><x path="Int"/></height>
		<name public="1" set="null"><c path="String"/></name>
		<numGlyphs public="1"><x path="Int"/></numGlyphs>
		<src public="1"><d/></src>
		<underlinePosition public="1"><x path="Int"/></underlinePosition>
		<underlineThickness public="1"><x path="Int"/></underlineThickness>
		<unitsPerEM public="1"><x path="Int"/></unitsPerEM>
		<__fontID>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontID>
		<__fontPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontPath>
		<__init>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__init>
		<decompose public="1" set="method" line="102"><f a=""><t path="lime.text.NativeFontData"/></f></decompose>
		<getGlyph public="1" set="method" line="179"><f a="character">
	<c path="String"/>
	<x path="lime.text.Glyph"/>
</f></getGlyph>
		<getGlyphs public="1" set="method" line="188">
			<f a="?characters" v="&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`&apos;\&quot;/\\&amp;*()[]{}&lt;&gt;|:;_-+=?,. &quot;">
				<c path="String"/>
				<c path="Array"><x path="lime.text.Glyph"/></c>
			</f>
			<meta><m n=":value"><e><![CDATA[{ characters : "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`'\"/\\&*()[]{}<>|:;_-+=?,. " }]]></e></m></meta>
		</getGlyphs>
		<getGlyphMetrics public="1" set="method" line="198"><f a="glyph">
	<x path="lime.text.Glyph"/>
	<c path="lime.text.GlyphMetrics"/>
</f></getGlyphMetrics>
		<renderGlyph public="1" set="method" line="215"><f a="glyph:fontSize">
	<x path="lime.text.Glyph"/>
	<x path="Int"/>
	<c path="lime.graphics.Image"/>
</f></renderGlyph>
		<renderGlyphs public="1" set="method" line="254"><f a="glyphs:fontSize">
	<c path="Array"><x path="lime.text.Glyph"/></c>
	<x path="Int"/>
	<t path="Map">
		<x path="lime.text.Glyph"/>
		<c path="lime.graphics.Image"/>
	</t>
</f></renderGlyphs>
		<__copyFrom set="method" line="417">
			<f a="other">
				<c path="lime.text.Font"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__copyFrom>
		<__fromBytes set="method" line="442">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromBytes>
		<__fromFile set="method" line="455">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromFile>
		<__initializeSource set="method" line="468">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__initializeSource>
		<__loadFromName set="method" line="495">
			<f a="name">
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.text.Font"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromName>
		<__setSize set="method" line="590">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setSize>
		<new public="1" set="method" line="53">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ name : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.text.Glyph</e></m>
		</meta>
	</class>
	<typedef path="lime.text.NativeFontData" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="lime.text.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="lime.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="lime.text.NativeGlyphData" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="lime.text.NativeKerningData" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Font.hx" module="lime.text.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<abstract path="lime.text.Glyph" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Glyph.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.text._Glyph.Glyph_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Glyph.hx" private="1" module="lime.text.Glyph" final="1"><_new public="1" set="method" line="5" static="1">
	<f a="i">
		<x path="Int"/>
		<x path="lime.text.Glyph"/>
	</f>
	<meta>
		<m n=":impl"/>
		<m n=":noCompletion"/>
	</meta>
</_new></class></impl>
	</abstract>
	<class path="lime.text._Glyph.Glyph_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/Glyph.hx" private="1" module="lime.text.Glyph" final="1"><_new public="1" set="method" line="5" static="1">
	<f a="i">
		<x path="Int"/>
		<x path="lime.text.Glyph"/>
	</f>
	<meta>
		<m n=":impl"/>
		<m n=":noCompletion"/>
	</meta>
</_new></class>
	<class path="lime.text.GlyphMetrics" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/GlyphMetrics.hx">
		<advance public="1"><c path="lime.math.Vector2"/></advance>
		<height public="1"><x path="Int"/></height>
		<horizontalBearing public="1"><c path="lime.math.Vector2"/></horizontalBearing>
		<verticalBearing public="1"><c path="lime.math.Vector2"/></verticalBearing>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.text.UTF8String" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/text/UTF8String.hx"><x path="UnicodeString"/></typedef>
	<class path="lime.ui.FileDialog" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/FileDialog.hx">
		<onCancel public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onCancel>
		<onOpen public="1" expr="new Event&lt;Resource&gt;()">
			<c path="lime.app._Event_lime_utils_Resource_Void"><f a="">
	<x path="lime.utils.Resource"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Resource>()]]></e></m></meta>
		</onOpen>
		<onSave public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onSave>
		<onSelect public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onSelect>
		<onSelectMultiple public="1" expr="new Event&lt;Array&lt;String&gt;&gt;()">
			<c path="lime.app._Event_Array_String__Void"><f a="">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Array<String>>()]]></e></m></meta>
		</onSelectMultiple>
		<browse public="1" set="method" line="34">
			<f a="?type:?filter:?defaultPath:?title" v="null:null:null:null">
				<e path="lime.ui.FileDialogType"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ title : null, defaultPath : null, filter : null, type : null }</e></m></meta>
		</browse>
		<open public="1" set="method" line="120">
			<f a="?filter:?defaultPath:?title" v="null:null:null">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ title : null, defaultPath : null, filter : null }</e></m></meta>
		</open>
		<save public="1" set="method" line="159">
			<f a="data:?filter:?defaultPath:?title:?type" v=":null:null:null:&quot;application/octet-stream&quot;">
				<x path="lime.utils.Resource"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ type : "application/octet-stream", title : null, defaultPath : null, filter : null }</e></m></meta>
		</save>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.graphics.Image</e></m>
		</meta>
	</class>
	<enum path="lime.ui.FileDialogType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/FileDialogType.hx">
		<OPEN/>
		<OPEN_MULTIPLE/>
		<SAVE/>
		<OPEN_DIRECTORY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.ui.Gamepad" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Gamepad.hx">
		<devices public="1" expr="new Map&lt;Int,Gamepad&gt;()" line="14" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Gamepad"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Gamepad>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Gamepad&gt;()" line="15" static="1">
			<c path="lime.app._Event_lime_ui_Gamepad_Void"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Gamepad>()]]></e></m></meta>
		</onConnect>
		<addMappings public="1" set="method" line="32" static="1"><f a="mappings">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addMappings>
		<__connect set="method" line="45" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="55" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<onAxisMove public="1" expr="new Event&lt;GamepadAxis -&gt; Float&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadAxis_Float_Void"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadAxis -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app._Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<get_guid get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="80">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<new public="1" set="method" line="26"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.Joystick</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.GamepadAxis" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadAxis.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis" final="1">
	<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_X>
	<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_Y>
	<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_X>
	<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_Y>
	<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_LEFT>
	<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_RIGHT>
	<toString public="1" get="inline" set="null" line="12" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis" final="1">
		<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_X>
		<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_Y>
		<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_X>
		<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_Y>
		<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_LEFT>
		<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_RIGHT>
		<toString public="1" get="inline" set="null" line="12" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="lime.ui.GamepadButton" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadButton.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton" final="1">
	<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<BACK public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACK>
	<GUIDE public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GUIDE>
	<START public="1" get="inline" set="null" expr="cast 6" line="11" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</START>
	<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="12" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_STICK>
	<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="13" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_STICK>
	<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="14" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHOULDER>
	<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="15" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHOULDER>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="16" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="17" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="18" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="19" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_RIGHT>
	<toString public="1" get="inline" set="null" line="21" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton" final="1">
		<A public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<BACK public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACK>
		<GUIDE public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GUIDE>
		<START public="1" get="inline" set="null" expr="cast 6" line="11" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</START>
		<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="12" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_STICK>
		<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="13" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_STICK>
		<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="14" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="15" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHOULDER>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="16" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="17" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="18" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="19" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_RIGHT>
		<toString public="1" get="inline" set="null" line="21" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.ui.Haptic" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Haptic.hx">
		<vibrate public="1" set="method" line="18" static="1"><f a="period:duration">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vibrate>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.ui.Joystick" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Joystick.hx">
		<devices public="1" expr="new Map&lt;Int,Joystick&gt;()" line="13" static="1">
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="lime.ui.Joystick"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Joystick>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Joystick&gt;()" line="14" static="1">
			<c path="lime.app._Event_lime_ui_Joystick_Void"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Joystick>()]]></e></m></meta>
		</onConnect>
		<__connect set="method" line="37" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="47" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<numAxes public="1" get="accessor" set="null"><x path="Int"/></numAxes>
		<numButtons public="1" get="accessor" set="null"><x path="Int"/></numButtons>
		<numHats public="1" get="accessor" set="null"><x path="Int"/></numHats>
		<numTrackballs public="1" get="accessor" set="null"><x path="Int"/></numTrackballs>
		<onAxisMove public="1" expr="new Event&lt;Int -&gt; Float&gt;()">
			<c path="lime.app._Event_Int_Float_Void"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app._Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<onHatMove public="1" expr="new Event&lt;Int -&gt; JoystickHatPosition&gt;()">
			<c path="lime.app._Event_Int_lime_ui_JoystickHatPosition_Void"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> JoystickHatPosition>()]]></e></m></meta>
		</onHatMove>
		<onTrackballMove public="1" expr="new Event&lt;Int -&gt; Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Int_Float_Float_Void"><f a="::">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float -> Float>()]]></e></m></meta>
		</onTrackballMove>
		<get_guid get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="80">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<get_numAxes get="inline" set="null" line="96">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numAxes>
		<get_numButtons get="inline" set="null" line="108">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numButtons>
		<get_numHats get="inline" set="null" line="120">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numHats>
		<get_numTrackballs get="inline" set="null" line="129">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numTrackballs>
		<new public="1" set="method" line="31"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.JoystickHatPosition" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/JoystickHatPosition.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition" final="1">
	<CENTER public="1" get="inline" set="null" expr="0x00" line="5" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x00</e></m></meta>
	</CENTER>
	<DOWN public="1" get="inline" set="null" expr="0x04" line="6" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x04</e></m></meta>
	</DOWN>
	<LEFT public="1" get="inline" set="null" expr="0x08" line="7" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x08</e></m></meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="0x02" line="8" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x02</e></m></meta>
	</RIGHT>
	<UP public="1" get="inline" set="null" expr="0x01" line="9" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x01</e></m></meta>
	</UP>
	<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="10" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
	</DOWN_LEFT>
	<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="11" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
	</DOWN_RIGHT>
	<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="12" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
	</UP_LEFT>
	<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="13" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
	</UP_RIGHT>
	<center public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</center>
	<down public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</down>
	<left public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</left>
	<right public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</right>
	<up public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</up>
	<_new public="1" set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="lime.ui.JoystickHatPosition"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<get_center set="method" line="26" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_center>
	<set_center get="inline" set="null" line="31" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_center>
	<get_down set="method" line="41" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_down>
	<set_down get="inline" set="null" line="46" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_down>
	<get_left set="method" line="60" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_left>
	<set_left get="inline" set="null" line="65" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_left>
	<get_right set="method" line="79" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_right>
	<set_right get="inline" set="null" line="84" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_right>
	<get_up set="method" line="98" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_up>
	<set_up get="inline" set="null" line="103" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_up>
</class></impl>
	</abstract>
	<class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition" final="1">
		<CENTER public="1" get="inline" set="null" expr="0x00" line="5" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x00</e></m></meta>
		</CENTER>
		<DOWN public="1" get="inline" set="null" expr="0x04" line="6" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x04</e></m></meta>
		</DOWN>
		<LEFT public="1" get="inline" set="null" expr="0x08" line="7" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x08</e></m></meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="0x02" line="8" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x02</e></m></meta>
		</RIGHT>
		<UP public="1" get="inline" set="null" expr="0x01" line="9" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x01</e></m></meta>
		</UP>
		<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="10" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
		</DOWN_LEFT>
		<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="11" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
		</DOWN_RIGHT>
		<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="12" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
		</UP_LEFT>
		<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="13" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
		</UP_RIGHT>
		<center public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</center>
		<down public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</down>
		<left public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</left>
		<right public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</right>
		<up public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</up>
		<_new public="1" set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<get_center set="method" line="26" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_center>
		<set_center get="inline" set="null" line="31" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_center>
		<get_down set="method" line="41" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_down>
		<set_down get="inline" set="null" line="46" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_down>
		<get_left set="method" line="60" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_left>
		<set_left get="inline" set="null" line="65" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_left>
		<get_right set="method" line="79" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_right>
		<set_right get="inline" set="null" line="84" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_right>
		<get_up set="method" line="98" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_up>
		<set_up get="inline" set="null" line="103" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_up>
	</class>
	<abstract path="lime.ui.KeyCode" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyCode.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="fromScanCode"><x path="lime.ui.ScanCode"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode" final="1">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="8" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x00</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="9" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 0x09" line="10" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x09</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="11" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x0D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="12" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x1B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="13" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="14" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXCLAMATION>
	<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="15" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUOTE>
	<HASH public="1" get="inline" set="null" expr="cast 0x23" line="16" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HASH>
	<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="17" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOLLAR>
	<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="18" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERCENT>
	<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="19" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AMPERSAND>
	<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="20" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="21" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_PARENTHESIS>
	<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="22" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_PARENTHESIS>
	<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="23" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="24" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="25" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="26" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="27" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="28" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="29" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="30" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="31" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="32" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="33" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="34" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="35" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="36" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="37" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="38" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="39" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="40" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="41" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="42" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="43" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="44" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" expr="cast 0x40" line="45" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT>
	<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="46" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="47" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="48" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="49" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="50" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDERSCORE>
	<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="51" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" expr="cast 0x61" line="52" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 0x62" line="53" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 0x63" line="54" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x63</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 0x64" line="55" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 0x65" line="56" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 0x66" line="57" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 0x67" line="58" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 0x68" line="59" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 0x69" line="60" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 0x6A" line="61" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 0x6B" line="62" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 0x6C" line="63" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 0x6D" line="64" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 0x6E" line="65" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 0x6F" line="66" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 0x70" line="67" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 0x71" line="68" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 0x72" line="69" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 0x73" line="70" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 0x74" line="71" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 0x75" line="72" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 0x76" line="73" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 0x77" line="74" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 0x78" line="75" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 0x79" line="76" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 0x7A" line="77" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="78" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="79" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000039</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="80" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="81" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="82" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="83" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="84" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="85" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="86" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000040</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="87" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000041</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="88" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000042</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="89" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000043</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="90" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000044</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="91" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000045</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="92" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000046</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="93" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000047</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="94" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000048</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="95" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000049</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="96" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="97" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="98" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="99" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="100" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="101" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000050</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="102" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000051</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="103" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000052</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="104" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000053</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="105" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000054</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="106" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000055</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="107" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000056</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="108" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000057</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="109" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000058</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="110" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000059</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="111" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="112" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="113" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="114" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="115" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="116" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="117" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000060</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="118" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000061</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="119" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000062</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="120" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000063</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="121" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000065</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="122" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000066</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="123" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000067</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="124" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000068</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="125" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000069</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="126" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="127" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="128" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="129" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="130" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="131" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="132" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000070</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="133" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000071</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="134" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000072</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="135" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000073</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="136" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000074</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="137" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000075</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="138" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000076</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="139" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000077</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="140" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000078</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="141" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000079</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="142" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="143" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="144" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="145" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="146" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="147" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="148" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000080</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="149" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000081</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="150" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000085</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="152" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000099</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="153" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="154" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="155" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="156" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="157" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="158" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="159" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="160" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="161" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="162" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="163" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="164" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="165" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="166" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="167" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="168" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="169" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="170" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="171" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="172" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="173" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="174" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="175" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="176" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="177" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="178" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="179" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="180" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="181" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="182" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="183" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="184" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="185" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="186" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="187" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="188" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="189" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="190" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="191" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="192" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="193" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="194" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="195" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="196" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="197" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="198" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="199" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="200" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="201" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="202" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="203" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="204" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="205" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="206" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="207" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="208" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="209" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="210" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="211" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="212" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="213" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="214" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="215" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="216" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="217" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="218" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="219" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="220" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="221" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="222" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="223" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="224" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="225" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000108</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="226" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="227" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="228" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="229" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="230" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="231" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="232" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="233" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="234" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000111</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="235" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="236" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="237" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="238" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="239" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="240" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="241" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="242" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="243" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000011A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<fromScanCode public="1" set="method" line="245" static="1">
		<f a="scanCode">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.KeyCode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromScanCode>
	<toScanCode set="method" line="255" static="1"><f a="keyCode">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.ScanCode"/>
</f></toScanCode>
	<gt get="inline" set="null" line="265" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="270" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="275" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="280" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<plus get="inline" set="null" line="285" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="Int"/>
			<x path="lime.ui.KeyCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode" final="1">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="8" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x00</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="9" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 0x09" line="10" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x09</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="11" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x0D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="12" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x1B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="13" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="14" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXCLAMATION>
		<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="15" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUOTE>
		<HASH public="1" get="inline" set="null" expr="cast 0x23" line="16" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HASH>
		<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="17" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOLLAR>
		<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="18" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERCENT>
		<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="19" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AMPERSAND>
		<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="20" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="21" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_PARENTHESIS>
		<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="22" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_PARENTHESIS>
		<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="23" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="24" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="25" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="26" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="27" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="28" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="29" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="30" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="31" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="32" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="33" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="34" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="35" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="36" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="37" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="38" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="39" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="40" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="41" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="42" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="43" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="44" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" expr="cast 0x40" line="45" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT>
		<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="46" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="47" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="48" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="49" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="50" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDERSCORE>
		<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="51" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" expr="cast 0x61" line="52" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 0x62" line="53" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 0x63" line="54" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x63</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 0x64" line="55" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 0x65" line="56" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 0x66" line="57" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 0x67" line="58" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 0x68" line="59" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 0x69" line="60" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 0x6A" line="61" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 0x6B" line="62" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 0x6C" line="63" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 0x6D" line="64" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 0x6E" line="65" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 0x6F" line="66" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 0x70" line="67" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 0x71" line="68" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 0x72" line="69" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 0x73" line="70" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 0x74" line="71" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 0x75" line="72" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 0x76" line="73" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 0x77" line="74" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 0x78" line="75" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 0x79" line="76" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 0x7A" line="77" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="78" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="79" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000039</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="80" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="81" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="82" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="83" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="84" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="85" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="86" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000040</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="87" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000041</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="88" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000042</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="89" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000043</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="90" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000044</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="91" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000045</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="92" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000046</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="93" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000047</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="94" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000048</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="95" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000049</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="96" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="97" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="98" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="99" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="100" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="101" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000050</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="102" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000051</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="103" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000052</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="104" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000053</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="105" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000054</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="106" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000055</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="107" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000056</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="108" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000057</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="109" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000058</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="110" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000059</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="111" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="112" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="113" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="114" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="115" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="116" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="117" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000060</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="118" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000061</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="119" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000062</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="120" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000063</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="121" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000065</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="122" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000066</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="123" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000067</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="124" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000068</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="125" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000069</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="126" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="127" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="128" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="129" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="130" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="131" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="132" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000070</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="133" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000071</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="134" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000072</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="135" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000073</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="136" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000074</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="137" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000075</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="138" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000076</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="139" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000077</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="140" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000078</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="141" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000079</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="142" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="143" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="144" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="145" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="146" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="147" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="148" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000080</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="149" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000081</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="150" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000085</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="152" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000099</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="153" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="154" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="155" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="156" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="157" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="158" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="159" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="160" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="161" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="162" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="163" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="164" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="165" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="166" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="167" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="168" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="169" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="170" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="171" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="172" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="173" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="174" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="175" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="176" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="177" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="178" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="179" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="180" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="181" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="182" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="183" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="184" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="185" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="186" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="187" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="188" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="189" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="190" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="191" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="192" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="193" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="194" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="195" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="196" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="197" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="198" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="199" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="200" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="201" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="202" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="203" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="204" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="205" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="206" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="207" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="208" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="209" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="210" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="211" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="212" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="213" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="214" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="215" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="216" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="217" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="218" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="219" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="220" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="221" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="222" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="223" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="224" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="225" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000108</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="226" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="227" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="228" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="229" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="230" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="231" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="232" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="233" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="234" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000111</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="235" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="236" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="237" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="238" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="239" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="240" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="241" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="242" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="243" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000011A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<fromScanCode public="1" set="method" line="245" static="1">
			<f a="scanCode">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.KeyCode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromScanCode>
		<toScanCode set="method" line="255" static="1"><f a="keyCode">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.ScanCode"/>
</f></toScanCode>
		<gt get="inline" set="null" line="265" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="270" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="275" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="280" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<plus get="inline" set="null" line="285" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="Int"/>
				<x path="lime.ui.KeyCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.KeyModifier" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyModifier.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier" final="1">
	<NONE public="1" get="inline" set="null" expr="0x0000" line="5" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0000</e></m></meta>
	</NONE>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="6" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0001</e></m></meta>
	</LEFT_SHIFT>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="7" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0002</e></m></meta>
	</RIGHT_SHIFT>
	<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="8" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0040</e></m></meta>
	</LEFT_CTRL>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="9" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0080</e></m></meta>
	</RIGHT_CTRL>
	<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="10" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0100</e></m></meta>
	</LEFT_ALT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="11" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0200</e></m></meta>
	</RIGHT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="12" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0400</e></m></meta>
	</LEFT_META>
	<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="13" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0800</e></m></meta>
	</RIGHT_META>
	<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="14" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x1000</e></m></meta>
	</NUM_LOCK>
	<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="15" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x2000</e></m></meta>
	</CAPS_LOCK>
	<MODE public="1" get="inline" set="null" expr="0x4000" line="16" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x4000</e></m></meta>
	</MODE>
	<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="17" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
	</CTRL>
	<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="18" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
	</SHIFT>
	<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="19" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
	</ALT>
	<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="20" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
	</META>
	<altKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</altKey>
	<capsLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</capsLock>
	<ctrlKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</ctrlKey>
	<metaKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</metaKey>
	<numLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</numLock>
	<shiftKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</shiftKey>
	<get_altKey set="method" line="29" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_altKey>
	<set_altKey get="inline" set="null" line="34" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_altKey>
	<get_capsLock set="method" line="48" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_capsLock>
	<set_capsLock get="inline" set="null" line="53" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_capsLock>
	<get_ctrlKey set="method" line="67" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_ctrlKey>
	<set_ctrlKey get="inline" set="null" line="72" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_ctrlKey>
	<get_metaKey set="method" line="86" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_metaKey>
	<set_metaKey get="inline" set="null" line="91" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_metaKey>
	<get_numLock set="method" line="105" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_numLock>
	<set_numLock get="inline" set="null" line="110" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_numLock>
	<get_shiftKey set="method" line="124" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_shiftKey>
	<set_shiftKey get="inline" set="null" line="129" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_shiftKey>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier" final="1">
		<NONE public="1" get="inline" set="null" expr="0x0000" line="5" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</NONE>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="6" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</LEFT_SHIFT>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="7" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</RIGHT_SHIFT>
		<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="8" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</LEFT_CTRL>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="9" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</RIGHT_CTRL>
		<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="10" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
		</LEFT_ALT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="11" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</RIGHT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="12" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0400</e></m></meta>
		</LEFT_META>
		<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="13" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0800</e></m></meta>
		</RIGHT_META>
		<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="14" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</NUM_LOCK>
		<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="15" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x2000</e></m></meta>
		</CAPS_LOCK>
		<MODE public="1" get="inline" set="null" expr="0x4000" line="16" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x4000</e></m></meta>
		</MODE>
		<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="17" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
		</CTRL>
		<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="18" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
		</SHIFT>
		<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="19" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
		</ALT>
		<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="20" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
		</META>
		<altKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</altKey>
		<capsLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</capsLock>
		<ctrlKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</ctrlKey>
		<metaKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</metaKey>
		<numLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</numLock>
		<shiftKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</shiftKey>
		<get_altKey set="method" line="29" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_altKey>
		<set_altKey get="inline" set="null" line="34" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_altKey>
		<get_capsLock set="method" line="48" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_capsLock>
		<set_capsLock get="inline" set="null" line="53" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_capsLock>
		<get_ctrlKey set="method" line="67" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_ctrlKey>
		<set_ctrlKey get="inline" set="null" line="72" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_ctrlKey>
		<get_metaKey set="method" line="86" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_metaKey>
		<set_metaKey get="inline" set="null" line="91" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_metaKey>
		<get_numLock set="method" line="105" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_numLock>
		<set_numLock get="inline" set="null" line="110" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_numLock>
		<get_shiftKey set="method" line="124" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_shiftKey>
		<set_shiftKey get="inline" set="null" line="129" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_shiftKey>
	</class>
	<abstract path="lime.ui.MouseButton" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/MouseButton.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/MouseButton.hx" private="1" module="lime.ui.MouseButton" extern="1" final="1">
	<LEFT public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIDDLE>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="lime.ui.MouseButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._MouseButton.MouseButton_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/MouseButton.hx" private="1" module="lime.ui.MouseButton" extern="1" final="1">
		<LEFT public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIDDLE>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="lime.ui.MouseButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<meta><m n=":enum"/></meta>
	</class>
	<enum path="lime.ui.MouseCursor" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/MouseCursor.hx">
		<ARROW/>
		<CROSSHAIR/>
		<DEFAULT/>
		<MOVE/>
		<POINTER/>
		<RESIZE_NESW/>
		<RESIZE_NS/>
		<RESIZE_NWSE/>
		<RESIZE_WE/>
		<TEXT/>
		<WAIT/>
		<WAIT_ARROW/>
		<CUSTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="lime.ui.MouseWheelMode" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/MouseWheelMode.hx">
		<PIXELS/>
		<LINES/>
		<PAGES/>
		<UNKNOWN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.ui.ScanCode" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/ScanCode.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="fromKeyCode"><x path="lime.ui.KeyCode"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>lime.ui.KeyCode</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.ui._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/ScanCode.hx" private="1" module="lime.ui.ScanCode" final="1">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="10" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 42</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 43" line="11" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 43</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" expr="cast 40" line="12" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="13" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" expr="cast 44" line="14" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 44</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 52" line="21" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<COMMA public="1" get="inline" set="null" expr="cast 54" line="26" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 45" line="27" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 55" line="28" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 56" line="29" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" expr="cast 39" line="30" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" expr="cast 30" line="31" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" expr="cast 31" line="32" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" expr="cast 32" line="33" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" expr="cast 33" line="34" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" expr="cast 34" line="35" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" expr="cast 35" line="36" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" expr="cast 36" line="37" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" expr="cast 37" line="38" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" expr="cast 38" line="39" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="41" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<EQUALS public="1" get="inline" set="null" expr="cast 46" line="43" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 47" line="47" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 47</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="48" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 48" line="49" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<GRAVE public="1" get="inline" set="null" expr="cast 53" line="52" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" expr="cast 4" line="53" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 5" line="54" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 6" line="55" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 7" line="56" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 8" line="57" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 9" line="58" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 10" line="59" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 11" line="60" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 12" line="61" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 13" line="62" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 14" line="63" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 15" line="64" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 16" line="65" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 17" line="66" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 18" line="67" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 19" line="68" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 20" line="69" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 21" line="70" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 22" line="71" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 23" line="72" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 24" line="73" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 25" line="74" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 26" line="75" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 27" line="76" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 28" line="77" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 29" line="78" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" expr="cast 76" line="79" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" expr="cast 57" line="80" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" expr="cast 58" line="81" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 58</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 59" line="82" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 59</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 60" line="83" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 61" line="84" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 62" line="85" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 63" line="86" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 63</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 64" line="87" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 65" line="88" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 66" line="89" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 67" line="90" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 68" line="91" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 69" line="92" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 70" line="93" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 71" line="94" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 72" line="95" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 73" line="96" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 74" line="97" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" expr="cast 75" line="98" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" expr="cast 77" line="99" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" expr="cast 78" line="100" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 79" line="101" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 80" line="102" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 81" line="103" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 81</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 82" line="104" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 82</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" expr="cast 83" line="105" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 83</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="106" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 84</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="107" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 85</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 86" line="108" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 86</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 87" line="109" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 87</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 88" line="110" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 88</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" expr="cast 89" line="111" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 89</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" expr="cast 90" line="112" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" expr="cast 91" line="113" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 91</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" expr="cast 92" line="114" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 92</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" expr="cast 93" line="115" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 93</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" expr="cast 94" line="116" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 94</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" expr="cast 95" line="117" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 95</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" expr="cast 96" line="118" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" expr="cast 97" line="119" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" expr="cast 98" line="120" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 99" line="121" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="122" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 102" line="123" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 103" line="124" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 104" line="125" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 105" line="126" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 106" line="127" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 107" line="128" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 108" line="129" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 108</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 109" line="130" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 110" line="131" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 111" line="132" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 111</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 112" line="133" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 113" line="134" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 114" line="135" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 115" line="136" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="137" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 117" line="138" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 118" line="139" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 119" line="140" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 120" line="141" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 121" line="142" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 122" line="143" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 123" line="144" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 123</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 124" line="145" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 124</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 125" line="146" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 125</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 126" line="147" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 126</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 127" line="148" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 127</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" expr="cast 128" line="149" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 128</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 129" line="150" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 129</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 133" line="151" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 133</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" expr="cast 153" line="153" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 153</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 154" line="154" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 154</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" expr="cast 155" line="155" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 155</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 156" line="156" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 156</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 157" line="157" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 157</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="158" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 158</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="159" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 159</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 160" line="160" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 160</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 161" line="161" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 161</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 162" line="162" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 162</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 163" line="163" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 163</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 164" line="164" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 164</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" expr="cast 176" line="165" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 176</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" expr="cast 177" line="166" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 177</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 178" line="167" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 178</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 179" line="168" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 179</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 180" line="169" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 180</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 181" line="170" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 181</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 182" line="171" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 182</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 183" line="172" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 183</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 184" line="173" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 184</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 185" line="174" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 185</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 186" line="175" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 186</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="176" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 187</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" expr="cast 188" line="177" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 188</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" expr="cast 189" line="178" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 189</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" expr="cast 190" line="179" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 190</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" expr="cast 191" line="180" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 191</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" expr="cast 192" line="181" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 192</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" expr="cast 193" line="182" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 193</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 194" line="183" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 194</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 195" line="184" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 195</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 196" line="185" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 196</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 197" line="186" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 197</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 198" line="187" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 198</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="188" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 199</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 200" line="189" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 201" line="190" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 201</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 202" line="191" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 202</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 203" line="192" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 203</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 204" line="193" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 204</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 205" line="194" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 205</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" expr="cast 206" line="195" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 206</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 207" line="196" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 207</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 208" line="197" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 208</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 209" line="198" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 209</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 210" line="199" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 210</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 211" line="200" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 211</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 212" line="201" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 212</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 213" line="202" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 213</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 214" line="203" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 214</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 215" line="204" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 215</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 216" line="205" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 216</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 217" line="206" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 217</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 218" line="207" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 218</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 219" line="208" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 219</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="209" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 220</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="210" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 221</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" expr="cast 224" line="211" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 224</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 225" line="212" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 225</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" expr="cast 226" line="213" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 226</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="cast 227" line="214" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 227</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 228" line="215" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 228</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 229" line="216" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 229</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="cast 230" line="217" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 230</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" expr="cast 231" line="218" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 231</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" expr="cast 257" line="219" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 257</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 258" line="220" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 258</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 259" line="221" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 259</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" expr="cast 260" line="222" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 260</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 261" line="223" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 261</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 262" line="224" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 262</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 263" line="225" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 263</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" expr="cast 264" line="226" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 264</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 265" line="227" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 265</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="228" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 266</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="229" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 267</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 268" line="230" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 268</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 269" line="231" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 269</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 270" line="232" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 270</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 271" line="233" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 271</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 272" line="234" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 272</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 273" line="235" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 273</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="236" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 274</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 275" line="237" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 275</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 276" line="238" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 276</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 277" line="239" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 277</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 278" line="240" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 278</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 279" line="241" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 279</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 280" line="242" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 280</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" expr="cast 281" line="243" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 281</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 282" line="244" static="1">
		<x path="lime.ui.ScanCode"/>
		<meta>
			<m n=":value"><e>cast 282</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<fromKeyCode public="1" set="method" line="246" static="1">
		<f a="keyCode">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.ScanCode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromKeyCode>
	<toKeyCode set="method" line="251" static="1"><f a="scanCode">
	<x path="lime.ui.ScanCode"/>
	<x path="lime.ui.KeyCode"/>
</f></toKeyCode>
	<gt get="inline" set="null" line="256" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="261" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="266" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="271" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="lime.ui.ScanCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<plus get="inline" set="null" line="276" static="1">
		<f a="a:b">
			<x path="lime.ui.ScanCode"/>
			<x path="Int"/>
			<x path="lime.ui.ScanCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<meta>
		<m n=":enum"/>
		<m n=":access"><e>lime.ui.KeyCode</e></m>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._ScanCode.ScanCode_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/ScanCode.hx" private="1" module="lime.ui.ScanCode" final="1">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 42" line="10" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 42</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 43" line="11" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 43</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" expr="cast 40" line="12" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" expr="cast 41" line="13" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="cast 44" line="14" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 44</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 52" line="21" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<COMMA public="1" get="inline" set="null" expr="cast 54" line="26" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 45" line="27" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 55" line="28" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 56" line="29" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" expr="cast 39" line="30" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="cast 30" line="31" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="cast 31" line="32" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="cast 32" line="33" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="cast 33" line="34" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="cast 34" line="35" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="cast 35" line="36" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="cast 36" line="37" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="cast 37" line="38" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="cast 38" line="39" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 51" line="41" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<EQUALS public="1" get="inline" set="null" expr="cast 46" line="43" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 47" line="47" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 47</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 49" line="48" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 48" line="49" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<GRAVE public="1" get="inline" set="null" expr="cast 53" line="52" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" expr="cast 4" line="53" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 5" line="54" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 6" line="55" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 7" line="56" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 8" line="57" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 9" line="58" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 10" line="59" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 11" line="60" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 12" line="61" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 13" line="62" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 14" line="63" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 15" line="64" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 16" line="65" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 17" line="66" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 18" line="67" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 19" line="68" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 20" line="69" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 21" line="70" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 22" line="71" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 23" line="72" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 24" line="73" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 25" line="74" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 26" line="75" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 27" line="76" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 28" line="77" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 29" line="78" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" expr="cast 76" line="79" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="cast 57" line="80" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" expr="cast 58" line="81" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 58</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 59" line="82" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 59</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 60" line="83" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 61" line="84" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 62" line="85" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 63" line="86" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 63</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 64" line="87" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 65" line="88" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 66" line="89" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 67" line="90" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 68" line="91" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 69" line="92" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 70" line="93" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 71" line="94" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 72" line="95" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 73" line="96" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 74" line="97" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" expr="cast 75" line="98" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" expr="cast 77" line="99" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" expr="cast 78" line="100" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 79" line="101" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 80" line="102" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 81" line="103" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 81</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 82" line="104" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 82</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" expr="cast 83" line="105" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 83</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 84" line="106" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 84</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 85" line="107" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 85</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 86" line="108" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 86</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 87" line="109" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 87</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 88" line="110" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 88</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" expr="cast 89" line="111" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 89</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="cast 90" line="112" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="cast 91" line="113" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 91</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="cast 92" line="114" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 92</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="cast 93" line="115" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 93</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="cast 94" line="116" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 94</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="cast 95" line="117" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 95</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="cast 96" line="118" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="cast 97" line="119" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="cast 98" line="120" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 99" line="121" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 101" line="122" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 102" line="123" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 103" line="124" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 104" line="125" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 105" line="126" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 106" line="127" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 107" line="128" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 108" line="129" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 108</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 109" line="130" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 110" line="131" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 111" line="132" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 111</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 112" line="133" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 113" line="134" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 114" line="135" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 115" line="136" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 116" line="137" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 117" line="138" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 118" line="139" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 119" line="140" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 120" line="141" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 121" line="142" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 122" line="143" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 123" line="144" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 123</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 124" line="145" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 124</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 125" line="146" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 125</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 126" line="147" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 126</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 127" line="148" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 127</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" expr="cast 128" line="149" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 128</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 129" line="150" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 129</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 133" line="151" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 133</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" expr="cast 153" line="153" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 153</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 154" line="154" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 154</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" expr="cast 155" line="155" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 155</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 156" line="156" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 156</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 157" line="157" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 157</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 158" line="158" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 158</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 159" line="159" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 159</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 160" line="160" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 160</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 161" line="161" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 161</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 162" line="162" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 162</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 163" line="163" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 163</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 164" line="164" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 164</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" expr="cast 176" line="165" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 176</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" expr="cast 177" line="166" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 177</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 178" line="167" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 178</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 179" line="168" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 179</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 180" line="169" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 180</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 181" line="170" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 181</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 182" line="171" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 182</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 183" line="172" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 183</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 184" line="173" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 184</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 185" line="174" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 185</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 186" line="175" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 186</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 187" line="176" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 187</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" expr="cast 188" line="177" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 188</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" expr="cast 189" line="178" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 189</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" expr="cast 190" line="179" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 190</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" expr="cast 191" line="180" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 191</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" expr="cast 192" line="181" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 192</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" expr="cast 193" line="182" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 193</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 194" line="183" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 194</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 195" line="184" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 195</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 196" line="185" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 196</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 197" line="186" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 197</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 198" line="187" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 198</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 199" line="188" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 199</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 200" line="189" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 201" line="190" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 201</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 202" line="191" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 202</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 203" line="192" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 203</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 204" line="193" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 204</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 205" line="194" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 205</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" expr="cast 206" line="195" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 206</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 207" line="196" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 207</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 208" line="197" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 208</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 209" line="198" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 209</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 210" line="199" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 210</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 211" line="200" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 211</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 212" line="201" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 212</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 213" line="202" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 213</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 214" line="203" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 214</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 215" line="204" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 215</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 216" line="205" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 216</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 217" line="206" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 217</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 218" line="207" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 218</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 219" line="208" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 219</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 220" line="209" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 220</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 221" line="210" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 221</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" expr="cast 224" line="211" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 224</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 225" line="212" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 225</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" expr="cast 226" line="213" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 226</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="cast 227" line="214" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 227</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 228" line="215" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 228</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 229" line="216" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 229</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="cast 230" line="217" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 230</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" expr="cast 231" line="218" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 231</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" expr="cast 257" line="219" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 257</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 258" line="220" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 258</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 259" line="221" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 259</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" expr="cast 260" line="222" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 260</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 261" line="223" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 261</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 262" line="224" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 262</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 263" line="225" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 263</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" expr="cast 264" line="226" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 264</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 265" line="227" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 265</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 266" line="228" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 266</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 267" line="229" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 267</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 268" line="230" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 268</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 269" line="231" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 269</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 270" line="232" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 270</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 271" line="233" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 271</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 272" line="234" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 272</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 273" line="235" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 273</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 274" line="236" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 274</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 275" line="237" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 275</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 276" line="238" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 276</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 277" line="239" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 277</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 278" line="240" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 278</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 279" line="241" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 279</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 280" line="242" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 280</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" expr="cast 281" line="243" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 281</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 282" line="244" static="1">
			<x path="lime.ui.ScanCode"/>
			<meta>
				<m n=":value"><e>cast 282</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<fromKeyCode public="1" set="method" line="246" static="1">
			<f a="keyCode">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.ScanCode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromKeyCode>
		<toKeyCode set="method" line="251" static="1"><f a="scanCode">
	<x path="lime.ui.ScanCode"/>
	<x path="lime.ui.KeyCode"/>
</f></toKeyCode>
		<gt get="inline" set="null" line="256" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="261" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="266" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="271" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="lime.ui.ScanCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<plus get="inline" set="null" line="276" static="1">
			<f a="a:b">
				<x path="lime.ui.ScanCode"/>
				<x path="Int"/>
				<x path="lime.ui.ScanCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<meta>
			<m n=":enum"/>
			<m n=":access"><e>lime.ui.KeyCode</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		</meta>
	</class>
	<class path="lime.ui.Touch" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Touch.hx">
		<onCancel public="1" expr="new Event&lt;Touch&gt;()" line="11" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onCancel>
		<onEnd public="1" expr="new Event&lt;Touch&gt;()" line="12" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onEnd>
		<onMove public="1" expr="new Event&lt;Touch&gt;()" line="13" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onMove>
		<onStart public="1" expr="new Event&lt;Touch&gt;()" line="14" static="1">
			<c path="lime.app._Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onStart>
		<device public="1"><x path="Int"/></device>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<id public="1"><x path="Int"/></id>
		<pressure public="1"><x path="Float"/></pressure>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="24"><f a="x:y:id:dx:dy:pressure:device">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.ui.Window" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx">
		<application public="1" set="null"><c path="lime.app.Application"/></application>
		<borderless public="1" get="accessor" set="accessor"><x path="Bool"/></borderless>
		<context public="1" set="null"><c path="lime.graphics.RenderContext"/></context>
		<cursor public="1" get="accessor" set="accessor"><e path="lime.ui.MouseCursor"/></cursor>
		<display public="1" get="accessor" set="null"><c path="lime.system.Display"/></display>
		<displayMode public="1" get="accessor" set="accessor"><c path="lime.system.DisplayMode"/></displayMode>
		<frameRate public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The current frame rate (measured in frames-per-second) of the window.
	 *
	 * On some platforms, a frame rate of 60 or greater may imply vsync, which will
	 * perform more quickly on displays with a higher refresh rate</haxe_doc>
		</frameRate>
		<fullscreen public="1" get="accessor" set="accessor"><x path="Bool"/></fullscreen>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<hidden public="1" get="accessor" set="null"><x path="Bool"/></hidden>
		<id public="1" set="null"><x path="Int"/></id>
		<maximized public="1" get="accessor" set="accessor"><x path="Bool"/></maximized>
		<minimized public="1" get="accessor" set="accessor"><x path="Bool"/></minimized>
		<mouseLock public="1" get="accessor" set="accessor"><x path="Bool"/></mouseLock>
		<onActivate public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onActivate>
		<onClose public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onClose>
		<onDeactivate public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDeactivate>
		<onDropFile public="1" set="null" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onDropFile>
		<onEnter public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onEnter>
		<onExpose public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onExpose>
		<onFocusIn public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusIn>
		<onFocusOut public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusOut>
		<onFullscreen public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFullscreen>
		<onKeyDown public="1" set="null" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyDown>
		<onKeyUp public="1" set="null" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app._Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyUp>
		<onLeave public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onLeave>
		<onMaximize public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onMaximize>
		<onMinimize public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onMinimize>
		<onMouseDown public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; MouseButton&gt;()">
			<c path="lime.app._Event_Float_Float_lime_ui_MouseButton_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.ui.MouseButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> MouseButton>()]]></e></m></meta>
		</onMouseDown>
		<onMouseMove public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; Int&gt;()">
			<c path="lime.app._Event_Float_Float_Int_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Int>()]]></e></m></meta>
		</onMouseUp>
		<onMouseWheel public="1" set="null" expr="new Event&lt;Float -&gt; Float -&gt; MouseWheelMode&gt;()">
			<c path="lime.app._Event_Float_Float_lime_ui_MouseWheelMode_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<e path="lime.ui.MouseWheelMode"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> MouseWheelMode>()]]></e></m></meta>
		</onMouseWheel>
		<onMove public="1" set="null" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app._Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMove>
		<onRender public="1" set="null" expr="new Event&lt;RenderContext&gt;()">
			<c path="lime.app._Event_lime_graphics_RenderContext_Void"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<RenderContext>()]]></e></m></meta>
		</onRender>
		<onRenderContextLost public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="null" expr="new Event&lt;RenderContext&gt;()">
			<c path="lime.app._Event_lime_graphics_RenderContext_Void"><f a="">
	<c path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<RenderContext>()]]></e></m></meta>
		</onRenderContextRestored>
		<onResize public="1" set="null" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onResize>
		<onRestore public="1" set="null" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRestore>
		<onTextEdit public="1" set="null" expr="new Event&lt;String -&gt; Int -&gt; Int&gt;()">
			<c path="lime.app._Event_String_Int_Int_Void"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String -> Int -> Int>()]]></e></m></meta>
		</onTextEdit>
		<onTextInput public="1" set="null" expr="new Event&lt;String&gt;()">
			<c path="lime.app._Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onTextInput>
		<parameters public="1"><d/></parameters>
		<resizable public="1" get="accessor" set="accessor"><x path="Bool"/></resizable>
		<scale public="1" get="accessor" set="null"><x path="Float"/></scale>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<textInputEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></textInputEnabled>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<__attributes>
			<t path="lime.ui.WindowAttributes"/>
			<meta><m n=":noCompletion"/></meta>
		</__attributes>
		<__backend>
			<t path="lime.ui._Window.WindowBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</__backend>
		<__borderless>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__borderless>
		<__fullscreen>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__fullscreen>
		<__height>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__height>
		<__hidden>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__hidden>
		<__maximized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__maximized>
		<__minimized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__minimized>
		<__resizable>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__resizable>
		<__scale>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__scale>
		<__title>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__title>
		<__width>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__width>
		<__x>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__x>
		<__y>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__y>
		<alert public="1" set="method" line="360">
			<f a="?message:?title" v="null:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ title : null, message : null }</e></m></meta>
		</alert>
		<close public="1" set="method" line="365"><f a=""><x path="Void"/></f></close>
		<focus public="1" set="method" line="370"><f a=""><x path="Void"/></f></focus>
		<move public="1" set="method" line="375"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<readPixels public="1" set="method" line="383">
			<f a="?rect" v="null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</readPixels>
		<resize public="1" set="method" line="388"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setIcon public="1" set="method" line="396"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<toString public="1" set="method" line="406"><f a=""><c path="String"/></f></toString>
		<warpMouse public="1" set="method" line="411"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></warpMouse>
		<get_cursor set="method" line="417">
			<f a=""><e path="lime.ui.MouseCursor"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cursor>
		<set_cursor set="method" line="422">
			<f a="value">
				<e path="lime.ui.MouseCursor"/>
				<e path="lime.ui.MouseCursor"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cursor>
		<get_display set="method" line="427">
			<f a=""><c path="lime.system.Display"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_display>
		<get_displayMode set="method" line="432">
			<f a=""><c path="lime.system.DisplayMode"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_displayMode>
		<set_displayMode set="method" line="437">
			<f a="value">
				<c path="lime.system.DisplayMode"/>
				<c path="lime.system.DisplayMode"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_displayMode>
		<get_borderless get="inline" set="null" line="442">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_borderless>
		<set_borderless set="method" line="447">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_borderless>
		<get_frameRate get="inline" set="null" line="452">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_frameRate>
		<set_frameRate get="inline" set="null" line="457">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_frameRate>
		<get_fullscreen get="inline" set="null" line="462">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fullscreen>
		<set_fullscreen set="method" line="467">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fullscreen>
		<get_height get="inline" set="null" line="472">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="477">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_hidden get="inline" set="null" line="483">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hidden>
		<get_maximized get="inline" set="null" line="488">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_maximized>
		<set_maximized get="inline" set="null" line="493">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_maximized>
		<get_minimized get="inline" set="null" line="499">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_minimized>
		<set_minimized set="method" line="504">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_minimized>
		<get_mouseLock set="method" line="510">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseLock>
		<set_mouseLock set="method" line="515">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mouseLock>
		<get_resizable get="inline" set="null" line="521">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_resizable>
		<set_resizable set="method" line="526">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_resizable>
		<get_scale get="inline" set="null" line="532">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<get_textInputEnabled get="inline" set="null" line="537">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_textInputEnabled>
		<set_textInputEnabled get="inline" set="null" line="542">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_textInputEnabled>
		<get_title get="inline" set="null" line="547">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_title>
		<set_title set="method" line="552">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_title>
		<get_width get="inline" set="null" line="557">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width set="method" line="562">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<get_x get="inline" set="null" line="568">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_x>
		<set_x set="method" line="573">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_x>
		<get_y get="inline" set="null" line="579">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_y>
		<set_y set="method" line="584">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_y>
		<new set="method" line="137">
			<f a="application:attributes">
				<c path="lime.app.Application"/>
				<t path="lime.ui.WindowAttributes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<typedef path="lime.ui._Window.WindowBackend" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<c path="lime._internal.backend.flash.FlashWindow"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<typedef path="lime.ui.WindowAttributes" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/ui/WindowAttributes.hx"><a>
	<y>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</x>
	<width>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</width>
	<title>
		<x path="Null"><c path="String"/></x>
		<meta><m n=":optional"/></meta>
	</title>
	<resizable>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</resizable>
	<parameters>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</parameters>
	<minimized>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</minimized>
	<maximized>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</maximized>
	<hidden>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</hidden>
	<height>
		<x path="Null"><x path="Int"/></x>
		<meta><m n=":optional"/></meta>
	</height>
	<fullscreen>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</fullscreen>
	<frameRate>
		<x path="Null"><x path="Float"/></x>
		<meta><m n=":optional"/></meta>
	</frameRate>
	<element>
		<x path="Null"><d/></x>
		<meta><m n=":optional"/></meta>
	</element>
	<context>
		<x path="Null"><t path="lime.graphics.RenderContextAttributes"/></x>
		<meta><m n=":optional"/></meta>
	</context>
	<borderless>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</borderless>
	<alwaysOnTop>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</alwaysOnTop>
	<allowHighDPI>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</allowHighDPI>
</a></typedef>
	<abstract path="lime.utils.ArrayBuffer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBuffer.hx">
		<from>
			<icast><d/></icast>
			<icast><c path="haxe.io.Bytes"/></icast>
		</from>
		<this><c path="haxe.io.Bytes"/></this>
		<to>
			<icast><d/></icast>
			<icast><c path="haxe.io.Bytes"/></icast>
		</to>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer" final="1">
	<byteLength public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</byteLength>
	<get_byteLength get="inline" set="null" line="16" static="1">
		<f a="this">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_byteLength>
	<_new public="1" get="inline" set="null" line="21" static="1">
		<f a="byteLength">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<isView public="1" get="inline" set="null" line="26" static="1"><f a="arg">
	<d/>
	<x path="Bool"/>
</f></isView>
	<slice public="1" get="inline" set="null" line="31" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</slice>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer" final="1">
		<byteLength public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</byteLength>
		<get_byteLength get="inline" set="null" line="16" static="1">
			<f a="this">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_byteLength>
		<_new public="1" get="inline" set="null" line="21" static="1">
			<f a="byteLength">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<isView public="1" get="inline" set="null" line="26" static="1"><f a="arg">
	<d/>
	<x path="Bool"/>
</f></isView>
		<slice public="1" get="inline" set="null" line="31" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</slice>
	</class>
	<abstract path="lime.utils.TypedArrayType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1" final="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="406" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Int8 public="1" get="inline" set="null" expr="cast 1" line="407" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int8>
	<Int16 public="1" get="inline" set="null" expr="cast 2" line="408" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int16>
	<Int32 public="1" get="inline" set="null" expr="cast 3" line="409" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int32>
	<Uint8 public="1" get="inline" set="null" expr="cast 4" line="410" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8>
	<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="411" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8Clamped>
	<Uint16 public="1" get="inline" set="null" expr="cast 6" line="412" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint16>
	<Uint32 public="1" get="inline" set="null" expr="cast 7" line="413" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint32>
	<Float32 public="1" get="inline" set="null" expr="cast 8" line="414" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float32>
	<Float64 public="1" get="inline" set="null" expr="cast 9" line="415" static="1">
		<x path="lime.utils.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float64>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1" final="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="406" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Int8 public="1" get="inline" set="null" expr="cast 1" line="407" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int8>
		<Int16 public="1" get="inline" set="null" expr="cast 2" line="408" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int16>
		<Int32 public="1" get="inline" set="null" expr="cast 3" line="409" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int32>
		<Uint8 public="1" get="inline" set="null" expr="cast 4" line="410" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8>
		<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="411" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8Clamped>
		<Uint16 public="1" get="inline" set="null" expr="cast 6" line="412" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint16>
		<Uint32 public="1" get="inline" set="null" expr="cast 7" line="413" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint32>
		<Float32 public="1" get="inline" set="null" expr="cast 8" line="414" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float32>
		<Float64 public="1" get="inline" set="null" expr="cast 9" line="415" static="1">
			<x path="lime.utils.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float64>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.utils.ArrayBufferIO" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<getInt8 public="1" get="inline" set="null" line="424" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt8>
		<setInt8 public="1" get="inline" set="null" line="438" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt8>
		<getUint8 public="1" get="inline" set="null" line="454" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint8>
		<setUint8Clamped public="1" get="inline" set="null" line="467" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint8Clamped>
		<setUint8 public="1" get="inline" set="null" line="476" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint8>
		<getInt16 public="1" set="method" line="491" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getInt16_BE public="1" set="method" line="505" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16_BE>
		<setInt16 public="1" set="method" line="519" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setInt16_BE public="1" set="method" line="534" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16_BE>
		<getUint16 public="1" get="inline" set="null" line="551" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint16>
		<getUint16_BE public="1" get="inline" set="null" line="567" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint16_BE>
		<setUint16 public="1" get="inline" set="null" line="583" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint16>
		<setUint16_BE public="1" get="inline" set="null" line="596" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint16_BE>
		<getInt32 public="1" get="inline" set="null" line="611" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt32>
		<getInt32_BE public="1" get="inline" set="null" line="624" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getInt32_BE>
		<setInt32 public="1" get="inline" set="null" line="637" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt32>
		<setInt32_BE public="1" get="inline" set="null" line="654" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setInt32_BE>
		<getUint32 public="1" get="inline" set="null" line="671" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint32>
		<getUint32_BE public="1" get="inline" set="null" line="684" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta><m n=":extern"/></meta>
		</getUint32_BE>
		<setUint32 public="1" get="inline" set="null" line="697" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint32>
		<setUint32_BE public="1" get="inline" set="null" line="710" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setUint32_BE>
		<getFloat32 public="1" get="inline" set="null" line="724" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat32>
		<getFloat32_BE public="1" get="inline" set="null" line="737" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat32_BE>
		<setFloat32 public="1" get="inline" set="null" line="750" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat32>
		<setFloat32_BE public="1" get="inline" set="null" line="766" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat32_BE>
		<getFloat64 public="1" get="inline" set="null" line="782" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat64>
		<getFloat64_BE public="1" get="inline" set="null" line="795" static="1">
			<f a="buffer:byteOffset">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":extern"/></meta>
		</getFloat64_BE>
		<setFloat64 public="1" get="inline" set="null" line="808" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat64>
		<setFloat64_BE public="1" get="inline" set="null" line="824" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":extern"/></meta>
		</setFloat64_BE>
		<_clamp get="inline" set="null" line="841" static="1">
			<f a="_in">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":extern"/></meta>
		</_clamp>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lime.utils.AssetBundle" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetBundle.hx">
		<fromBytes public="1" set="method" line="29" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.utils.AssetBundle"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.utils.AssetBundle"/>
</f></fromFile>
		<loadFromBytes public="1" set="method" line="45" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetBundle"/></c>
</f></loadFromBytes>
		<loadFromFile public="1" set="method" line="50" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetBundle"/></c>
</f></loadFromFile>
		<__extractBundle set="method" line="55" static="1">
			<f a="input">
				<c path="haxe.io.Input"/>
				<c path="lime.utils.AssetBundle"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__extractBundle>
		<data public="1"><t path="Map">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</t></data>
		<paths public="1"><c path="Array"><c path="String"/></c></paths>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.utils.AssetCache" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetCache.hx">
		<audio public="1"><t path="Map">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</t></audio>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<image public="1"><t path="Map">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</t></image>
		<font public="1"><t path="Map">
	<c path="String"/>
	<d/>
</t></font>
		<version public="1"><x path="Int"/></version>
		<exists public="1" set="method" line="37"><f a="id:?type">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<set public="1" set="method" line="57"><f a="id:type:asset">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<d/>
	<x path="Void"/>
</f></set>
		<clear public="1" set="method" line="79">
			<f a="?prefix" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prefix : null }</e></m></meta>
		</clear>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<class path="lime.utils.AssetLibrary" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetLibrary.hx">
		<fromBytes public="1" set="method" line="89" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="94" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<fromBundle public="1" set="method" line="99" static="1"><f a="bundle">
	<c path="lime.utils.AssetBundle"/>
	<c path="lime.utils.AssetLibrary"/>
</f></fromBundle>
		<fromManifest public="1" set="method" line="140" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.utils.AssetLibrary"/>
</f></fromManifest>
		<loadFromBytes public="1" set="method" line="528" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="536" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<loadFromManifest public="1" set="method" line="544" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
</f></loadFromManifest>
		<onChange public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<assetsLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</assetsLoaded>
		<assetsTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</assetsTotal>
		<bytesLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoaded>
		<bytesLoadedCache>
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoadedCache>
		<bytesTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesTotal>
		<cachedAudioBuffers expr="new Map&lt;String,AudioBuffer&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.media.AudioBuffer"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,AudioBuffer>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedAudioBuffers>
		<cachedBytes expr="new Map&lt;String,Bytes&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Bytes>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedBytes>
		<cachedFonts expr="new Map&lt;String,Font&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.text.Font"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Font>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedFonts>
		<cachedImages expr="new Map&lt;String,Image&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Image>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedImages>
		<cachedText expr="new Map&lt;String,String&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</cachedText>
		<classTypes expr="new Map&lt;String,Class&lt;Dynamic&gt;&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Class"><d/></x>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Class<Dynamic>>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</classTypes>
		<loaded>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</loaded>
		<pathGroups expr="new Map&lt;String,Array&lt;String&gt;&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Array<String>>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</pathGroups>
		<paths expr="new Map&lt;String,String&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</paths>
		<preload expr="new Map&lt;String,Bool&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Bool>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</preload>
		<promise>
			<c path="lime.app.Promise_lime_utils_AssetLibrary"/>
			<meta><m n=":noCompletion"/></meta>
		</promise>
		<sizes expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</sizes>
		<types expr="new Map&lt;String,AssetType&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,AssetType>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</types>
		<exists public="1" set="method" line="52"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAsset public="1" set="method" line="170"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAsset>
		<getAudioBuffer public="1" set="method" line="185"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="207"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="246"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="270"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="290"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getText public="1" set="method" line="306"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="327"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="355"><f a="type">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<loadAsset public="1" set="method" line="371"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<c path="lime.app.Future"><d/></c>
</f></loadAsset>
		<load public="1" set="method" line="386"><f a=""><c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c></f></load>
		<loadAudioBuffer public="1" set="method" line="459"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="482"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="502"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="558"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
</f></loadImage>
		<loadText public="1" set="method" line="583"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<unload public="1" set="method" line="611"><f a=""><x path="Void"/></f></unload>
		<__assetLoaded set="method" line="613">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__assetLoaded>
		<__cacheBreak set="method" line="655">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__cacheBreak>
		<__fromBundle set="method" line="660">
			<f a="bundle:?manifest" v=":null">
				<c path="lime.utils.AssetBundle"/>
				<c path="lime.utils.AssetManifest"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ manifest : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__fromBundle>
		<__fromManifest set="method" line="707">
			<f a="manifest">
				<c path="lime.utils.AssetManifest"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromManifest>
		<__resolvePath set="method" line="774">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__resolvePath>
		<loadAudioBuffer_onComplete set="method" line="834">
			<f a="id:audioBuffer">
				<c path="String"/>
				<c path="lime.media.AudioBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadAudioBuffer_onComplete>
		<loadAudioBuffer_onError set="method" line="860">
			<f a="id:message">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadAudioBuffer_onError>
		<loadBytes_onComplete set="method" line="878">
			<f a="id:bytes">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadBytes_onComplete>
		<loadFont_onComplete set="method" line="884">
			<f a="id:font">
				<c path="String"/>
				<c path="lime.text.Font"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadFont_onComplete>
		<loadImage_onComplete set="method" line="890">
			<f a="id:image">
				<c path="String"/>
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadImage_onComplete>
		<loadText_onComplete set="method" line="896">
			<f a="id:text">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loadText_onComplete>
		<load_onError set="method" line="902">
			<f a="id:message">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</load_onError>
		<load_onProgress set="method" line="914">
			<f a="id:bytesLoaded:bytesTotal">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</load_onProgress>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime.text.Font</e></m>
			<m n=":access"><e>lime.utils.Assets</e></m>
		</meta>
	</class>
	<class path="lime.utils.AssetManifest" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetManifest.hx">
		<fromBytes public="1" set="method" line="32" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="44" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<loadFromBytes public="1" set="method" line="54" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetManifest"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="59" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.AssetManifest"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<parse public="1" set="method" line="72" static="1">
			<f a="data:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.AssetManifest"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</parse>
		<__resolvePath set="method" line="148" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></__resolvePath>
		<__resolveRootPath set="method" line="188" static="1"><f a="rootPath:path">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></__resolveRootPath>
		<assets public="1"><c path="Array"><d/></c></assets>
		<libraryArgs public="1"><c path="Array"><c path="String"/></c></libraryArgs>
		<libraryType public="1"><c path="String"/></libraryType>
		<name public="1"><c path="String"/></name>
		<rootPath public="1"><c path="String"/></rootPath>
		<version public="1"><x path="Int"/></version>
		<serialize public="1" set="method" line="131"><f a=""><c path="String"/></f></serialize>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.AssetType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetType.hx">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.utils._AssetType.AssetType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetType.hx" private="1" module="lime.utils.AssetType" extern="1" final="1">
	<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="5" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "BINARY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="6" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "FONT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="7" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "IMAGE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MANIFEST public="1" get="inline" set="null" expr="cast &quot;MANIFEST&quot;" line="8" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MANIFEST"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MANIFEST>
	<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="9" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MUSIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="10" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "SOUND"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="11" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEMPLATE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="12" static="1">
		<x path="lime.utils.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEXT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._AssetType.AssetType_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/AssetType.hx" private="1" module="lime.utils.AssetType" extern="1" final="1">
		<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="5" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "BINARY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="6" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "FONT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="7" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "IMAGE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MANIFEST public="1" get="inline" set="null" expr="cast &quot;MANIFEST&quot;" line="8" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MANIFEST"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MANIFEST>
		<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="9" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MUSIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="10" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "SOUND"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="11" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEMPLATE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="12" static="1">
			<x path="lime.utils.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEXT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.utils.Assets" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Assets.hx">
		<cache public="1" expr="new AssetCache()" line="39" static="1">
			<c path="lime.utils.AssetCache"/>
			<meta><m n=":value"><e>new AssetCache()</e></m></meta>
		</cache>
		<onChange public="1" expr="new Event&lt;Void&gt;()" line="40" static="1">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<bundlePaths expr="new Map&lt;String,String&gt;()" line="42" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m></meta>
		</bundlePaths>
		<libraries set="null" expr="new Map&lt;String,AssetLibrary&gt;()" line="43" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="lime.utils.AssetLibrary"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,AssetLibrary>()]]></e></m></meta>
		</libraries>
		<libraryPaths expr="new Map&lt;String,String&gt;()" line="44" static="1">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m></meta>
		</libraryPaths>
		<exists public="1" set="method" line="46" static="1">
			<f a="id:?type" v=":null">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</exists>
		<getAsset public="1" set="method" line="71" static="1">
			<f a="id:type:useCache">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Gets an instance of a cached or embedded asset
	 * @usage		var sound = Assets.getAsset("sound.wav", SOUND);
	 * @param	id		The ID or asset path for the asset
	 * @return		An Asset object, or null.</haxe_doc>
		</getAsset>
		<getAudioBuffer public="1" set="method" line="156" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.media.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getAudioBuffer ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getAudioBuffer>
		<getBytes public="1" set="method" line="167" static="1">
			<f a="id">
				<c path="String"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new Bytes object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="178" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.text.Font"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getImage public="1" set="method" line="190" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getImage>
		<getLibrary public="1" set="method" line="195" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
</f></getLibrary>
		<getPath public="1" set="method" line="211" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath("image.jpg");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset (or null)</haxe_doc>
		</getPath>
		<getText public="1" set="method" line="242" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<hasLibrary public="1" set="method" line="247" static="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasLibrary>
		<isLocal public="1" set="method" line="257" static="1">
			<f a="id:?type:?useCache" v=":null:true">
				<c path="String"/>
				<x path="lime.utils.AssetType"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true, type : null }</e></m></meta>
		</isLocal>
		<isValidAudio set="method" line="272" static="1"><f a="buffer">
	<c path="lime.media.AudioBuffer"/>
	<x path="Bool"/>
</f></isValidAudio>
		<isValidImage set="method" line="279" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
</f></isValidImage>
		<list public="1" set="method" line="286" static="1">
			<f a="?type" v="null">
				<x path="lime.utils.AssetType"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</list>
		<loadAsset public="1" set="method" line="303" static="1"><f a="id:type:useCache">
	<c path="String"/>
	<x path="lime.utils.AssetType"/>
	<x path="Bool"/>
	<c path="lime.app.Future"><d/></c>
</f></loadAsset>
		<loadAudioBuffer public="1" set="method" line="375" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadAudioBuffer>
		<loadBytes public="1" set="method" line="380" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="385" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.text.Font"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadFont>
		<loadImage public="1" set="method" line="390" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadImage>
		<loadLibrary public="1" set="method" line="395" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c>
</f></loadLibrary>
		<loadText public="1" set="method" line="488" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<registerLibrary public="1" set="method" line="493" static="1"><f a="name:library">
	<c path="String"/>
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></registerLibrary>
		<unloadLibrary public="1" set="method" line="515" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<__cacheBreak set="method" line="536" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__cacheBreak>
		<__libraryNotFound set="method" line="555" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__libraryNotFound>
		<library_onChange set="method" line="573" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</library_onChange>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access
 * embedded images, fonts, sounds and other resource files.</p>
 *
 * <p>The contents are populated automatically when an application
 * is compiled using the Lime command-line tools, based on the
 * contents of the project file.</p>
 *
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application.</p>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":access"><e>lime.utils.AssetLibrary</e></m>
		</meta>
	</class>
	<class path="lime.utils._Assets.LibrarySymbol" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Assets.hx" private="1" module="lime.utils.Assets">
		<library public="1" set="null"><c path="lime.utils.AssetLibrary"/></library>
		<libraryName public="1" set="null"><c path="String"/></libraryName>
		<symbolName public="1" set="null"><c path="String"/></symbolName>
		<isLocal public="1" get="inline" set="null" line="598"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<exists public="1" get="inline" set="null" line="601"><f a="?type">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<new public="1" get="inline" set="null" line="590"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.BytePointer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/BytePointer.hx">
		<from>
			<icast><c path="lime.utils.BytePointerData"/></icast>
			<icast field="fromArrayBufferView"><c path="lime.utils.ArrayBufferView"/></icast>
			<icast field="fromArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="fromBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="fromBytesData"><t path="haxe.io.BytesData"/></icast>
			<icast field="fromLimeBytes"><t path="lime.utils._Bytes.LimeBytes"/></icast>
		</from>
		<this><c path="lime.utils.BytePointerData"/></this>
		<to>
			<icast><c path="lime.utils.BytePointerData"/></icast>
			<icast field="toUInt8Array"><x path="lime.utils.UInt8Array"/></icast>
			<icast field="toUInt8ClampedArray"><x path="lime.utils.UInt8ClampedArray"/></icast>
			<icast field="toInt8Array"><x path="lime.utils.Int8Array"/></icast>
			<icast field="toUInt16Array"><x path="lime.utils.UInt16Array"/></icast>
			<icast field="toInt16Array"><x path="lime.utils.Int16Array"/></icast>
			<icast field="toUInt32Array"><x path="lime.utils.UInt32Array"/></icast>
			<icast field="toInt32Array"><x path="lime.utils.Int32Array"/></icast>
			<icast field="toFloat32Array"><x path="lime.utils.Float32Array"/></icast>
			<icast field="toFloat64Array"><x path="lime.utils.Float64Array"/></icast>
		</to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":access"><e>lime.utils.BytePointerData</e></m>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="lime.utils._BytePointer.BytePointer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/BytePointer.hx" private="1" module="lime.utils.BytePointer" final="1">
	<_new public="1" get="inline" set="null" line="13" static="1">
		<f a="?bytes:?offset" v="null:0">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":value"><e>{ offset : 0, bytes : null }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<set public="1" set="method" line="18" static="1">
		<f a="this:?bytes:?bufferView:?buffer:?offset">
			<c path="lime.utils.BytePointerData"/>
			<c path="haxe.io.Bytes"/>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<__arrayGet get="inline" set="null" line="46" static="1">
		<f a="this:index">
			<c path="lime.utils.BytePointerData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</__arrayGet>
	<__arraySet get="inline" set="null" line="51" static="1">
		<f a="this:index:value">
			<c path="lime.utils.BytePointerData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</__arraySet>
	<fromArrayBufferView public="1" set="method" line="57" static="1">
		<f a="arrayBufferView">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBufferView>
	<fromArrayBuffer public="1" set="method" line="68" static="1">
		<f a="buffer">
			<x path="lime.utils.ArrayBuffer"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBuffer>
	<fromBytes public="1" set="method" line="79" static="1">
		<f a="bytes">
			<c path="haxe.io.Bytes"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytes>
	<fromBytesData public="1" set="method" line="84" static="1">
		<f a="bytesData">
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesData>
	<fromFile public="1" set="method" line="91" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.BytePointer"/>
</f></fromFile>
	<fromLimeBytes public="1" set="method" line="96" static="1">
		<f a="bytes">
			<t path="lime.utils._Bytes.LimeBytes"/>
			<x path="lime.utils.BytePointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromLimeBytes>
	<toUInt8Array public="1" set="method" line="101" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt8Array>
	<toUInt8ClampedArray public="1" set="method" line="110" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt8ClampedArray>
	<toInt8Array public="1" set="method" line="121" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt8Array>
	<toUInt16Array public="1" set="method" line="132" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt16Array>
	<toInt16Array public="1" set="method" line="143" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt16Array>
	<toUInt32Array public="1" set="method" line="154" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toUInt32Array>
	<toInt32Array public="1" set="method" line="165" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toInt32Array>
	<toFloat32Array public="1" set="method" line="176" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toFloat32Array>
	<toFloat64Array public="1" set="method" line="187" static="1">
		<f a="bytePointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toFloat64Array>
	<meta>
		<m n=":access"><e>lime.utils.BytePointerData</e></m>
		<m n=":access"><e>haxe.io.Bytes</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._BytePointer.BytePointer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/BytePointer.hx" private="1" module="lime.utils.BytePointer" final="1">
		<_new public="1" get="inline" set="null" line="13" static="1">
			<f a="?bytes:?offset" v="null:0">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":value"><e>{ offset : 0, bytes : null }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<set public="1" set="method" line="18" static="1">
			<f a="this:?bytes:?bufferView:?buffer:?offset">
				<c path="lime.utils.BytePointerData"/>
				<c path="haxe.io.Bytes"/>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<__arrayGet get="inline" set="null" line="46" static="1">
			<f a="this:index">
				<c path="lime.utils.BytePointerData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</__arrayGet>
		<__arraySet get="inline" set="null" line="51" static="1">
			<f a="this:index:value">
				<c path="lime.utils.BytePointerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</__arraySet>
		<fromArrayBufferView public="1" set="method" line="57" static="1">
			<f a="arrayBufferView">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBufferView>
		<fromArrayBuffer public="1" set="method" line="68" static="1">
			<f a="buffer">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBuffer>
		<fromBytes public="1" set="method" line="79" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytes>
		<fromBytesData public="1" set="method" line="84" static="1">
			<f a="bytesData">
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesData>
		<fromFile public="1" set="method" line="91" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.BytePointer"/>
</f></fromFile>
		<fromLimeBytes public="1" set="method" line="96" static="1">
			<f a="bytes">
				<t path="lime.utils._Bytes.LimeBytes"/>
				<x path="lime.utils.BytePointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromLimeBytes>
		<toUInt8Array public="1" set="method" line="101" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt8Array>
		<toUInt8ClampedArray public="1" set="method" line="110" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt8ClampedArray>
		<toInt8Array public="1" set="method" line="121" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt8Array>
		<toUInt16Array public="1" set="method" line="132" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt16Array>
		<toInt16Array public="1" set="method" line="143" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt16Array>
		<toUInt32Array public="1" set="method" line="154" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toUInt32Array>
		<toInt32Array public="1" set="method" line="165" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toInt32Array>
		<toFloat32Array public="1" set="method" line="176" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toFloat32Array>
		<toFloat64Array public="1" set="method" line="187" static="1">
			<f a="bytePointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toFloat64Array>
		<meta>
			<m n=":access"><e>lime.utils.BytePointerData</e></m>
			<m n=":access"><e>haxe.io.Bytes</e></m>
		</meta>
	</class>
	<class path="lime.utils.BytePointerData" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/BytePointer.hx" module="lime.utils.BytePointer">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<offset public="1"><x path="Int"/></offset>
		<new public="1" set="method" line="204"><f a="bytes:offset">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<abstract path="lime.utils.Bytes" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Bytes.hx">
		<from><icast><t path="haxe.io._Bytes.HaxeBytes"/></icast></from>
		<this><t path="haxe.io._Bytes.HaxeBytes"/></this>
		<to><icast><t path="haxe.io._Bytes.HaxeBytes"/></icast></to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":forward"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="lime.utils._Bytes.Bytes_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Bytes.hx" private="1" module="lime.utils.Bytes" final="1">
	<_new public="1" set="method" line="19" static="1">
		<f a="length:bytesData">
			<x path="Int"/>
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<alloc public="1" set="method" line="30" static="1"><f a="length">
	<x path="Int"/>
	<x path="lime.utils.Bytes"/>
</f></alloc>
	<compress public="1" set="method" line="38" static="1">
		<f a="this:algorithm">
			<t path="haxe.io._Bytes.HaxeBytes"/>
			<e path="lime.utils.CompressionAlgorithm"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</compress>
	<decompress public="1" set="method" line="59" static="1">
		<f a="this:algorithm">
			<t path="haxe.io._Bytes.HaxeBytes"/>
			<e path="lime.utils.CompressionAlgorithm"/>
			<x path="lime.utils.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</decompress>
	<fastGet public="1" get="inline" set="null" line="80" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
	<fromBytes public="1" set="method" line="85" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="lime.utils.Bytes"/>
</f></fromBytes>
	<fromFile public="1" set="method" line="92" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></fromFile>
	<loadFromBytes public="1" set="method" line="107" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromBytes>
	<loadFromFile public="1" set="method" line="112" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromFile>
	<ofData public="1" set="method" line="118" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<x path="lime.utils.Bytes"/>
</f></ofData>
	<ofString public="1" set="method" line="124" static="1"><f a="s">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></ofString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
		<m n=":access"><e>haxe.io.Bytes</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Bytes.Bytes_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Bytes.hx" private="1" module="lime.utils.Bytes" final="1">
		<_new public="1" set="method" line="19" static="1">
			<f a="length:bytesData">
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<alloc public="1" set="method" line="30" static="1"><f a="length">
	<x path="Int"/>
	<x path="lime.utils.Bytes"/>
</f></alloc>
		<compress public="1" set="method" line="38" static="1">
			<f a="this:algorithm">
				<t path="haxe.io._Bytes.HaxeBytes"/>
				<e path="lime.utils.CompressionAlgorithm"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</compress>
		<decompress public="1" set="method" line="59" static="1">
			<f a="this:algorithm">
				<t path="haxe.io._Bytes.HaxeBytes"/>
				<e path="lime.utils.CompressionAlgorithm"/>
				<x path="lime.utils.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</decompress>
		<fastGet public="1" get="inline" set="null" line="80" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
		<fromBytes public="1" set="method" line="85" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="lime.utils.Bytes"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="92" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></fromFile>
		<loadFromBytes public="1" set="method" line="107" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromBytes>
		<loadFromFile public="1" set="method" line="112" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadFromFile>
		<ofData public="1" set="method" line="118" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<x path="lime.utils.Bytes"/>
</f></ofData>
		<ofString public="1" set="method" line="124" static="1"><f a="s">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></ofString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime._internal.backend.native.NativeCFFI</e></m>
			<m n=":access"><e>haxe.io.Bytes</e></m>
		</meta>
	</class>
	<enum path="lime.utils.CompressionAlgorithm" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<GZIP/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.utils.DataPointer" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/DataPointer.hx">
		<from>
			<icast field="fromFloat"><x path="Float"/></icast>
			<icast field="fromBytesPointer"><x path="lime.utils.BytePointer"/></icast>
			<icast field="fromArrayBufferView"><c path="lime.utils.ArrayBufferView"/></icast>
			<icast field="fromArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="fromBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="fromBytesData"><t path="haxe.io.BytesData"/></icast>
			<icast field="fromLimeBytes"><t path="lime.utils._Bytes.LimeBytes"/></icast>
		</from>
		<this><t path="lime.utils._DataPointer.DataPointerType"/></this>
		<to><icast><t path="lime.utils._DataPointer.DataPointerType"/></icast></to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":transitive"/>
		</meta>
		<impl><class path="lime.utils._DataPointer.DataPointer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer" final="1">
	<_new set="method" line="21" static="1">
		<f a="data">
			<d/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromFloat set="method" line="37" static="1">
		<f a="value">
			<x path="Float"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromFloat>
	<fromBytesPointer public="1" set="method" line="62" static="1">
		<f a="pointer">
			<x path="lime.utils.BytePointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesPointer>
	<fromArrayBufferView public="1" set="method" line="76" static="1">
		<f a="arrayBufferView">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBufferView>
	<fromArrayBuffer public="1" set="method" line="90" static="1">
		<f a="buffer">
			<x path="lime.utils.ArrayBuffer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBuffer>
	<fromBytes public="1" set="method" line="100" static="1">
		<f a="bytes">
			<c path="haxe.io.Bytes"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytes>
	<fromBytesData public="1" set="method" line="114" static="1">
		<f a="bytesData">
			<t path="haxe.io.BytesData"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesData>
	<fromLimeBytes public="1" set="method" line="124" static="1">
		<f a="bytes">
			<t path="lime.utils._Bytes.LimeBytes"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromLimeBytes>
	<fromFile public="1" set="method" line="141" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.DataPointer"/>
</f></fromFile>
	<__withOffset set="method" line="150" static="1"><f a="data:offset">
	<x path="lime.utils.DataPointer"/>
	<x path="Int"/>
	<x path="lime.utils.DataPointer"/>
</f></__withOffset>
	<equals get="inline" set="null" line="161" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equals>
	<equalsPointer get="inline" set="null" line="166" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equalsPointer>
	<greaterThan get="inline" set="null" line="171" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</greaterThan>
	<greaterThanOrEqual get="inline" set="null" line="183" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</greaterThanOrEqual>
	<lessThan get="inline" set="null" line="195" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lessThan>
	<lessThanOrEqual get="inline" set="null" line="207" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lessThanOrEqual>
	<notEquals get="inline" set="null" line="219" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEquals>
	<notEqualsPointer get="inline" set="null" line="224" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEqualsPointer>
	<plus get="inline" set="null" line="229" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</plus>
	<plusPointer get="inline" set="null" line="234" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A + B</e></m>
		</meta>
	</plusPointer>
	<minus get="inline" set="null" line="239" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="Int"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</minus>
	<minusPointer get="inline" set="null" line="244" static="1">
		<f a="a:b">
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
			<x path="lime.utils.DataPointer"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A - B</e></m>
		</meta>
	</minusPointer>
	<meta><m n=":access"><e>haxe.io.Bytes</e></m></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._DataPointer.DataPointer_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer" final="1">
		<_new set="method" line="21" static="1">
			<f a="data">
				<d/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromFloat set="method" line="37" static="1">
			<f a="value">
				<x path="Float"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromFloat>
		<fromBytesPointer public="1" set="method" line="62" static="1">
			<f a="pointer">
				<x path="lime.utils.BytePointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesPointer>
		<fromArrayBufferView public="1" set="method" line="76" static="1">
			<f a="arrayBufferView">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBufferView>
		<fromArrayBuffer public="1" set="method" line="90" static="1">
			<f a="buffer">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBuffer>
		<fromBytes public="1" set="method" line="100" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytes>
		<fromBytesData public="1" set="method" line="114" static="1">
			<f a="bytesData">
				<t path="haxe.io.BytesData"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesData>
		<fromLimeBytes public="1" set="method" line="124" static="1">
			<f a="bytes">
				<t path="lime.utils._Bytes.LimeBytes"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromLimeBytes>
		<fromFile public="1" set="method" line="141" static="1"><f a="path">
	<c path="String"/>
	<x path="lime.utils.DataPointer"/>
</f></fromFile>
		<__withOffset set="method" line="150" static="1"><f a="data:offset">
	<x path="lime.utils.DataPointer"/>
	<x path="Int"/>
	<x path="lime.utils.DataPointer"/>
</f></__withOffset>
		<equals get="inline" set="null" line="161" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equals>
		<equalsPointer get="inline" set="null" line="166" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equalsPointer>
		<greaterThan get="inline" set="null" line="171" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</greaterThan>
		<greaterThanOrEqual get="inline" set="null" line="183" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</greaterThanOrEqual>
		<lessThan get="inline" set="null" line="195" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lessThan>
		<lessThanOrEqual get="inline" set="null" line="207" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lessThanOrEqual>
		<notEquals get="inline" set="null" line="219" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEquals>
		<notEqualsPointer get="inline" set="null" line="224" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEqualsPointer>
		<plus get="inline" set="null" line="229" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</plus>
		<plusPointer get="inline" set="null" line="234" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A + B</e></m>
			</meta>
		</plusPointer>
		<minus get="inline" set="null" line="239" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="Int"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</minus>
		<minusPointer get="inline" set="null" line="244" static="1">
			<f a="a:b">
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
				<x path="lime.utils.DataPointer"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A - B</e></m>
			</meta>
		</minusPointer>
		<meta><m n=":access"><e>haxe.io.Bytes</e></m></meta>
	</class>
	<typedef path="lime.utils._DataPointer.DataPointerType" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/DataPointer.hx" private="1" module="lime.utils.DataPointer"><x path="Int"/></typedef>
	<class path="lime.utils.DataView" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/DataView.hx">
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteLength public="1"><x path="Int"/></byteLength>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<getInt8 public="1" get="inline" set="null" line="189"><f a="byteOffset">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getInt16 public="1" get="inline" set="null" line="197">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt16>
		<getInt32 public="1" get="inline" set="null" line="206">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt32>
		<getUint8 public="1" get="inline" set="null" line="215"><f a="byteOffset">
	<x path="Int"/>
	<x path="UInt"/>
</f></getUint8>
		<getUint16 public="1" get="inline" set="null" line="223">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint16>
		<getUint32 public="1" get="inline" set="null" line="232">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint32>
		<getFloat32 public="1" get="inline" set="null" line="241">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat32>
		<getFloat64 public="1" get="inline" set="null" line="250">
			<f a="byteOffset:?littleEndian" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat64>
		<setInt8 public="1" get="inline" set="null" line="259"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setInt16 public="1" get="inline" set="null" line="267">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setInt16>
		<setInt32 public="1" get="inline" set="null" line="275">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setInt32>
		<setUint8 public="1" get="inline" set="null" line="283"><f a="byteOffset:value">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setUint8>
		<setUint16 public="1" get="inline" set="null" line="291">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint16>
		<setUint32 public="1" get="inline" set="null" line="299">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint32>
		<setFloat32 public="1" get="inline" set="null" line="307">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat32>
		<setFloat64 public="1" get="inline" set="null" line="315">
			<f a="byteOffset:value:?littleEndian" v="::true">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat64>
		<new public="1" get="inline" set="null" line="163">
			<f a="buffer:?byteOffset:?byteLength" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ byteLength : null, byteOffset : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.Float32Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="93" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<hello public="1" static="1"><x path="Int"/></hello>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="99" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="131" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="135" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="140" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="146" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="149" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":extern"/>
		</meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="154" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="161" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
</class></impl>
	</abstract>
	<class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<hello public="1" static="1"><x path="Int"/></hello>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="131" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="135" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="140" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="146" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="149" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":extern"/>
			</meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="154" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="161" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
	</class>
	<abstract path="lime.utils.Float64Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float64Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="91" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>8</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="96" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="128" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="132" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="128" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="132" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int16Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="91" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="96" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="128" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="132" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="128" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="132" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int32Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="91" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="96" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="128" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="132" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="128" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="132" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.Int8Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="89" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="94" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="126" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="130" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="94" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="126" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="130" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<class path="lime.utils.Log" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Log.hx">
		<level public="1" static="1"><x path="lime.utils.LogLevel"/></level>
		<throwErrors public="1" expr="true" line="12" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</throwErrors>
		<debug public="1" set="method" line="14" static="1"><f a="message:?info">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></debug>
		<error public="1" set="method" line="26" static="1"><f a="message:?info">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></error>
		<info public="1" set="method" line="47" static="1"><f a="message:?info">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></info>
		<print public="1" get="inline" set="null" line="59" static="1">
			<f a="message">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</print>
		<println public="1" get="inline" set="null" line="72" static="1">
			<f a="message">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</println>
		<verbose public="1" set="method" line="85" static="1"><f a="message:?info">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></verbose>
		<warn public="1" set="method" line="93" static="1"><f a="message:?info">
	<d/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></warn>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.LogLevel" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/LogLevel.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.utils._LogLevel.LogLevel_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/LogLevel.hx" private="1" module="lime.utils.LogLevel" final="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<ERROR public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ERROR>
	<WARN public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WARN>
	<INFO public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INFO>
	<DEBUG public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEBUG>
	<VERBOSE public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
		<x path="lime.utils.LogLevel"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VERBOSE>
	<gt get="inline" set="null" line="12" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="17" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="22" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="27" static="1">
		<f a="a:b">
			<x path="lime.utils.LogLevel"/>
			<x path="lime.utils.LogLevel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._LogLevel.LogLevel_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/LogLevel.hx" private="1" module="lime.utils.LogLevel" final="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="5" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<ERROR public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ERROR>
		<WARN public="1" get="inline" set="null" expr="cast 2" line="7" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WARN>
		<INFO public="1" get="inline" set="null" expr="cast 3" line="8" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INFO>
		<DEBUG public="1" get="inline" set="null" expr="cast 4" line="9" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEBUG>
		<VERBOSE public="1" get="inline" set="null" expr="cast 5" line="10" static="1">
			<x path="lime.utils.LogLevel"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VERBOSE>
		<gt get="inline" set="null" line="12" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="17" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="22" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="27" static="1">
			<f a="a:b">
				<x path="lime.utils.LogLevel"/>
				<x path="lime.utils.LogLevel"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.utils.ObjectPool" params="T" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/ObjectPool.hx">
		<activeObjects public="1" set="null"><x path="Int"/></activeObjects>
		<inactiveObjects public="1" set="null"><x path="Int"/></inactiveObjects>
		<size public="1" get="accessor" set="accessor"><x path="Null"><x path="Int"/></x></size>
		<__inactiveObject0>
			<c path="lime.utils.ObjectPool.T"/>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObject0>
		<__inactiveObject1>
			<c path="lime.utils.ObjectPool.T"/>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObject1>
		<__inactiveObjectList>
			<t path="List"><c path="lime.utils.ObjectPool.T"/></t>
			<meta><m n=":noCompletion"/></meta>
		</__inactiveObjectList>
		<__pool>
			<t path="Map">
				<c path="lime.utils.ObjectPool.T"/>
				<x path="Bool"/>
			</t>
			<meta><m n=":noCompletion"/></meta>
		</__pool>
		<__size>
			<x path="Null"><x path="Int"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__size>
		<add public="1" set="method" line="46"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></add>
		<clean public="1" set="dynamic" line="56"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></clean>
		<clear public="1" set="method" line="58"><f a=""><x path="Void"/></f></clear>
		<create public="1" set="dynamic" line="70"><f a=""><c path="lime.utils.ObjectPool.T"/></f></create>
		<get public="1" set="method" line="75"><f a=""><c path="lime.utils.ObjectPool.T"/></f></get>
		<release public="1" set="method" line="97"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></release>
		<remove public="1" set="method" line="123"><f a="object">
	<c path="lime.utils.ObjectPool.T"/>
	<x path="Void"/>
</f></remove>
		<__addInactive get="inline" set="null" line="150">
			<f a="object">
				<c path="lime.utils.ObjectPool.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__addInactive>
		<__getInactive get="inline" set="null" line="172">
			<f a=""><c path="lime.utils.ObjectPool.T"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getInactive>
		<__removeInactive set="method" line="211">
			<f a="count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__removeInactive>
		<get_size set="method" line="247">
			<f a=""><x path="Null"><x path="Int"/></x></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<set_size set="method" line="252">
			<f a="value">
				<x path="Null"><x path="Int"/></x>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<new public="1" set="method" line="21">
			<f a="?create:?clean:?size" v="null:null:null">
				<f a=""><c path="lime.utils.ObjectPool.T"/></f>
				<f a="">
					<c path="lime.utils.ObjectPool.T"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ size : null, clean : null, create : null }</e></m></meta>
		</new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="lime.utils.PackedAssetLibrary" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/PackedAssetLibrary.hx">
		<extends path="lime.utils.AssetLibrary"/>
		<fromBytes public="1" set="method" line="40" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.utils.PackedAssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="45" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.utils.PackedAssetLibrary"/>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</fromFile>
		<fromManifest public="1" set="method" line="50" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.utils.PackedAssetLibrary"/>
</f></fromManifest>
		<loadFromBytes public="1" set="method" line="317" static="1">
			<f a="bytes:?rootPath" v=":null">
				<x path="lime.utils.Bytes"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromBytes>
		<loadFromFile public="1" set="method" line="326" static="1">
			<f a="path:?rootPath" v=":null">
				<c path="String"/>
				<c path="String"/>
				<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ rootPath : null }</e></m></meta>
		</loadFromFile>
		<loadFromManifest public="1" set="method" line="335" static="1"><f a="manifest">
	<c path="lime.utils.AssetManifest"/>
	<c path="lime.app.Future"><c path="lime.utils.PackedAssetLibrary"/></c>
</f></loadFromManifest>
		<id>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</id>
		<lengths expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</lengths>
		<packedData>
			<x path="lime.utils.Bytes"/>
			<meta><m n=":noCompletion"/></meta>
		</packedData>
		<positions expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</positions>
		<type>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</type>
		<rootPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</rootPath>
		<getAudioBuffer public="1" set="method" line="55" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.media.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="76" override="1"><f a="id">
	<c path="String"/>
	<x path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="98" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="119" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getText public="1" set="method" line="136" override="1"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="156" override="1"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<load public="1" set="method" line="161" override="1"><f a=""><c path="lime.app.Future"><c path="lime.utils.AssetLibrary"/></c></f></load>
		<loadAudioBuffer public="1" set="method" line="258" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.media.AudioBuffer"/></c>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="279" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><x path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="296" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="344" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
</f></loadImage>
		<loadText public="1" set="method" line="361" override="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<unload public="1" set="method" line="396" override="1"><f a=""><x path="Void"/></f></unload>
		<__fromManifest set="method" line="398" override="1">
			<f a="manifest">
				<c path="lime.utils.AssetManifest"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromManifest>
		<__assetLoaded set="method" line="418" override="1">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__assetLoaded>
		<new public="1" set="method" line="32"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="lime.utils.Preloader" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Preloader.hx">
		<extends path="flash.display.Sprite"/>
		<complete public="1" set="null"><x path="Bool"/></complete>
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app._Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<onProgress public="1" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app._Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onProgress>
		<bytesLoaded>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesLoaded>
		<bytesLoadedCache expr="new Map&lt;AssetLibrary,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="lime.utils.AssetLibrary"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<AssetLibrary,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesLoadedCache>
		<bytesLoadedCache2 expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesLoadedCache2>
		<bytesTotal>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</bytesTotal>
		<bytesTotalCache expr="new Map&lt;String,Int&gt;()">
			<x path="haxe.ds.Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Int>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</bytesTotalCache>
		<initLibraryNames>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</initLibraryNames>
		<libraries>
			<c path="Array"><c path="lime.utils.AssetLibrary"/></c>
			<meta><m n=":noCompletion"/></meta>
		</libraries>
		<libraryNames>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</libraryNames>
		<loadedLibraries>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</loadedLibraries>
		<loadedStage>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</loadedStage>
		<preloadComplete>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</preloadComplete>
		<preloadStarted>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</preloadStarted>
		<simulateProgress>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</simulateProgress>
		<addLibrary public="1" set="method" line="107"><f a="library">
	<c path="lime.utils.AssetLibrary"/>
	<x path="Void"/>
</f></addLibrary>
		<addLibraryName public="1" set="method" line="112"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></addLibraryName>
		<load public="1" set="method" line="120"><f a=""><x path="Void"/></f></load>
		<loadedAssetLibrary set="method" line="184">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ name : null }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</loadedAssetLibrary>
		<start set="method" line="205">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</start>
		<update set="method" line="221">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</update>
		<updateProgress set="method" line="223">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</updateProgress>
		<current_onEnter set="method" line="309">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</current_onEnter>
		<loaderInfo_onComplete set="method" line="336">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onComplete>
		<loaderInfo_onInit set="method" line="350">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onInit>
		<loaderInfo_onProgress set="method" line="365">
			<f a="event">
				<c path="flash.events.ProgressEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</loaderInfo_onProgress>
		<new public="1" set="method" line="51"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.utils.AssetLibrary</e></m>
			<m n=":fileXml"><e>"tags=\"haxe,release\""</e></m>
			<m n=":noDebug"/>
		</meta>
	</class>
	<abstract path="lime.utils.Resource" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Resource.hx">
		<from>
			<icast><c path="haxe.io.Bytes"/></icast>
			<icast field="__fromString"><c path="String"/></icast>
		</from>
		<this><c path="haxe.io.Bytes"/></this>
		<to>
			<icast><c path="haxe.io.Bytes"/></icast>
			<icast field="__toString"><c path="String"/></icast>
		</to>
		<meta><m n=":transitive"/></meta>
		<impl><class path="lime.utils._Resource.Resource_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Resource.hx" private="1" module="lime.utils.Resource" final="1">
	<_new public="1" set="method" line="8" static="1">
		<f a="?size" v="0">
			<x path="Int"/>
			<x path="lime.utils.Resource"/>
		</f>
		<meta>
			<m n=":value"><e>{ size : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<__fromString get="inline" set="null" line="13" static="1">
		<f a="value">
			<c path="String"/>
			<x path="lime.utils.Resource"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromString>
	<__toString get="inline" set="null" line="18" static="1">
		<f a="value">
			<x path="lime.utils.Resource"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</__toString>
</class></impl>
	</abstract>
	<class path="lime.utils._Resource.Resource_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/Resource.hx" private="1" module="lime.utils.Resource" final="1">
		<_new public="1" set="method" line="8" static="1">
			<f a="?size" v="0">
				<x path="Int"/>
				<x path="lime.utils.Resource"/>
			</f>
			<meta>
				<m n=":value"><e>{ size : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<__fromString get="inline" set="null" line="13" static="1">
			<f a="value">
				<c path="String"/>
				<x path="lime.utils.Resource"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromString>
		<__toString get="inline" set="null" line="18" static="1">
			<f a="value">
				<x path="lime.utils.Resource"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</__toString>
	</class>
	<abstract path="lime.utils.UInt16Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="91" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="96" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="128" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="132" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="128" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="132" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.UInt32Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="91" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="96" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="128" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="132" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="137" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="143" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="148" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="155" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="128" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="132" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="137" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="143" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="148" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="155" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
	<abstract path="lime.utils.UInt8Array" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="89" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="94" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="126" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="130" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="135" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString get="inline" set="null" line="141" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="144" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="149" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="156" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="94" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="126" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="130" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="135" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString get="inline" set="null" line="141" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="144" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="149" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="156" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
	</class>
	<abstract path="lime.utils.UInt8ClampedArray" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8ClampedArray.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="101" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="106" static="1">
		<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="138" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" get="inline" set="null" line="142" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" get="inline" set="null" line="147" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="153" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="158" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Null"><x path="UInt"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="165" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
			<m n=":extern"/>
		</meta>
	</__set>
	<toString get="inline" set="null" line="171" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Null"><c path="String"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="/home/runner/work/api.lime.software/api.lime.software/lime/src/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="106" static="1">
			<f a="?elements:?buffer:?array:?view:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="138" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" get="inline" set="null" line="142" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" get="inline" set="null" line="147" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="153" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="158" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Null"><x path="UInt"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="165" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
				<m n=":extern"/>
			</meta>
		</__set>
		<toString get="inline" set="null" line="171" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
	</class>
</haxe>